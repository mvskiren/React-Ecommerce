{"ast":null,"code":"import invariant from 'invariant';\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction _compilePattern(pattern) {\n  var regexpSource = '';\n  var paramNames = [];\n  var tokens = [];\n  var match = void 0,\n      lastIndex = 0,\n      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\\*\\*|\\*|\\(|\\)|\\\\\\(|\\\\\\)/g;\n\n  while (match = matcher.exec(pattern)) {\n    if (match.index !== lastIndex) {\n      tokens.push(pattern.slice(lastIndex, match.index));\n      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));\n    }\n\n    if (match[1]) {\n      regexpSource += '([^/]+)';\n      paramNames.push(match[1]);\n    } else if (match[0] === '**') {\n      regexpSource += '(.*)';\n      paramNames.push('splat');\n    } else if (match[0] === '*') {\n      regexpSource += '(.*?)';\n      paramNames.push('splat');\n    } else if (match[0] === '(') {\n      regexpSource += '(?:';\n    } else if (match[0] === ')') {\n      regexpSource += ')?';\n    } else if (match[0] === '\\\\(') {\n      regexpSource += '\\\\(';\n    } else if (match[0] === '\\\\)') {\n      regexpSource += '\\\\)';\n    }\n\n    tokens.push(match[0]);\n    lastIndex = matcher.lastIndex;\n  }\n\n  if (lastIndex !== pattern.length) {\n    tokens.push(pattern.slice(lastIndex, pattern.length));\n    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));\n  }\n\n  return {\n    pattern: pattern,\n    regexpSource: regexpSource,\n    paramNames: paramNames,\n    tokens: tokens\n  };\n}\n\nvar CompiledPatternsCache = Object.create(null);\nexport function compilePattern(pattern) {\n  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);\n  return CompiledPatternsCache[pattern];\n}\n/**\n * Attempts to match a pattern on the given pathname. Patterns may use\n * the following special characters:\n *\n * - :paramName     Matches a URL segment up to the next /, ?, or #. The\n *                  captured string is considered a \"param\"\n * - ()             Wraps a segment of the URL that is optional\n * - *              Consumes (non-greedy) all characters up to the next\n *                  character in the pattern, or to the end of the URL if\n *                  there is none\n * - **             Consumes (greedy) all characters up to the next character\n *                  in the pattern, or to the end of the URL if there is none\n *\n *  The function calls callback(error, matched) when finished.\n * The return value is an object with the following properties:\n *\n * - remainingPathname\n * - paramNames\n * - paramValues\n */\n\nexport function matchPattern(pattern, pathname) {\n  // Ensure pattern starts with leading slash for consistency with pathname.\n  if (pattern.charAt(0) !== '/') {\n    pattern = '/' + pattern;\n  }\n\n  var _compilePattern2 = compilePattern(pattern),\n      regexpSource = _compilePattern2.regexpSource,\n      paramNames = _compilePattern2.paramNames,\n      tokens = _compilePattern2.tokens;\n\n  if (pattern.charAt(pattern.length - 1) !== '/') {\n    regexpSource += '/?'; // Allow optional path separator at end.\n  } // Special-case patterns like '*' for catch-all routes.\n\n\n  if (tokens[tokens.length - 1] === '*') {\n    regexpSource += '$';\n  }\n\n  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));\n\n  if (match == null) {\n    return null;\n  }\n\n  var matchedPath = match[0];\n  var remainingPathname = pathname.substr(matchedPath.length);\n\n  if (remainingPathname) {\n    // Require that the match ends at a path separator, if we didn't match\n    // the full path, so any remaining pathname is a new path segment.\n    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {\n      return null;\n    } // If there is a remaining pathname, treat the path separator as part of\n    // the remaining pathname for properly continuing the match.\n\n\n    remainingPathname = '/' + remainingPathname;\n  }\n\n  return {\n    remainingPathname: remainingPathname,\n    paramNames: paramNames,\n    paramValues: match.slice(1).map(function (v) {\n      return v && decodeURIComponent(v);\n    })\n  };\n}\nexport function getParamNames(pattern) {\n  return compilePattern(pattern).paramNames;\n}\nexport function getParams(pattern, pathname) {\n  var match = matchPattern(pattern, pathname);\n\n  if (!match) {\n    return null;\n  }\n\n  var paramNames = match.paramNames,\n      paramValues = match.paramValues;\n  var params = {};\n  paramNames.forEach(function (paramName, index) {\n    params[paramName] = paramValues[index];\n  });\n  return params;\n}\n/**\n * Returns a version of the given pattern with params interpolated. Throws\n * if there is a dynamic segment of the pattern for which there is no param.\n */\n\nexport function formatPattern(pattern, params) {\n  params = params || {};\n\n  var _compilePattern3 = compilePattern(pattern),\n      tokens = _compilePattern3.tokens;\n\n  var parenCount = 0,\n      pathname = '',\n      splatIndex = 0,\n      parenHistory = [];\n  var token = void 0,\n      paramName = void 0,\n      paramValue = void 0;\n\n  for (var i = 0, len = tokens.length; i < len; ++i) {\n    token = tokens[i];\n\n    if (token === '*' || token === '**') {\n      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;\n      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing splat #%s for path \"%s\"', splatIndex, pattern) : invariant(false) : void 0;\n      if (paramValue != null) pathname += encodeURI(paramValue);\n    } else if (token === '(') {\n      parenHistory[parenCount] = '';\n      parenCount += 1;\n    } else if (token === ')') {\n      var parenText = parenHistory.pop();\n      parenCount -= 1;\n      if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;\n    } else if (token === '\\\\(') {\n      pathname += '(';\n    } else if (token === '\\\\)') {\n      pathname += ')';\n    } else if (token.charAt(0) === ':') {\n      paramName = token.substring(1);\n      paramValue = params[paramName];\n      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing \"%s\" parameter for path \"%s\"', paramName, pattern) : invariant(false) : void 0;\n\n      if (paramValue == null) {\n        if (parenCount) {\n          parenHistory[parenCount - 1] = '';\n          var curTokenIdx = tokens.indexOf(token);\n          var tokensSubset = tokens.slice(curTokenIdx, tokens.length);\n          var nextParenIdx = -1;\n\n          for (var _i = 0; _i < tokensSubset.length; _i++) {\n            if (tokensSubset[_i] == ')') {\n              nextParenIdx = _i;\n              break;\n            }\n          }\n\n          !(nextParenIdx > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Path \"%s\" is missing end paren at segment \"%s\"', pattern, tokensSubset.join('')) : invariant(false) : void 0; // jump to ending paren\n\n          i = curTokenIdx + nextParenIdx - 1;\n        }\n      } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);\n    } else {\n      if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;\n    }\n  }\n\n  !(parenCount <= 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Path \"%s\" is missing end paren', pattern) : invariant(false) : void 0;\n  return pathname.replace(/\\/+/g, '/');\n}","map":{"version":3,"sources":["/Users/saikiran/Desktop/Mojo-Ecommerce/react-ecommerce/node_modules/react-router/es/PatternUtils.js"],"names":["invariant","escapeRegExp","string","replace","_compilePattern","pattern","regexpSource","paramNames","tokens","match","lastIndex","matcher","exec","index","push","slice","length","CompiledPatternsCache","Object","create","compilePattern","matchPattern","pathname","charAt","_compilePattern2","RegExp","matchedPath","remainingPathname","substr","paramValues","map","v","decodeURIComponent","getParamNames","getParams","params","forEach","paramName","formatPattern","_compilePattern3","parenCount","splatIndex","parenHistory","token","paramValue","i","len","Array","isArray","splat","process","env","NODE_ENV","encodeURI","parenText","pop","substring","curTokenIdx","indexOf","tokensSubset","nextParenIdx","_i","join","encodeURIComponent"],"mappings":"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","sourcesContent":["import invariant from 'invariant';\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction _compilePattern(pattern) {\n  var regexpSource = '';\n  var paramNames = [];\n  var tokens = [];\n\n  var match = void 0,\n      lastIndex = 0,\n      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\\*\\*|\\*|\\(|\\)|\\\\\\(|\\\\\\)/g;\n  while (match = matcher.exec(pattern)) {\n    if (match.index !== lastIndex) {\n      tokens.push(pattern.slice(lastIndex, match.index));\n      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));\n    }\n\n    if (match[1]) {\n      regexpSource += '([^/]+)';\n      paramNames.push(match[1]);\n    } else if (match[0] === '**') {\n      regexpSource += '(.*)';\n      paramNames.push('splat');\n    } else if (match[0] === '*') {\n      regexpSource += '(.*?)';\n      paramNames.push('splat');\n    } else if (match[0] === '(') {\n      regexpSource += '(?:';\n    } else if (match[0] === ')') {\n      regexpSource += ')?';\n    } else if (match[0] === '\\\\(') {\n      regexpSource += '\\\\(';\n    } else if (match[0] === '\\\\)') {\n      regexpSource += '\\\\)';\n    }\n\n    tokens.push(match[0]);\n\n    lastIndex = matcher.lastIndex;\n  }\n\n  if (lastIndex !== pattern.length) {\n    tokens.push(pattern.slice(lastIndex, pattern.length));\n    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));\n  }\n\n  return {\n    pattern: pattern,\n    regexpSource: regexpSource,\n    paramNames: paramNames,\n    tokens: tokens\n  };\n}\n\nvar CompiledPatternsCache = Object.create(null);\n\nexport function compilePattern(pattern) {\n  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);\n\n  return CompiledPatternsCache[pattern];\n}\n\n/**\n * Attempts to match a pattern on the given pathname. Patterns may use\n * the following special characters:\n *\n * - :paramName     Matches a URL segment up to the next /, ?, or #. The\n *                  captured string is considered a \"param\"\n * - ()             Wraps a segment of the URL that is optional\n * - *              Consumes (non-greedy) all characters up to the next\n *                  character in the pattern, or to the end of the URL if\n *                  there is none\n * - **             Consumes (greedy) all characters up to the next character\n *                  in the pattern, or to the end of the URL if there is none\n *\n *  The function calls callback(error, matched) when finished.\n * The return value is an object with the following properties:\n *\n * - remainingPathname\n * - paramNames\n * - paramValues\n */\nexport function matchPattern(pattern, pathname) {\n  // Ensure pattern starts with leading slash for consistency with pathname.\n  if (pattern.charAt(0) !== '/') {\n    pattern = '/' + pattern;\n  }\n\n  var _compilePattern2 = compilePattern(pattern),\n      regexpSource = _compilePattern2.regexpSource,\n      paramNames = _compilePattern2.paramNames,\n      tokens = _compilePattern2.tokens;\n\n  if (pattern.charAt(pattern.length - 1) !== '/') {\n    regexpSource += '/?'; // Allow optional path separator at end.\n  }\n\n  // Special-case patterns like '*' for catch-all routes.\n  if (tokens[tokens.length - 1] === '*') {\n    regexpSource += '$';\n  }\n\n  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));\n  if (match == null) {\n    return null;\n  }\n\n  var matchedPath = match[0];\n  var remainingPathname = pathname.substr(matchedPath.length);\n\n  if (remainingPathname) {\n    // Require that the match ends at a path separator, if we didn't match\n    // the full path, so any remaining pathname is a new path segment.\n    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {\n      return null;\n    }\n\n    // If there is a remaining pathname, treat the path separator as part of\n    // the remaining pathname for properly continuing the match.\n    remainingPathname = '/' + remainingPathname;\n  }\n\n  return {\n    remainingPathname: remainingPathname,\n    paramNames: paramNames,\n    paramValues: match.slice(1).map(function (v) {\n      return v && decodeURIComponent(v);\n    })\n  };\n}\n\nexport function getParamNames(pattern) {\n  return compilePattern(pattern).paramNames;\n}\n\nexport function getParams(pattern, pathname) {\n  var match = matchPattern(pattern, pathname);\n  if (!match) {\n    return null;\n  }\n\n  var paramNames = match.paramNames,\n      paramValues = match.paramValues;\n\n  var params = {};\n\n  paramNames.forEach(function (paramName, index) {\n    params[paramName] = paramValues[index];\n  });\n\n  return params;\n}\n\n/**\n * Returns a version of the given pattern with params interpolated. Throws\n * if there is a dynamic segment of the pattern for which there is no param.\n */\nexport function formatPattern(pattern, params) {\n  params = params || {};\n\n  var _compilePattern3 = compilePattern(pattern),\n      tokens = _compilePattern3.tokens;\n\n  var parenCount = 0,\n      pathname = '',\n      splatIndex = 0,\n      parenHistory = [];\n\n  var token = void 0,\n      paramName = void 0,\n      paramValue = void 0;\n  for (var i = 0, len = tokens.length; i < len; ++i) {\n    token = tokens[i];\n\n    if (token === '*' || token === '**') {\n      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;\n\n      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing splat #%s for path \"%s\"', splatIndex, pattern) : invariant(false) : void 0;\n\n      if (paramValue != null) pathname += encodeURI(paramValue);\n    } else if (token === '(') {\n      parenHistory[parenCount] = '';\n      parenCount += 1;\n    } else if (token === ')') {\n      var parenText = parenHistory.pop();\n      parenCount -= 1;\n\n      if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;\n    } else if (token === '\\\\(') {\n      pathname += '(';\n    } else if (token === '\\\\)') {\n      pathname += ')';\n    } else if (token.charAt(0) === ':') {\n      paramName = token.substring(1);\n      paramValue = params[paramName];\n\n      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing \"%s\" parameter for path \"%s\"', paramName, pattern) : invariant(false) : void 0;\n\n      if (paramValue == null) {\n        if (parenCount) {\n          parenHistory[parenCount - 1] = '';\n\n          var curTokenIdx = tokens.indexOf(token);\n          var tokensSubset = tokens.slice(curTokenIdx, tokens.length);\n          var nextParenIdx = -1;\n\n          for (var _i = 0; _i < tokensSubset.length; _i++) {\n            if (tokensSubset[_i] == ')') {\n              nextParenIdx = _i;\n              break;\n            }\n          }\n\n          !(nextParenIdx > 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Path \"%s\" is missing end paren at segment \"%s\"', pattern, tokensSubset.join('')) : invariant(false) : void 0;\n\n          // jump to ending paren\n          i = curTokenIdx + nextParenIdx - 1;\n        }\n      } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);\n    } else {\n      if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;\n    }\n  }\n\n  !(parenCount <= 0) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Path \"%s\" is missing end paren', pattern) : invariant(false) : void 0;\n\n  return pathname.replace(/\\/+/g, '/');\n}"]},"metadata":{},"sourceType":"module"}