{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport warning from './routerWarning';\nimport computeChangedRoutes from './computeChangedRoutes';\nimport getTransitionUtils from './TransitionUtils';\nimport _isActive from './isActive';\nimport getComponents from './getComponents';\nimport matchRoutes from './matchRoutes';\n\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (Object.prototype.hasOwnProperty.call(object, p)) return true;\n  }\n\n  return false;\n}\n\nexport default function createTransitionManager(history, routes) {\n  var state = {};\n\n  var _getTransitionUtils = getTransitionUtils(),\n      runEnterHooks = _getTransitionUtils.runEnterHooks,\n      runChangeHooks = _getTransitionUtils.runChangeHooks,\n      runLeaveHooks = _getTransitionUtils.runLeaveHooks; // Signature should be (location, indexOnly), but needs to support (path,\n  // query, indexOnly)\n\n\n  function isActive(location, indexOnly) {\n    location = history.createLocation(location);\n    return _isActive(location, indexOnly, state.location, state.routes, state.params);\n  }\n\n  var partialNextState = void 0;\n\n  function match(location, callback) {\n    if (partialNextState && partialNextState.location === location) {\n      // Continue from where we left off.\n      finishMatch(partialNextState, callback);\n    } else {\n      matchRoutes(routes, location, function (error, nextState) {\n        if (error) {\n          callback(error);\n        } else if (nextState) {\n          finishMatch(_extends({}, nextState, {\n            location: location\n          }), callback);\n        } else {\n          callback();\n        }\n      });\n    }\n  }\n\n  function finishMatch(nextState, callback) {\n    var _computeChangedRoutes = computeChangedRoutes(state, nextState),\n        leaveRoutes = _computeChangedRoutes.leaveRoutes,\n        changeRoutes = _computeChangedRoutes.changeRoutes,\n        enterRoutes = _computeChangedRoutes.enterRoutes;\n\n    runLeaveHooks(leaveRoutes, state); // Tear down confirmation hooks for left routes\n\n    leaveRoutes.filter(function (route) {\n      return enterRoutes.indexOf(route) === -1;\n    }).forEach(removeListenBeforeHooksForRoute); // change and enter hooks are run in series\n\n    runChangeHooks(changeRoutes, state, nextState, function (error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n      runEnterHooks(enterRoutes, nextState, finishEnterHooks);\n    });\n\n    function finishEnterHooks(error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo); // TODO: Fetch components after state is updated.\n\n      getComponents(nextState, function (error, components) {\n        if (error) {\n          callback(error);\n        } else {\n          // TODO: Make match a pure function and have some other API\n          // for \"match and update state\".\n          callback(null, null, state = _extends({}, nextState, {\n            components: components\n          }));\n        }\n      });\n    }\n\n    function handleErrorOrRedirect(error, redirectInfo) {\n      if (error) callback(error);else callback(null, redirectInfo);\n    }\n  }\n\n  var RouteGuid = 1;\n\n  function getRouteID(route) {\n    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return route.__id__ || create && (route.__id__ = RouteGuid++);\n  }\n\n  var RouteHooks = Object.create(null);\n\n  function getRouteHooksForRoutes(routes) {\n    return routes.map(function (route) {\n      return RouteHooks[getRouteID(route)];\n    }).filter(function (hook) {\n      return hook;\n    });\n  }\n\n  function transitionHook(location, callback) {\n    matchRoutes(routes, location, function (error, nextState) {\n      if (nextState == null) {\n        // TODO: We didn't actually match anything, but hang\n        // onto error/nextState so we don't have to matchRoutes\n        // again in the listen callback.\n        callback();\n        return;\n      } // Cache some state here so we don't have to\n      // matchRoutes() again in the listen callback.\n\n\n      partialNextState = _extends({}, nextState, {\n        location: location\n      });\n      var hooks = getRouteHooksForRoutes(computeChangedRoutes(state, partialNextState).leaveRoutes);\n      var result = void 0;\n\n      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n        // Passing the location arg here indicates to\n        // the user that this is a transition hook.\n        result = hooks[i](location);\n      }\n\n      callback(result);\n    });\n  }\n  /* istanbul ignore next: untestable with Karma */\n\n\n  function beforeUnloadHook() {\n    // Synchronously check to see if any route hooks want\n    // to prevent the current window/tab from closing.\n    if (state.routes) {\n      var hooks = getRouteHooksForRoutes(state.routes);\n      var message = void 0;\n\n      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n        // Passing no args indicates to the user that this is a\n        // beforeunload hook. We don't know the next location.\n        message = hooks[i]();\n      }\n\n      return message;\n    }\n  }\n\n  var unlistenBefore = void 0,\n      unlistenBeforeUnload = void 0;\n\n  function removeListenBeforeHooksForRoute(route) {\n    var routeID = getRouteID(route);\n\n    if (!routeID) {\n      return;\n    }\n\n    delete RouteHooks[routeID];\n\n    if (!hasAnyProperties(RouteHooks)) {\n      // teardown transition & beforeunload hooks\n      if (unlistenBefore) {\n        unlistenBefore();\n        unlistenBefore = null;\n      }\n\n      if (unlistenBeforeUnload) {\n        unlistenBeforeUnload();\n        unlistenBeforeUnload = null;\n      }\n    }\n  }\n  /**\n   * Registers the given hook function to run before leaving the given route.\n   *\n   * During a normal transition, the hook function receives the next location\n   * as its only argument and can return either a prompt message (string) to show the user,\n   * to make sure they want to leave the page; or `false`, to prevent the transition.\n   * Any other return value will have no effect.\n   *\n   * During the beforeunload event (in browsers) the hook receives no arguments.\n   * In this case it must return a prompt message to prevent the transition.\n   *\n   * Returns a function that may be used to unbind the listener.\n   */\n\n\n  function listenBeforeLeavingRoute(route, hook) {\n    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n    var routeID = getRouteID(route, true);\n    RouteHooks[routeID] = hook;\n\n    if (thereWereNoRouteHooks) {\n      // setup transition & beforeunload hooks\n      unlistenBefore = history.listenBefore(transitionHook);\n      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n    }\n\n    return function () {\n      removeListenBeforeHooksForRoute(route);\n    };\n  }\n  /**\n   * This is the API for stateful environments. As the location\n   * changes, we update state and call the listener. We can also\n   * gracefully handle errors and redirects.\n   */\n\n\n  function listen(listener) {\n    function historyListener(location) {\n      if (state.location === location) {\n        listener(null, state);\n      } else {\n        match(location, function (error, redirectLocation, nextState) {\n          if (error) {\n            listener(error);\n          } else if (redirectLocation) {\n            history.replace(redirectLocation);\n          } else if (nextState) {\n            listener(null, nextState);\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : void 0;\n          }\n        });\n      }\n    } // TODO: Only use a single history listener. Otherwise we'll end up with\n    // multiple concurrent calls to match.\n    // Set up the history listener first in case the initial match redirects.\n\n\n    var unsubscribe = history.listen(historyListener);\n\n    if (state.location) {\n      // Picking up on a matchContext.\n      listener(null, state);\n    } else {\n      historyListener(history.getCurrentLocation());\n    }\n\n    return unsubscribe;\n  }\n\n  return {\n    isActive: isActive,\n    match: match,\n    listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n    listen: listen\n  };\n}","map":{"version":3,"sources":["/Users/saikiran/Desktop/Mojo-Ecommerce/react-ecommerce/node_modules/react-router/es/createTransitionManager.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","warning","computeChangedRoutes","getTransitionUtils","_isActive","getComponents","matchRoutes","hasAnyProperties","object","p","createTransitionManager","history","routes","state","_getTransitionUtils","runEnterHooks","runChangeHooks","runLeaveHooks","isActive","location","indexOnly","createLocation","params","partialNextState","match","callback","finishMatch","error","nextState","_computeChangedRoutes","leaveRoutes","changeRoutes","enterRoutes","filter","route","indexOf","forEach","removeListenBeforeHooksForRoute","redirectInfo","handleErrorOrRedirect","finishEnterHooks","components","RouteGuid","getRouteID","create","undefined","__id__","RouteHooks","getRouteHooksForRoutes","map","hook","transitionHook","hooks","result","len","beforeUnloadHook","message","unlistenBefore","unlistenBeforeUnload","routeID","listenBeforeLeavingRoute","thereWereNoRouteHooks","listenBefore","listenBeforeUnload","listen","listener","historyListener","redirectLocation","replace","process","env","NODE_ENV","pathname","search","hash","unsubscribe","getCurrentLocation"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from './routerWarning';\nimport computeChangedRoutes from './computeChangedRoutes';\nimport getTransitionUtils from './TransitionUtils';\nimport _isActive from './isActive';\nimport getComponents from './getComponents';\nimport matchRoutes from './matchRoutes';\n\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (Object.prototype.hasOwnProperty.call(object, p)) return true;\n  }return false;\n}\n\nexport default function createTransitionManager(history, routes) {\n  var state = {};\n\n  var _getTransitionUtils = getTransitionUtils(),\n      runEnterHooks = _getTransitionUtils.runEnterHooks,\n      runChangeHooks = _getTransitionUtils.runChangeHooks,\n      runLeaveHooks = _getTransitionUtils.runLeaveHooks;\n\n  // Signature should be (location, indexOnly), but needs to support (path,\n  // query, indexOnly)\n\n\n  function isActive(location, indexOnly) {\n    location = history.createLocation(location);\n\n    return _isActive(location, indexOnly, state.location, state.routes, state.params);\n  }\n\n  var partialNextState = void 0;\n\n  function match(location, callback) {\n    if (partialNextState && partialNextState.location === location) {\n      // Continue from where we left off.\n      finishMatch(partialNextState, callback);\n    } else {\n      matchRoutes(routes, location, function (error, nextState) {\n        if (error) {\n          callback(error);\n        } else if (nextState) {\n          finishMatch(_extends({}, nextState, { location: location }), callback);\n        } else {\n          callback();\n        }\n      });\n    }\n  }\n\n  function finishMatch(nextState, callback) {\n    var _computeChangedRoutes = computeChangedRoutes(state, nextState),\n        leaveRoutes = _computeChangedRoutes.leaveRoutes,\n        changeRoutes = _computeChangedRoutes.changeRoutes,\n        enterRoutes = _computeChangedRoutes.enterRoutes;\n\n    runLeaveHooks(leaveRoutes, state);\n\n    // Tear down confirmation hooks for left routes\n    leaveRoutes.filter(function (route) {\n      return enterRoutes.indexOf(route) === -1;\n    }).forEach(removeListenBeforeHooksForRoute);\n\n    // change and enter hooks are run in series\n    runChangeHooks(changeRoutes, state, nextState, function (error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n\n      runEnterHooks(enterRoutes, nextState, finishEnterHooks);\n    });\n\n    function finishEnterHooks(error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n\n      // TODO: Fetch components after state is updated.\n      getComponents(nextState, function (error, components) {\n        if (error) {\n          callback(error);\n        } else {\n          // TODO: Make match a pure function and have some other API\n          // for \"match and update state\".\n          callback(null, null, state = _extends({}, nextState, { components: components }));\n        }\n      });\n    }\n\n    function handleErrorOrRedirect(error, redirectInfo) {\n      if (error) callback(error);else callback(null, redirectInfo);\n    }\n  }\n\n  var RouteGuid = 1;\n\n  function getRouteID(route) {\n    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    return route.__id__ || create && (route.__id__ = RouteGuid++);\n  }\n\n  var RouteHooks = Object.create(null);\n\n  function getRouteHooksForRoutes(routes) {\n    return routes.map(function (route) {\n      return RouteHooks[getRouteID(route)];\n    }).filter(function (hook) {\n      return hook;\n    });\n  }\n\n  function transitionHook(location, callback) {\n    matchRoutes(routes, location, function (error, nextState) {\n      if (nextState == null) {\n        // TODO: We didn't actually match anything, but hang\n        // onto error/nextState so we don't have to matchRoutes\n        // again in the listen callback.\n        callback();\n        return;\n      }\n\n      // Cache some state here so we don't have to\n      // matchRoutes() again in the listen callback.\n      partialNextState = _extends({}, nextState, { location: location });\n\n      var hooks = getRouteHooksForRoutes(computeChangedRoutes(state, partialNextState).leaveRoutes);\n\n      var result = void 0;\n      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n        // Passing the location arg here indicates to\n        // the user that this is a transition hook.\n        result = hooks[i](location);\n      }\n\n      callback(result);\n    });\n  }\n\n  /* istanbul ignore next: untestable with Karma */\n  function beforeUnloadHook() {\n    // Synchronously check to see if any route hooks want\n    // to prevent the current window/tab from closing.\n    if (state.routes) {\n      var hooks = getRouteHooksForRoutes(state.routes);\n\n      var message = void 0;\n      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n        // Passing no args indicates to the user that this is a\n        // beforeunload hook. We don't know the next location.\n        message = hooks[i]();\n      }\n\n      return message;\n    }\n  }\n\n  var unlistenBefore = void 0,\n      unlistenBeforeUnload = void 0;\n\n  function removeListenBeforeHooksForRoute(route) {\n    var routeID = getRouteID(route);\n    if (!routeID) {\n      return;\n    }\n\n    delete RouteHooks[routeID];\n\n    if (!hasAnyProperties(RouteHooks)) {\n      // teardown transition & beforeunload hooks\n      if (unlistenBefore) {\n        unlistenBefore();\n        unlistenBefore = null;\n      }\n\n      if (unlistenBeforeUnload) {\n        unlistenBeforeUnload();\n        unlistenBeforeUnload = null;\n      }\n    }\n  }\n\n  /**\n   * Registers the given hook function to run before leaving the given route.\n   *\n   * During a normal transition, the hook function receives the next location\n   * as its only argument and can return either a prompt message (string) to show the user,\n   * to make sure they want to leave the page; or `false`, to prevent the transition.\n   * Any other return value will have no effect.\n   *\n   * During the beforeunload event (in browsers) the hook receives no arguments.\n   * In this case it must return a prompt message to prevent the transition.\n   *\n   * Returns a function that may be used to unbind the listener.\n   */\n  function listenBeforeLeavingRoute(route, hook) {\n    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n    var routeID = getRouteID(route, true);\n\n    RouteHooks[routeID] = hook;\n\n    if (thereWereNoRouteHooks) {\n      // setup transition & beforeunload hooks\n      unlistenBefore = history.listenBefore(transitionHook);\n\n      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n    }\n\n    return function () {\n      removeListenBeforeHooksForRoute(route);\n    };\n  }\n\n  /**\n   * This is the API for stateful environments. As the location\n   * changes, we update state and call the listener. We can also\n   * gracefully handle errors and redirects.\n   */\n  function listen(listener) {\n    function historyListener(location) {\n      if (state.location === location) {\n        listener(null, state);\n      } else {\n        match(location, function (error, redirectLocation, nextState) {\n          if (error) {\n            listener(error);\n          } else if (redirectLocation) {\n            history.replace(redirectLocation);\n          } else if (nextState) {\n            listener(null, nextState);\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : void 0;\n          }\n        });\n      }\n    }\n\n    // TODO: Only use a single history listener. Otherwise we'll end up with\n    // multiple concurrent calls to match.\n\n    // Set up the history listener first in case the initial match redirects.\n    var unsubscribe = history.listen(historyListener);\n\n    if (state.location) {\n      // Picking up on a matchContext.\n      listener(null, state);\n    } else {\n      historyListener(history.getCurrentLocation());\n    }\n\n    return unsubscribe;\n  }\n\n  return {\n    isActive: isActive,\n    match: match,\n    listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n    listen: listen\n  };\n}"]},"metadata":{},"sourceType":"module"}