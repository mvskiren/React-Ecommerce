{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nimport { matchPattern } from './PatternUtils';\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\n\n\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  } // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n\n\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\n\n\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = []; // for...of would work here but it's probably slower post-transpilation.\n\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\n\n\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n  if (query == null) return true;\n  return deepEqual(query, activeQuery);\n}\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\n\n\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n      query = _ref.query;\n  if (currentLocation == null) return false; // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}","map":{"version":3,"sources":["/Users/saikiran/Desktop/Mojo-Ecommerce/react-ecommerce/node_modules/react-router/es/isActive.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","matchPattern","deepEqual","a","b","Array","isArray","length","every","item","index","p","Object","hasOwnProperty","call","undefined","String","pathIsActive","pathname","currentPathname","charAt","routeIsActive","routes","params","remainingPathname","paramNames","paramValues","i","len","route","pattern","path","matched","concat","paramName","queryIsActive","query","activeQuery","isActive","_ref","indexOnly","currentLocation"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { matchPattern } from './PatternUtils';\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = [];\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n\n  if (query == null) return true;\n\n  return deepEqual(query, activeQuery);\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n      query = _ref.query;\n\n  if (currentLocation == null) return false;\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}"]},"metadata":{},"sourceType":"module"}