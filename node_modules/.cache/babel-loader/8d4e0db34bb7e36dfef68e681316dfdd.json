{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\n\n\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source or Token to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source or Token to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto'; // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {// when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe)\n      });\n    }; // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n    // Wraps createToken in order to infer the Element that is being tokenized.\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;","map":{"version":3,"sources":["/Users/saikiran/Desktop/Mojo-Ecommerce/react-ecommerce/node_modules/react-stripe-elements/es/components/inject.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","_react","require","_react2","_interopRequireDefault","_Elements","_Provider","__esModule","default","_objectWithoutProperties","keys","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","inject","WrappedComponent","_class","_temp","componentOptions","undefined","_componentOptions$wit","withRef","_React$Component","props","context","getRegisteredElements","Error","_this","findElement","filterBy","specifiedType","allElements","filteredElements","filter","e","matchingElements","element","requireElement","wrappedCreateToken","stripe","tokenTypeOrOptions","options","opts","tokenType","type","rest","createToken","_tokenType","wrappedCreateSource","createSource","tag","state","stripeProps","componentDidMount","_this2","addStripeLoadListener","setState","getWrappedInstance","wrappedInstance","render","_this3","createElement","ref","c","Component","contextTypes","providerContextTypes","injectContextTypes","displayName","name"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Elements = require('./Elements');\n\nvar _Provider = require('./Provider');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// react-redux does a bunch of stuff with pure components / checking if it needs to re-render.\n// not sure if we need to do the same.\nvar inject = function inject(WrappedComponent) {\n  var _class, _temp;\n\n  var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _componentOptions$wit = componentOptions.withRef,\n      withRef = _componentOptions$wit === undefined ? false : _componentOptions$wit;\n\n\n  return _temp = _class = function (_React$Component) {\n    _inherits(_class, _React$Component);\n\n    function _class(props, context) {\n      _classCallCheck(this, _class);\n\n      if (!context || !context.getRegisteredElements) {\n        throw new Error('It looks like you are trying to inject Stripe context outside of an Elements context.\\nPlease be sure the component that calls createSource or createToken is within an <Elements> component.');\n      }\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.findElement = function (filterBy, specifiedType) {\n        var allElements = _this.context.getRegisteredElements();\n        var filteredElements = allElements.filter(function (e) {\n          return e[filterBy];\n        });\n        var matchingElements = specifiedType === 'auto' ? filteredElements : filteredElements.filter(function (e) {\n          return e[filterBy] === specifiedType;\n        });\n\n        if (matchingElements.length === 1) {\n          return matchingElements[0].element;\n        } else if (matchingElements.length > 1) {\n          throw new Error('You did not specify the type of Source or Token to create.\\n        We could not infer which Element you want to use for this operation.');\n        } else {\n          return null;\n        }\n      };\n\n      _this.requireElement = function (filterBy, specifiedType) {\n        var element = _this.findElement(filterBy, specifiedType);\n        if (element) {\n          return element;\n        } else {\n          throw new Error('You did not specify the type of Source or Token to create.\\n        We could not infer which Element you want to use for this operation.');\n        }\n      };\n\n      _this.wrappedCreateToken = function (stripe) {\n        return function () {\n          var tokenTypeOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (tokenTypeOrOptions && (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) === 'object') {\n            // First argument is options; infer the Element and tokenize\n            var opts = tokenTypeOrOptions;\n\n            var tokenType = opts.type,\n                rest = _objectWithoutProperties(opts, ['type']);\n\n            var specifiedType = typeof tokenType === 'string' ? tokenType : 'auto';\n            // Since only options were passed in, a corresponding Element must exist\n            // for the tokenization to succeed -- thus we call requireElement.\n            var element = _this.requireElement('impliedTokenType', specifiedType);\n            return stripe.createToken(element, rest);\n          } else if (typeof tokenTypeOrOptions === 'string') {\n            // First argument is token type; tokenize with token type and options\n            var _tokenType = tokenTypeOrOptions;\n            return stripe.createToken(_tokenType, options);\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createToken. Expected an object, got ' + (typeof tokenTypeOrOptions === 'undefined' ? 'undefined' : _typeof(tokenTypeOrOptions)) + '.');\n          }\n        };\n      };\n\n      _this.wrappedCreateSource = function (stripe) {\n        return function () {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            if (typeof options.type !== 'string') {\n              throw new Error('Invalid Source type passed to createSource. Expected string, got ' + _typeof(options.type) + '.');\n            }\n\n            var element = _this.findElement('impliedSourceType', options.type);\n            if (element) {\n              // If an Element exists for the source type, use that to create the\n              // corresponding source.\n              //\n              // NOTE: this prevents users from independently creating sources of\n              // type `foo` if an Element that can create `foo` sources exists in\n              // the current <Elements /> context.\n              return stripe.createSource(element, options);\n            } else {\n              // If no Element exists for the source type, directly create a source.\n              return stripe.createSource(options);\n            }\n          } else {\n            // If a bad value was passed in for options, throw an error.\n            throw new Error('Invalid options passed to createSource. Expected an object, got ' + (typeof options === 'undefined' ? 'undefined' : _typeof(options)) + '.');\n          }\n        };\n      };\n\n      if (_this.context.tag === 'sync') {\n        _this.state = {\n          stripe: _this.stripeProps(_this.context.stripe)\n        };\n      } else {\n        _this.state = {\n          stripe: null\n        };\n      }\n      return _this;\n    }\n\n    _class.prototype.componentDidMount = function componentDidMount() {\n      var _this2 = this;\n\n      if (this.context.tag === 'async') {\n        this.context.addStripeLoadListener(function (stripe) {\n          _this2.setState({\n            stripe: _this2.stripeProps(stripe)\n          });\n        });\n      } else {\n        // when 'sync', it's already set in the constructor.\n      }\n    };\n\n    _class.prototype.getWrappedInstance = function getWrappedInstance() {\n      if (!withRef) {\n        throw new Error('To access the wrapped instance, the `{withRef: true}` option must be set when calling `injectStripe()`');\n      }\n      return this.wrappedInstance;\n    };\n\n    _class.prototype.stripeProps = function stripeProps(stripe) {\n      return _extends({}, stripe, {\n        // These are the only functions that take elements.\n        createToken: this.wrappedCreateToken(stripe),\n        createSource: this.wrappedCreateSource(stripe)\n      });\n    };\n\n    // Finds an Element by the specified type, if one exists.\n    // Throws if multiple Elements match.\n\n\n    // Require that exactly one Element is found for the specified type.\n    // Throws if no Element is found.\n\n\n    // Wraps createToken in order to infer the Element that is being tokenized.\n\n\n    // Wraps createSource in order to infer the Element that is being used for\n    // source creation.\n\n\n    _class.prototype.render = function render() {\n      var _this3 = this;\n\n      return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {\n        stripe: this.state.stripe,\n        ref: withRef ? function (c) {\n          _this3.wrappedInstance = c;\n        } : null\n      }));\n    };\n\n    return _class;\n  }(_react2.default.Component), _class.contextTypes = _extends({}, _Provider.providerContextTypes, _Elements.injectContextTypes), _class.displayName = 'InjectStripe(' + (WrappedComponent.displayName || WrappedComponent.name || 'Component') + ')', _temp;\n};\n\nexports.default = inject;"]},"metadata":{},"sourceType":"script"}