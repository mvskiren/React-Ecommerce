{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { loopAsync } from './AsyncUtils';\n\nvar PendingHooks = function PendingHooks() {\n  var _this = this;\n\n  _classCallCheck(this, PendingHooks);\n\n  this.hooks = [];\n\n  this.add = function (hook) {\n    return _this.hooks.push(hook);\n  };\n\n  this.remove = function (hook) {\n    return _this.hooks = _this.hooks.filter(function (h) {\n      return h !== hook;\n    });\n  };\n\n  this.has = function (hook) {\n    return _this.hooks.indexOf(hook) !== -1;\n  };\n\n  this.clear = function () {\n    return _this.hooks = [];\n  };\n};\n\nexport default function getTransitionUtils() {\n  var enterHooks = new PendingHooks();\n  var changeHooks = new PendingHooks();\n\n  function createTransitionHook(hook, route, asyncArity, pendingHooks) {\n    var isSync = hook.length < asyncArity;\n\n    var transitionHook = function transitionHook() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      hook.apply(route, args);\n\n      if (isSync) {\n        var callback = args[args.length - 1]; // Assume hook executes synchronously and\n        // automatically call the callback.\n\n        callback();\n      }\n    };\n\n    pendingHooks.add(transitionHook);\n    return transitionHook;\n  }\n\n  function getEnterHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));\n      return hooks;\n    }, []);\n  }\n\n  function getChangeHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));\n      return hooks;\n    }, []);\n  }\n\n  function runTransitionHooks(length, iter, callback) {\n    if (!length) {\n      callback();\n      return;\n    }\n\n    var redirectInfo = void 0;\n\n    function replace(location) {\n      redirectInfo = location;\n    }\n\n    loopAsync(length, function (index, next, done) {\n      iter(index, replace, function (error) {\n        if (error || redirectInfo) {\n          done(error, redirectInfo); // No need to continue.\n        } else {\n          next();\n        }\n      });\n    }, callback);\n  }\n  /**\n   * Runs all onEnter hooks in the given array of routes in order\n   * with onEnter(nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n\n\n  function runEnterHooks(routes, nextState, callback) {\n    enterHooks.clear();\n    var hooks = getEnterHooks(routes);\n    return runTransitionHooks(hooks.length, function (index, replace, next) {\n      var wrappedNext = function wrappedNext() {\n        if (enterHooks.has(hooks[index])) {\n          next.apply(undefined, arguments);\n          enterHooks.remove(hooks[index]);\n        }\n      };\n\n      hooks[index](nextState, replace, wrappedNext);\n    }, callback);\n  }\n  /**\n   * Runs all onChange hooks in the given array of routes in order\n   * with onChange(prevState, nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n\n\n  function runChangeHooks(routes, state, nextState, callback) {\n    changeHooks.clear();\n    var hooks = getChangeHooks(routes);\n    return runTransitionHooks(hooks.length, function (index, replace, next) {\n      var wrappedNext = function wrappedNext() {\n        if (changeHooks.has(hooks[index])) {\n          next.apply(undefined, arguments);\n          changeHooks.remove(hooks[index]);\n        }\n      };\n\n      hooks[index](state, nextState, replace, wrappedNext);\n    }, callback);\n  }\n  /**\n   * Runs all onLeave hooks in the given array of routes in order.\n   */\n\n\n  function runLeaveHooks(routes, prevState) {\n    for (var i = 0, len = routes.length; i < len; ++i) {\n      if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);\n    }\n  }\n\n  return {\n    runEnterHooks: runEnterHooks,\n    runChangeHooks: runChangeHooks,\n    runLeaveHooks: runLeaveHooks\n  };\n}","map":{"version":3,"sources":["/Users/saikiran/Desktop/Mojo-Ecommerce/react-ecommerce/node_modules/react-router/es/TransitionUtils.js"],"names":["_classCallCheck","instance","Constructor","TypeError","loopAsync","PendingHooks","_this","hooks","add","hook","push","remove","filter","h","has","indexOf","clear","getTransitionUtils","enterHooks","changeHooks","createTransitionHook","route","asyncArity","pendingHooks","isSync","length","transitionHook","_len","arguments","args","Array","_key","apply","callback","getEnterHooks","routes","reduce","onEnter","getChangeHooks","onChange","runTransitionHooks","iter","redirectInfo","replace","location","index","next","done","error","runEnterHooks","nextState","wrappedNext","undefined","runChangeHooks","state","runLeaveHooks","prevState","i","len","onLeave","call"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { loopAsync } from './AsyncUtils';\n\nvar PendingHooks = function PendingHooks() {\n  var _this = this;\n\n  _classCallCheck(this, PendingHooks);\n\n  this.hooks = [];\n\n  this.add = function (hook) {\n    return _this.hooks.push(hook);\n  };\n\n  this.remove = function (hook) {\n    return _this.hooks = _this.hooks.filter(function (h) {\n      return h !== hook;\n    });\n  };\n\n  this.has = function (hook) {\n    return _this.hooks.indexOf(hook) !== -1;\n  };\n\n  this.clear = function () {\n    return _this.hooks = [];\n  };\n};\n\nexport default function getTransitionUtils() {\n  var enterHooks = new PendingHooks();\n  var changeHooks = new PendingHooks();\n\n  function createTransitionHook(hook, route, asyncArity, pendingHooks) {\n    var isSync = hook.length < asyncArity;\n\n    var transitionHook = function transitionHook() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      hook.apply(route, args);\n\n      if (isSync) {\n        var callback = args[args.length - 1];\n        // Assume hook executes synchronously and\n        // automatically call the callback.\n        callback();\n      }\n    };\n\n    pendingHooks.add(transitionHook);\n\n    return transitionHook;\n  }\n\n  function getEnterHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));\n      return hooks;\n    }, []);\n  }\n\n  function getChangeHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));\n      return hooks;\n    }, []);\n  }\n\n  function runTransitionHooks(length, iter, callback) {\n    if (!length) {\n      callback();\n      return;\n    }\n\n    var redirectInfo = void 0;\n    function replace(location) {\n      redirectInfo = location;\n    }\n\n    loopAsync(length, function (index, next, done) {\n      iter(index, replace, function (error) {\n        if (error || redirectInfo) {\n          done(error, redirectInfo); // No need to continue.\n        } else {\n          next();\n        }\n      });\n    }, callback);\n  }\n\n  /**\n   * Runs all onEnter hooks in the given array of routes in order\n   * with onEnter(nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n  function runEnterHooks(routes, nextState, callback) {\n    enterHooks.clear();\n    var hooks = getEnterHooks(routes);\n    return runTransitionHooks(hooks.length, function (index, replace, next) {\n      var wrappedNext = function wrappedNext() {\n        if (enterHooks.has(hooks[index])) {\n          next.apply(undefined, arguments);\n          enterHooks.remove(hooks[index]);\n        }\n      };\n      hooks[index](nextState, replace, wrappedNext);\n    }, callback);\n  }\n\n  /**\n   * Runs all onChange hooks in the given array of routes in order\n   * with onChange(prevState, nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n  function runChangeHooks(routes, state, nextState, callback) {\n    changeHooks.clear();\n    var hooks = getChangeHooks(routes);\n    return runTransitionHooks(hooks.length, function (index, replace, next) {\n      var wrappedNext = function wrappedNext() {\n        if (changeHooks.has(hooks[index])) {\n          next.apply(undefined, arguments);\n          changeHooks.remove(hooks[index]);\n        }\n      };\n      hooks[index](state, nextState, replace, wrappedNext);\n    }, callback);\n  }\n\n  /**\n   * Runs all onLeave hooks in the given array of routes in order.\n   */\n  function runLeaveHooks(routes, prevState) {\n    for (var i = 0, len = routes.length; i < len; ++i) {\n      if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);\n    }\n  }\n\n  return {\n    runEnterHooks: runEnterHooks,\n    runChangeHooks: runChangeHooks,\n    runLeaveHooks: runLeaveHooks\n  };\n}"]},"metadata":{},"sourceType":"module"}