(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('classnames'), require('react-dom')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'classnames', 'react-dom'], factory) :
	(factory((global.gestalt = {}),global.React,global.PropTypes,global.classnames,global.ReactDOM));
}(this, (function (exports,React,PropTypes,classnames,reactDom) { 'use strict';

PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
classnames = classnames && classnames.hasOwnProperty('default') ? classnames['default'] : classnames;

var styles = { "box": "_0 _3r _2u", "xsDisplayNone": "_1", "xsDisplayFlex": "_2", "xsDisplayBlock": "_3", "xsDisplayInlineBlock": "_4", "xsDisplayVisuallyHidden": "_5", "smDisplayNone": "_6", "smDisplayFlex": "_7", "smDisplayBlock": "_8", "smDisplayInlineBlock": "_9", "smDisplayVisuallyHidden": "_a", "mdDisplayNone": "_b", "mdDisplayFlex": "_c", "mdDisplayBlock": "_d", "mdDisplayInlineBlock": "_e", "mdDisplayVisuallyHidden": "_f", "lgDisplayNone": "_g", "lgDisplayFlex": "_h", "lgDisplayBlock": "_i", "lgDisplayInlineBlock": "_j", "lgDisplayVisuallyHidden": "_k", "xsDirectionRow": "_l", "xsDirectionColumn": "_m", "smDirectionRow": "_n", "smDirectionColumn": "_o", "mdDirectionRow": "_p", "mdDirectionColumn": "_q", "lgDirectionRow": "_r", "lgDirectionColumn": "_s", "xsCol0": "_t", "xsCol1": "_u _3u", "xsCol2": "_v _3v", "xsCol3": "_w _3w", "xsCol4": "_x _3x", "xsCol5": "_y _3y", "xsCol6": "_z _3z", "xsCol7": "_10 _40", "xsCol8": "_11 _41", "xsCol9": "_12 _42", "xsCol10": "_13 _43", "xsCol11": "_14 _44", "xsCol12": "_15 _45", "smCol0": "_16", "smCol1": "_17 _46", "smCol2": "_18 _47", "smCol3": "_19 _48", "smCol4": "_1a _49", "smCol5": "_1b _4a", "smCol6": "_1c _4b", "smCol7": "_1d _4c", "smCol8": "_1e _4d", "smCol9": "_1f _4e", "smCol10": "_1g _4f", "smCol11": "_1h _4g", "smCol12": "_1i _4h", "mdCol0": "_1j", "mdCol1": "_1k _4i", "mdCol2": "_1l _4j", "mdCol3": "_1m _4k", "mdCol4": "_1n _4l", "mdCol5": "_1o _4m", "mdCol6": "_1p _4n", "mdCol7": "_1q _4o", "mdCol8": "_1r _4p", "mdCol9": "_1s _4q", "mdCol10": "_1t _4r", "mdCol11": "_1u _4s", "mdCol12": "_1v _4t", "lgCol0": "_1w", "lgCol1": "_1x _4u", "lgCol2": "_1y _4v", "lgCol3": "_1z _4w", "lgCol4": "_20 _4x", "lgCol5": "_21 _4y", "lgCol6": "_22 _4z", "lgCol7": "_23 _50", "lgCol8": "_24 _51", "lgCol9": "_25 _52", "lgCol10": "_26 _53", "lgCol11": "_27 _54", "lgCol12": "_28 _55" };

var borders = { "border": "_56", "borderTop": "_57", "borderRight": "_58", "borderBottom": "_59", "borderLeft": "_5a", "square": "_5b", "circle": "_5c", "pill": "_5d", "rounded": "_5e", "roundedTop": "_5f", "roundedRight": "_5g", "roundedBottom": "_5h", "roundedLeft": "_5i", "noBorder": "_5j" };

var colors = { "red": "_5k", "redBg": "_5l", "white": "_5m", "whiteBg": "_5n", "lightGray": "_5o", "lightGrayBg": "_5p", "gray": "_5q", "grayBg": "_5r", "darkGray": "_5s", "darkGrayBg": "_5t", "green": "_5u", "greenBg": "_5v", "pine": "_5w", "pineBg": "_5x", "olive": "_5y", "oliveBg": "_5z", "blue": "_60", "blueBg": "_61", "navy": "_62", "navyBg": "_63", "midnight": "_64", "midnightBg": "_65", "purple": "_66", "purpleBg": "_67", "orchid": "_68", "orchidBg": "_69", "eggplant": "_6a", "eggplantBg": "_6b", "maroon": "_6c", "maroonBg": "_6d", "watermelon": "_6e", "watermelonBg": "_6f", "orange": "_6g", "orangeBg": "_6h", "transparentBg": "_6i", "lightWashBg": "_6j", "darkWashBg": "_6k" };

var layout = { "block": "_29", "inline": "_2a", "inlineBlock": "_2b", "table": "_2c", "overflowHidden": "_2d", "overflowScroll": "_2e", "overflowScrollX": "_2f", "overflowScrollY": "_2g", "overflowAuto": "_2h", "fit": "_2i", "relative": "_2j", "fixed": "_2k", "absolute": "_2l", "sticky": "_2m", "top0": "_2n", "right0": "_2o", "bottom0": "_2p", "left0": "_2q", "small": "_2r", "medium": "_2s", "large": "_2t", "borderBox": "_2u", "contentBox": "_2v", "-webkit-box-flex": "_2w", "-webkit-flex": "_2w", "-ms-flex": "_2w", "flex": "_2w", "smFlex": "_2x", "mdFlex": "_2y", "lgFlex": "_2z", "flexColumn": "_30", "flexWrap": "_31", "itemsStart": "_32", "itemsEnd": "_33", "itemsCenter": "_34", "itemsBaseline": "_35", "itemsStretch": "_36", "selfStart": "_37", "selfEnd": "_38", "selfCenter": "_39", "selfBaseline": "_3a", "selfStretch": "_3b", "justifyStart": "_3c", "justifyEnd": "_3d", "justifyCenter": "_3e", "justifyBetween": "_3f", "justifyAround": "_3g", "contentStart": "_3h", "contentEnd": "_3i", "contentCenter": "_3j", "contentBetween": "_3k", "contentAround": "_3l", "contentStretch": "_3m", "flexGrow": "_3n", "flexNone": "_3o", "orderFirst": "_3p", "orderLast": "_3q" };

var whitespace = { "marginStart1": "_6l", "marginEnd1": "_6m", "marginStartN1": "_6n", "marginEndN1": "_6o", "marginTop1": "_6p", "marginRight1": "_6q", "marginBottom1": "_6r", "marginLeft1": "_6s", "marginTopN1": "_6t", "marginRightN1": "_6u", "marginBottomN1": "_6v", "marginLeftN1": "_6w", "paddingY1": "_6x", "paddingX1": "_6y", "marginStart2": "_6z", "marginEnd2": "_70", "marginStartN2": "_71", "marginEndN2": "_72", "marginTop2": "_73", "marginRight2": "_74", "marginBottom2": "_75", "marginLeft2": "_76", "marginTopN2": "_77", "marginRightN2": "_78", "marginBottomN2": "_79", "marginLeftN2": "_7a", "paddingY2": "_7b", "paddingX2": "_7c", "marginStart3": "_7d", "marginEnd3": "_7e", "marginStartN3": "_7f", "marginEndN3": "_7g", "marginTop3": "_7h", "marginRight3": "_7i", "marginBottom3": "_7j", "marginLeft3": "_7k", "marginTopN3": "_7l", "marginRightN3": "_7m", "marginBottomN3": "_7n", "marginLeftN3": "_7o", "paddingY3": "_7p", "paddingX3": "_7q", "marginStart4": "_7r", "marginEnd4": "_7s", "marginStartN4": "_7t", "marginEndN4": "_7u", "marginTop4": "_7v", "marginRight4": "_7w", "marginBottom4": "_7x", "marginLeft4": "_7y", "marginTopN4": "_7z", "marginRightN4": "_80", "marginBottomN4": "_81", "marginLeftN4": "_82", "paddingY4": "_83", "paddingX4": "_84", "marginStart5": "_85", "marginEnd5": "_86", "marginStartN5": "_87", "marginEndN5": "_88", "marginTop5": "_89", "marginRight5": "_8a", "marginBottom5": "_8b", "marginLeft5": "_8c", "marginTopN5": "_8d", "marginRightN5": "_8e", "marginBottomN5": "_8f", "marginLeftN5": "_8g", "paddingY5": "_8h", "paddingX5": "_8i", "marginStart6": "_8j", "marginEnd6": "_8k", "marginStartN6": "_8l", "marginEndN6": "_8m", "marginTop6": "_8n", "marginRight6": "_8o", "marginBottom6": "_8p", "marginLeft6": "_8q", "marginTopN6": "_8r", "marginRightN6": "_8s", "marginBottomN6": "_8t", "marginLeftN6": "_8u", "paddingY6": "_8v", "paddingX6": "_8w", "marginStart7": "_8x", "marginEnd7": "_8y", "marginStartN7": "_8z", "marginEndN7": "_90", "marginTop7": "_91", "marginRight7": "_92", "marginBottom7": "_93", "marginLeft7": "_94", "marginTopN7": "_95", "marginRightN7": "_96", "marginBottomN7": "_97", "marginLeftN7": "_98", "paddingY7": "_99", "paddingX7": "_9a", "marginStart8": "_9b", "marginEnd8": "_9c", "marginStartN8": "_9d", "marginEndN8": "_9e", "marginTop8": "_9f", "marginRight8": "_9g", "marginBottom8": "_9h", "marginLeft8": "_9i", "marginTopN8": "_9j", "marginRightN8": "_9k", "marginBottomN8": "_9l", "marginLeftN8": "_9m", "paddingY8": "_9n", "paddingX8": "_9o", "marginStart9": "_9p", "marginEnd9": "_9q", "marginStartN9": "_9r", "marginEndN9": "_9s", "marginTop9": "_9t", "marginRight9": "_9u", "marginBottom9": "_9v", "marginLeft9": "_9w", "marginTopN9": "_9x", "marginRightN9": "_9y", "marginBottomN9": "_9z", "marginLeftN9": "_a0", "paddingY9": "_a1", "paddingX9": "_a2", "marginStart10": "_a3", "marginEnd10": "_a4", "marginStartN10": "_a5", "marginEndN10": "_a6", "marginTop10": "_a7", "marginRight10": "_a8", "marginBottom10": "_a9", "marginLeft10": "_aa", "marginTopN10": "_ab", "marginRightN10": "_ac", "marginBottomN10": "_ad", "marginLeftN10": "_ae", "paddingY10": "_af", "paddingX10": "_ag", "marginStart11": "_ah", "marginEnd11": "_ai", "marginStartN11": "_aj", "marginEndN11": "_ak", "marginTop11": "_al", "marginRight11": "_am", "marginBottom11": "_an", "marginLeft11": "_ao", "marginTopN11": "_ap", "marginRightN11": "_aq", "marginBottomN11": "_ar", "marginLeftN11": "_as", "paddingY11": "_at", "paddingX11": "_au", "marginStart12": "_av", "marginEnd12": "_aw", "marginStartN12": "_ax", "marginEndN12": "_ay", "marginTop12": "_az", "marginRight12": "_b0", "marginBottom12": "_b1", "marginLeft12": "_b2", "marginTopN12": "_b3", "marginRightN12": "_b4", "marginBottomN12": "_b5", "marginLeftN12": "_b6", "paddingY12": "_b7", "paddingX12": "_b8", "smMarginStart1": "_b9", "smMarginEnd1": "_ba", "smMarginStartN1": "_bb", "smMarginEndN1": "_bc", "smMarginTop1": "_bd", "smMarginRight1": "_be", "smMarginBottom1": "_bf", "smMarginLeft1": "_bg", "smMarginTopN1": "_bh", "smMarginRightN1": "_bi", "smMarginBottomN1": "_bj", "smMarginLeftN1": "_bk", "smPaddingY1": "_bl", "smPaddingX1": "_bm", "smMarginStart2": "_bn", "smMarginEnd2": "_bo", "smMarginStartN2": "_bp", "smMarginEndN2": "_bq", "smMarginTop2": "_br", "smMarginRight2": "_bs", "smMarginBottom2": "_bt", "smMarginLeft2": "_bu", "smMarginTopN2": "_bv", "smMarginRightN2": "_bw", "smMarginBottomN2": "_bx", "smMarginLeftN2": "_by", "smPaddingY2": "_bz", "smPaddingX2": "_c0", "smMarginStart3": "_c1", "smMarginEnd3": "_c2", "smMarginStartN3": "_c3", "smMarginEndN3": "_c4", "smMarginTop3": "_c5", "smMarginRight3": "_c6", "smMarginBottom3": "_c7", "smMarginLeft3": "_c8", "smMarginTopN3": "_c9", "smMarginRightN3": "_ca", "smMarginBottomN3": "_cb", "smMarginLeftN3": "_cc", "smPaddingY3": "_cd", "smPaddingX3": "_ce", "smMarginStart4": "_cf", "smMarginEnd4": "_cg", "smMarginStartN4": "_ch", "smMarginEndN4": "_ci", "smMarginTop4": "_cj", "smMarginRight4": "_ck", "smMarginBottom4": "_cl", "smMarginLeft4": "_cm", "smMarginTopN4": "_cn", "smMarginRightN4": "_co", "smMarginBottomN4": "_cp", "smMarginLeftN4": "_cq", "smPaddingY4": "_cr", "smPaddingX4": "_cs", "smMarginStart5": "_ct", "smMarginEnd5": "_cu", "smMarginStartN5": "_cv", "smMarginEndN5": "_cw", "smMarginTop5": "_cx", "smMarginRight5": "_cy", "smMarginBottom5": "_cz", "smMarginLeft5": "_d0", "smMarginTopN5": "_d1", "smMarginRightN5": "_d2", "smMarginBottomN5": "_d3", "smMarginLeftN5": "_d4", "smPaddingY5": "_d5", "smPaddingX5": "_d6", "smMarginStart6": "_d7", "smMarginEnd6": "_d8", "smMarginStartN6": "_d9", "smMarginEndN6": "_da", "smMarginTop6": "_db", "smMarginRight6": "_dc", "smMarginBottom6": "_dd", "smMarginLeft6": "_de", "smMarginTopN6": "_df", "smMarginRightN6": "_dg", "smMarginBottomN6": "_dh", "smMarginLeftN6": "_di", "smPaddingY6": "_dj", "smPaddingX6": "_dk", "smMarginStart7": "_dl", "smMarginEnd7": "_dm", "smMarginStartN7": "_dn", "smMarginEndN7": "_do", "smMarginTop7": "_dp", "smMarginRight7": "_dq", "smMarginBottom7": "_dr", "smMarginLeft7": "_ds", "smMarginTopN7": "_dt", "smMarginRightN7": "_du", "smMarginBottomN7": "_dv", "smMarginLeftN7": "_dw", "smPaddingY7": "_dx", "smPaddingX7": "_dy", "smMarginStart8": "_dz", "smMarginEnd8": "_e0", "smMarginStartN8": "_e1", "smMarginEndN8": "_e2", "smMarginTop8": "_e3", "smMarginRight8": "_e4", "smMarginBottom8": "_e5", "smMarginLeft8": "_e6", "smMarginTopN8": "_e7", "smMarginRightN8": "_e8", "smMarginBottomN8": "_e9", "smMarginLeftN8": "_ea", "smPaddingY8": "_eb", "smPaddingX8": "_ec", "smMarginStart9": "_ed", "smMarginEnd9": "_ee", "smMarginStartN9": "_ef", "smMarginEndN9": "_eg", "smMarginTop9": "_eh", "smMarginRight9": "_ei", "smMarginBottom9": "_ej", "smMarginLeft9": "_ek", "smMarginTopN9": "_el", "smMarginRightN9": "_em", "smMarginBottomN9": "_en", "smMarginLeftN9": "_eo", "smPaddingY9": "_ep", "smPaddingX9": "_eq", "smMarginStart10": "_er", "smMarginEnd10": "_es", "smMarginStartN10": "_et", "smMarginEndN10": "_eu", "smMarginTop10": "_ev", "smMarginRight10": "_ew", "smMarginBottom10": "_ex", "smMarginLeft10": "_ey", "smMarginTopN10": "_ez", "smMarginRightN10": "_f0", "smMarginBottomN10": "_f1", "smMarginLeftN10": "_f2", "smPaddingY10": "_f3", "smPaddingX10": "_f4", "smMarginStart11": "_f5", "smMarginEnd11": "_f6", "smMarginStartN11": "_f7", "smMarginEndN11": "_f8", "smMarginTop11": "_f9", "smMarginRight11": "_fa", "smMarginBottom11": "_fb", "smMarginLeft11": "_fc", "smMarginTopN11": "_fd", "smMarginRightN11": "_fe", "smMarginBottomN11": "_ff", "smMarginLeftN11": "_fg", "smPaddingY11": "_fh", "smPaddingX11": "_fi", "smMarginStart12": "_fj", "smMarginEnd12": "_fk", "smMarginStartN12": "_fl", "smMarginEndN12": "_fm", "smMarginTop12": "_fn", "smMarginRight12": "_fo", "smMarginBottom12": "_fp", "smMarginLeft12": "_fq", "smMarginTopN12": "_fr", "smMarginRightN12": "_fs", "smMarginBottomN12": "_ft", "smMarginLeftN12": "_fu", "smPaddingY12": "_fv", "smPaddingX12": "_fw", "mdMarginStart1": "_fx", "mdMarginEnd1": "_fy", "mdMarginStartN1": "_fz", "mdMarginEndN1": "_g0", "mdMarginTop1": "_g1", "mdMarginRight1": "_g2", "mdMarginBottom1": "_g3", "mdMarginLeft1": "_g4", "mdMarginTopN1": "_g5", "mdMarginRightN1": "_g6", "mdMarginBottomN1": "_g7", "mdMarginLeftN1": "_g8", "mdPaddingY1": "_g9", "mdPaddingX1": "_ga", "mdMarginStart2": "_gb", "mdMarginEnd2": "_gc", "mdMarginStartN2": "_gd", "mdMarginEndN2": "_ge", "mdMarginTop2": "_gf", "mdMarginRight2": "_gg", "mdMarginBottom2": "_gh", "mdMarginLeft2": "_gi", "mdMarginTopN2": "_gj", "mdMarginRightN2": "_gk", "mdMarginBottomN2": "_gl", "mdMarginLeftN2": "_gm", "mdPaddingY2": "_gn", "mdPaddingX2": "_go", "mdMarginStart3": "_gp", "mdMarginEnd3": "_gq", "mdMarginStartN3": "_gr", "mdMarginEndN3": "_gs", "mdMarginTop3": "_gt", "mdMarginRight3": "_gu", "mdMarginBottom3": "_gv", "mdMarginLeft3": "_gw", "mdMarginTopN3": "_gx", "mdMarginRightN3": "_gy", "mdMarginBottomN3": "_gz", "mdMarginLeftN3": "_h0", "mdPaddingY3": "_h1", "mdPaddingX3": "_h2", "mdMarginStart4": "_h3", "mdMarginEnd4": "_h4", "mdMarginStartN4": "_h5", "mdMarginEndN4": "_h6", "mdMarginTop4": "_h7", "mdMarginRight4": "_h8", "mdMarginBottom4": "_h9", "mdMarginLeft4": "_ha", "mdMarginTopN4": "_hb", "mdMarginRightN4": "_hc", "mdMarginBottomN4": "_hd", "mdMarginLeftN4": "_he", "mdPaddingY4": "_hf", "mdPaddingX4": "_hg", "mdMarginStart5": "_hh", "mdMarginEnd5": "_hi", "mdMarginStartN5": "_hj", "mdMarginEndN5": "_hk", "mdMarginTop5": "_hl", "mdMarginRight5": "_hm", "mdMarginBottom5": "_hn", "mdMarginLeft5": "_ho", "mdMarginTopN5": "_hp", "mdMarginRightN5": "_hq", "mdMarginBottomN5": "_hr", "mdMarginLeftN5": "_hs", "mdPaddingY5": "_ht", "mdPaddingX5": "_hu", "mdMarginStart6": "_hv", "mdMarginEnd6": "_hw", "mdMarginStartN6": "_hx", "mdMarginEndN6": "_hy", "mdMarginTop6": "_hz", "mdMarginRight6": "_i0", "mdMarginBottom6": "_i1", "mdMarginLeft6": "_i2", "mdMarginTopN6": "_i3", "mdMarginRightN6": "_i4", "mdMarginBottomN6": "_i5", "mdMarginLeftN6": "_i6", "mdPaddingY6": "_i7", "mdPaddingX6": "_i8", "mdMarginStart7": "_i9", "mdMarginEnd7": "_ia", "mdMarginStartN7": "_ib", "mdMarginEndN7": "_ic", "mdMarginTop7": "_id", "mdMarginRight7": "_ie", "mdMarginBottom7": "_if", "mdMarginLeft7": "_ig", "mdMarginTopN7": "_ih", "mdMarginRightN7": "_ii", "mdMarginBottomN7": "_ij", "mdMarginLeftN7": "_ik", "mdPaddingY7": "_il", "mdPaddingX7": "_im", "mdMarginStart8": "_in", "mdMarginEnd8": "_io", "mdMarginStartN8": "_ip", "mdMarginEndN8": "_iq", "mdMarginTop8": "_ir", "mdMarginRight8": "_is", "mdMarginBottom8": "_it", "mdMarginLeft8": "_iu", "mdMarginTopN8": "_iv", "mdMarginRightN8": "_iw", "mdMarginBottomN8": "_ix", "mdMarginLeftN8": "_iy", "mdPaddingY8": "_iz", "mdPaddingX8": "_j0", "mdMarginStart9": "_j1", "mdMarginEnd9": "_j2", "mdMarginStartN9": "_j3", "mdMarginEndN9": "_j4", "mdMarginTop9": "_j5", "mdMarginRight9": "_j6", "mdMarginBottom9": "_j7", "mdMarginLeft9": "_j8", "mdMarginTopN9": "_j9", "mdMarginRightN9": "_ja", "mdMarginBottomN9": "_jb", "mdMarginLeftN9": "_jc", "mdPaddingY9": "_jd", "mdPaddingX9": "_je", "mdMarginStart10": "_jf", "mdMarginEnd10": "_jg", "mdMarginStartN10": "_jh", "mdMarginEndN10": "_ji", "mdMarginTop10": "_jj", "mdMarginRight10": "_jk", "mdMarginBottom10": "_jl", "mdMarginLeft10": "_jm", "mdMarginTopN10": "_jn", "mdMarginRightN10": "_jo", "mdMarginBottomN10": "_jp", "mdMarginLeftN10": "_jq", "mdPaddingY10": "_jr", "mdPaddingX10": "_js", "mdMarginStart11": "_jt", "mdMarginEnd11": "_ju", "mdMarginStartN11": "_jv", "mdMarginEndN11": "_jw", "mdMarginTop11": "_jx", "mdMarginRight11": "_jy", "mdMarginBottom11": "_jz", "mdMarginLeft11": "_k0", "mdMarginTopN11": "_k1", "mdMarginRightN11": "_k2", "mdMarginBottomN11": "_k3", "mdMarginLeftN11": "_k4", "mdPaddingY11": "_k5", "mdPaddingX11": "_k6", "mdMarginStart12": "_k7", "mdMarginEnd12": "_k8", "mdMarginStartN12": "_k9", "mdMarginEndN12": "_ka", "mdMarginTop12": "_kb", "mdMarginRight12": "_kc", "mdMarginBottom12": "_kd", "mdMarginLeft12": "_ke", "mdMarginTopN12": "_kf", "mdMarginRightN12": "_kg", "mdMarginBottomN12": "_kh", "mdMarginLeftN12": "_ki", "mdPaddingY12": "_kj", "mdPaddingX12": "_kk", "lgMarginStart1": "_kl", "lgMarginEnd1": "_km", "lgMarginStartN1": "_kn", "lgMarginEndN1": "_ko", "lgMarginTop1": "_kp", "lgMarginRight1": "_kq", "lgMarginBottom1": "_kr", "lgMarginLeft1": "_ks", "lgMarginTopN1": "_kt", "lgMarginRightN1": "_ku", "lgMarginBottomN1": "_kv", "lgMarginLeftN1": "_kw", "lgPaddingY1": "_kx", "lgPaddingX1": "_ky", "lgMarginStart2": "_kz", "lgMarginEnd2": "_l0", "lgMarginStartN2": "_l1", "lgMarginEndN2": "_l2", "lgMarginTop2": "_l3", "lgMarginRight2": "_l4", "lgMarginBottom2": "_l5", "lgMarginLeft2": "_l6", "lgMarginTopN2": "_l7", "lgMarginRightN2": "_l8", "lgMarginBottomN2": "_l9", "lgMarginLeftN2": "_la", "lgPaddingY2": "_lb", "lgPaddingX2": "_lc", "lgMarginStart3": "_ld", "lgMarginEnd3": "_le", "lgMarginStartN3": "_lf", "lgMarginEndN3": "_lg", "lgMarginTop3": "_lh", "lgMarginRight3": "_li", "lgMarginBottom3": "_lj", "lgMarginLeft3": "_lk", "lgMarginTopN3": "_ll", "lgMarginRightN3": "_lm", "lgMarginBottomN3": "_ln", "lgMarginLeftN3": "_lo", "lgPaddingY3": "_lp", "lgPaddingX3": "_lq", "lgMarginStart4": "_lr", "lgMarginEnd4": "_ls", "lgMarginStartN4": "_lt", "lgMarginEndN4": "_lu", "lgMarginTop4": "_lv", "lgMarginRight4": "_lw", "lgMarginBottom4": "_lx", "lgMarginLeft4": "_ly", "lgMarginTopN4": "_lz", "lgMarginRightN4": "_m0", "lgMarginBottomN4": "_m1", "lgMarginLeftN4": "_m2", "lgPaddingY4": "_m3", "lgPaddingX4": "_m4", "lgMarginStart5": "_m5", "lgMarginEnd5": "_m6", "lgMarginStartN5": "_m7", "lgMarginEndN5": "_m8", "lgMarginTop5": "_m9", "lgMarginRight5": "_ma", "lgMarginBottom5": "_mb", "lgMarginLeft5": "_mc", "lgMarginTopN5": "_md", "lgMarginRightN5": "_me", "lgMarginBottomN5": "_mf", "lgMarginLeftN5": "_mg", "lgPaddingY5": "_mh", "lgPaddingX5": "_mi", "lgMarginStart6": "_mj", "lgMarginEnd6": "_mk", "lgMarginStartN6": "_ml", "lgMarginEndN6": "_mm", "lgMarginTop6": "_mn", "lgMarginRight6": "_mo", "lgMarginBottom6": "_mp", "lgMarginLeft6": "_mq", "lgMarginTopN6": "_mr", "lgMarginRightN6": "_ms", "lgMarginBottomN6": "_mt", "lgMarginLeftN6": "_mu", "lgPaddingY6": "_mv", "lgPaddingX6": "_mw", "lgMarginStart7": "_mx", "lgMarginEnd7": "_my", "lgMarginStartN7": "_mz", "lgMarginEndN7": "_n0", "lgMarginTop7": "_n1", "lgMarginRight7": "_n2", "lgMarginBottom7": "_n3", "lgMarginLeft7": "_n4", "lgMarginTopN7": "_n5", "lgMarginRightN7": "_n6", "lgMarginBottomN7": "_n7", "lgMarginLeftN7": "_n8", "lgPaddingY7": "_n9", "lgPaddingX7": "_na", "lgMarginStart8": "_nb", "lgMarginEnd8": "_nc", "lgMarginStartN8": "_nd", "lgMarginEndN8": "_ne", "lgMarginTop8": "_nf", "lgMarginRight8": "_ng", "lgMarginBottom8": "_nh", "lgMarginLeft8": "_ni", "lgMarginTopN8": "_nj", "lgMarginRightN8": "_nk", "lgMarginBottomN8": "_nl", "lgMarginLeftN8": "_nm", "lgPaddingY8": "_nn", "lgPaddingX8": "_no", "lgMarginStart9": "_np", "lgMarginEnd9": "_nq", "lgMarginStartN9": "_nr", "lgMarginEndN9": "_ns", "lgMarginTop9": "_nt", "lgMarginRight9": "_nu", "lgMarginBottom9": "_nv", "lgMarginLeft9": "_nw", "lgMarginTopN9": "_nx", "lgMarginRightN9": "_ny", "lgMarginBottomN9": "_nz", "lgMarginLeftN9": "_o0", "lgPaddingY9": "_o1", "lgPaddingX9": "_o2", "lgMarginStart10": "_o3", "lgMarginEnd10": "_o4", "lgMarginStartN10": "_o5", "lgMarginEndN10": "_o6", "lgMarginTop10": "_o7", "lgMarginRight10": "_o8", "lgMarginBottom10": "_o9", "lgMarginLeft10": "_oa", "lgMarginTopN10": "_ob", "lgMarginRightN10": "_oc", "lgMarginBottomN10": "_od", "lgMarginLeftN10": "_oe", "lgPaddingY10": "_of", "lgPaddingX10": "_og", "lgMarginStart11": "_oh", "lgMarginEnd11": "_oi", "lgMarginStartN11": "_oj", "lgMarginEndN11": "_ok", "lgMarginTop11": "_ol", "lgMarginRight11": "_om", "lgMarginBottom11": "_on", "lgMarginLeft11": "_oo", "lgMarginTopN11": "_op", "lgMarginRightN11": "_oq", "lgMarginBottomN11": "_or", "lgMarginLeftN11": "_os", "lgPaddingY11": "_ot", "lgPaddingX11": "_ou", "lgMarginStart12": "_ov", "lgMarginEnd12": "_ow", "lgMarginStartN12": "_ox", "lgMarginEndN12": "_oy", "lgMarginTop12": "_oz", "lgMarginRight12": "_p0", "lgMarginBottom12": "_p1", "lgMarginLeft12": "_p2", "lgMarginTopN12": "_p3", "lgMarginRightN12": "_p4", "lgMarginBottomN12": "_p5", "lgMarginLeftN12": "_p6", "lgPaddingY12": "_p7", "lgPaddingX12": "_p8" };

var whitespaceLegacy = { "mlAuto": "_p9", "mrAuto": "_pa", "m0": "_pb", "mt0": "_pc", "mr0": "_pd", "mb0": "_pe", "ml0": "_pf", "p0": "_pg", "px0": "_ph", "py0": "_pi", "m1": "_pj", "mt1": "_pk", "mr1": "_pl", "mb1": "_pm", "ml1": "_pn", "mn1": "_po", "mtn1": "_pp", "mbn1": "_pq", "mln1": "_pr", "mrn1": "_ps", "mxn1": "_pt", "myn1": "_pu", "p1": "_pv", "px1": "_pw", "py1": "_px", "m2": "_py", "mt2": "_pz", "mr2": "_q0", "mb2": "_q1", "ml2": "_q2", "mn2": "_q3", "mtn2": "_q4", "mbn2": "_q5", "mln2": "_q6", "mrn2": "_q7", "mxn2": "_q8", "myn2": "_q9", "p2": "_qa", "px2": "_qb", "py2": "_qc", "m3": "_qd", "mt3": "_qe", "mr3": "_qf", "mb3": "_qg", "ml3": "_qh", "mn3": "_qi", "mtn3": "_qj", "mbn3": "_qk", "mln3": "_ql", "mrn3": "_qm", "mxn3": "_qn", "myn3": "_qo", "p3": "_qp", "px3": "_qq", "py3": "_qr", "m4": "_qs", "mt4": "_qt", "mr4": "_qu", "mb4": "_qv", "ml4": "_qw", "mn4": "_qx", "mtn4": "_qy", "mbn4": "_qz", "mln4": "_r0", "mrn4": "_r1", "mxn4": "_r2", "myn4": "_r3", "p4": "_r4", "px4": "_r5", "py4": "_r6", "m5": "_r7", "mt5": "_r8", "mr5": "_r9", "mb5": "_ra", "ml5": "_rb", "mn5": "_rc", "mtn5": "_rd", "mbn5": "_re", "mln5": "_rf", "mrn5": "_rg", "mxn5": "_rh", "myn5": "_ri", "p5": "_rj", "px5": "_rk", "py5": "_rl", "m6": "_rm", "mt6": "_rn", "mr6": "_ro", "mb6": "_rp", "ml6": "_rq", "mn6": "_rr", "mtn6": "_rs", "mbn6": "_rt", "mln6": "_ru", "mrn6": "_rv", "mxn6": "_rw", "myn6": "_rx", "p6": "_ry", "px6": "_rz", "py6": "_s0" };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*

Style is a monoid that capture the "to-be-applied" styles (inline and classes)
for a Box. It's basically set that is closed under an associative binary
operation and has an identity element such that for all HA HA HA. Yes, it's a
monoid, which sounds scary but it's not really and actually super useful. All
that means is that basically you can do two things with it:

    1. concat(concat(a, b), c) === concat(a, concat(b, c));
    2. concat(identity(), a) === concat(a, identity()) === a;

What that means is that it's really easy to compose styles together and the
order in which you do so doesn't really matter.

*/

var identity = function identity() {
  return {
    className: new Set(),
    inlineStyle: {}
  };
};

// TODO: This type should be opaque, however the Babel parser doesn't support
//       the opaque syntax yet.


var fromClassName = function fromClassName() {
  for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }

  return {
    className: new Set(classNames),
    inlineStyle: {}
  };
};

var fromInlineStyle = function fromInlineStyle(inlineStyle) {
  return {
    className: new Set(),
    inlineStyle: inlineStyle
  };
};

var concat = function concat(styles) {
  return styles.reduce(function (_ref, _ref2) {
    var classNameA = _ref.className,
        inlineStyleA = _ref.inlineStyle;
    var classNameB = _ref2.className,
        inlineStyleB = _ref2.inlineStyle;
    return {
      className: new Set([].concat(toConsumableArray(classNameA), toConsumableArray(classNameB))),
      inlineStyle: _extends({}, inlineStyleA, inlineStyleB)
    };
  }, identity());
};

var mapClassName = function mapClassName(fn) {
  return function (_ref3) {
    var className = _ref3.className,
        inlineStyle = _ref3.inlineStyle;
    return {
      className: new Set(Array.from(className).map(fn)),
      inlineStyle: inlineStyle
    };
  };
};

var toProps = function toProps(_ref4) {
  var className = _ref4.className,
      inlineStyle = _ref4.inlineStyle;

  var props = {};

  if (className.size > 0) {
    // Sorting here ensures that classNames are always stable, reducing diff
    // churn. Box usually has a small number of properties so it's not a perf
    // concern.
    props.className = Array.from(className).sort().join(' ');
  }

  if (Object.keys(inlineStyle).length > 0) {
    props.style = inlineStyle;
  }

  return props;
};

/*

Transforms

These are a collection of a few functors that take values and returns Style's. OMG, I used the word functor - it's really just a fancy word for function.

*/

// Adds a classname when a property is present.
//
//     <Box top />
//
var toggle = function toggle() {
  for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
    classNames[_key] = arguments[_key];
  }

  return function (val) {
    return val ? fromClassName.apply(undefined, classNames) : identity();
  };
};

// Maps string values to classes
//
//     <Box alignItems="center" />
//
var mapping = function mapping(map) {
  return function (val) {
    return Object.prototype.hasOwnProperty.call(map, val) ? fromClassName(map[val]) : identity();
  };
};

// Maps a range of integers to a range of classnames
//
//     <Box padding={1} />
//
var range = function range(scale) {
  return function (n) {
    return fromClassName('' + scale + (n < 0 ? 'N' + Math.abs(n) : n));
  };
};

// Like `range`, maps a range of integers to a range of classnames, excluding
// zero values.
//
//     <Box padding={0} />
var rangeWithoutZero = function rangeWithoutZero(scale) {
  return function (n) {
    return n === 0 ? identity() : range(scale)(n);
  };
};

// Binds a string classname to the value in an object. Useful when interacting
// with ranges that need to come dynamically from a style object. This is
// similar to the NPM package 'classnames/bind'.
var bind = function bind(fn, scope) {
  return function (val) {
    return mapClassName(function (name) {
      return scope[name];
    })(fn(val));
  };
};

// This takes a series of the previously defined functors, runs them all
// against a value and returns the set of their classnames.
var union = function union() {
  for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return function (val) {
    return concat(fns.map(function (fn) {
      return fn(val);
    }));
  };
};

/*

# ProTypes

Box's type definition is exhaustive. With the exception of `dangerouslySetInlineStyle`, values shouldn't be ambigious. That means that we have to type out things like boints, but that's also where Box's magic lies. Also, by putting in extra effort around type definitions here, we can skip extra runtime typechecks in the transformers for performance.

*/

// --

/*

# Transformers

This is where the meat and the bones of Box's transforms are. You can read more about the DSL in `./transforms.js`, but basically they are a small declarative way of specifying how a property (i.e. `marginTop={4}`) gets turned into a CSS class (`marginTop4`).

There's a little preamble here, but it culminates in a big object mapping the actual property names to the transformer values.

*/

var marginStart = bind(rangeWithoutZero('marginStart'), whitespace);
var marginEnd = bind(rangeWithoutZero('marginEnd'), whitespace);
var marginTop = bind(rangeWithoutZero('marginTop'), whitespace);
var marginRight = bind(rangeWithoutZero('marginRight'), whitespace);
var marginBottom = bind(rangeWithoutZero('marginBottom'), whitespace);
var marginLeft = bind(rangeWithoutZero('marginLeft'), whitespace);
var margin = union(marginTop, marginBottom, marginLeft, marginRight);

var smMarginTop = bind(rangeWithoutZero('smMarginTop'), whitespace);
var smMarginRight = bind(rangeWithoutZero('smMarginRight'), whitespace);
var smMarginBottom = bind(rangeWithoutZero('smMarginBottom'), whitespace);
var smMarginLeft = bind(rangeWithoutZero('smMarginLeft'), whitespace);
var smMargin = union(smMarginTop, smMarginBottom, smMarginLeft, smMarginRight);

var mdMarginTop = bind(rangeWithoutZero('mdMarginTop'), whitespace);
var mdMarginRight = bind(rangeWithoutZero('mdMarginRight'), whitespace);
var mdMarginBottom = bind(rangeWithoutZero('mdMarginBottom'), whitespace);
var mdMarginLeft = bind(rangeWithoutZero('mdMarginLeft'), whitespace);
var mdMargin = union(mdMarginTop, mdMarginBottom, mdMarginLeft, mdMarginRight);

var lgMarginTop = bind(rangeWithoutZero('lgMarginTop'), whitespace);
var lgMarginRight = bind(rangeWithoutZero('lgMarginRight'), whitespace);
var lgMarginBottom = bind(rangeWithoutZero('lgMarginBottom'), whitespace);
var lgMarginLeft = bind(rangeWithoutZero('lgMarginLeft'), whitespace);
var lgMargin = union(lgMarginTop, lgMarginBottom, lgMarginLeft, lgMarginRight);

var paddingX = bind(rangeWithoutZero('paddingX'), whitespace);
var paddingY = bind(rangeWithoutZero('paddingY'), whitespace);
var padding = union(paddingX, paddingY);

var smPaddingX = bind(rangeWithoutZero('smPaddingX'), whitespace);
var smPaddingY = bind(rangeWithoutZero('smPaddingY'), whitespace);
var smPadding = union(smPaddingX, smPaddingY);

var mdPaddingX = bind(rangeWithoutZero('mdPaddingX'), whitespace);
var mdPaddingY = bind(rangeWithoutZero('mdPaddingY'), whitespace);
var mdPadding = union(mdPaddingX, mdPaddingY);

var lgPaddingX = bind(rangeWithoutZero('lgPaddingX'), whitespace);
var lgPaddingY = bind(rangeWithoutZero('lgPaddingY'), whitespace);
var lgPadding = union(lgPaddingX, lgPaddingY);

/*

These functions are legacy. I'd like to get rid of most of this file's dependency on importing `./style.js` directly once these are removed.

*/

var prefix = function prefix(pre) {
  return mapClassName(function (name) {
    return '' + pre + name;
  });
};
var display = function display(value) {
  switch (value) {
    case 'flex':
      return fromClassName('DisplayFlex', 'DirectionRow');
    case 'flexColumn':
      return fromClassName('DisplayFlex', 'DirectionColumn');
    case 'inlineBlock':
      return fromClassName('DisplayInlineBlock');
    case 'visuallyHidden':
      return fromClassName('DisplayVisuallyHidden');
    case false:
      return fromClassName('DisplayNone');
    default:
      /* block */
      return fromClassName('DisplayBlock');
  }
};
var column = range('Col');

var formatIntBoint = function formatIntBoint(x) {
  return x < 0 ? 'n' + Math.abs(x) : x.toString();
};

/*

It's preferable to put new properties into that object directly just so it's easier to read.

*/

var propToFn = {
  xs: function xs(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('xs')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  sm: function sm(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('sm')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  md: function md(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('md')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },
  lg: function lg(value) {
    if (!value) {
      return identity();
    }
    return mapClassName(function (c) {
      return styles[c];
    })(prefix('lg')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
  },

  display: mapping({
    none: styles.xsDisplayNone,
    flex: styles.xsDisplayFlex,
    block: styles.xsDisplayBlock,
    inlineBlock: styles.xsDisplayInlineBlock,
    visuallyHidden: styles.xsDisplayVisuallyHidden
  }),
  column: bind(range('xsCol'), styles),
  direction: mapping({
    row: styles.xsDirectionRow,
    column: styles.xsDirectionColumn
  }),

  smDisplay: mapping({
    none: styles.smDisplayNone,
    flex: styles.smDisplayFlex,
    block: styles.smDisplayBlock,
    inlineBlock: styles.smDisplayInlineBlock,
    visuallyHidden: styles.smDisplayVisuallyHidden
  }),
  smColumn: bind(range('smCol'), styles),
  smDirection: mapping({
    row: styles.smDirectionRow,
    column: styles.smDirectionColumn
  }),

  mdDisplay: mapping({
    none: styles.mdDisplayNone,
    flex: styles.mdDisplayFlex,
    block: styles.mdDisplayBlock,
    inlineBlock: styles.mdDisplayInlineBlock,
    visuallyHidden: styles.mdDisplayVisuallyHidden
  }),
  mdColumn: bind(range('mdCol'), styles),
  mdDirection: mapping({
    row: styles.mdDirectionRow,
    column: styles.mdDirectionColumn
  }),

  lgDisplay: mapping({
    none: styles.lgDisplayNone,
    flex: styles.lgDisplayFlex,
    block: styles.lgDisplayBlock,
    inlineBlock: styles.lgDisplayInlineBlock,
    visuallyHidden: styles.lgDisplayVisuallyHidden
  }),
  lgColumn: bind(range('lgCol'), styles),
  lgDirection: mapping({
    row: styles.lgDirectionRow,
    column: styles.lgDirectionColumn
  }),

  alignContent: mapping({
    start: layout.contentStart,
    end: layout.contentEnd,
    center: layout.contentCenter,
    between: layout.contentBetween,
    around: layout.contentAround
    // default: stretch
  }),
  alignItems: mapping({
    start: layout.itemsStart,
    end: layout.itemsEnd,
    center: layout.itemsCenter,
    baseline: layout.itemsBaseline
    // default: stretch
  }),
  alignSelf: mapping({
    start: layout.selfStart,
    end: layout.selfEnd,
    center: layout.selfCenter,
    baseline: layout.selfBaseline,
    stretch: layout.selfStretch
    // default: auto
  }),
  bottom: toggle(layout.bottom0),
  color: mapping({
    blue: colors.blueBg,
    darkGray: colors.darkGrayBg,
    pine: colors.pineBg,
    gray: colors.grayBg,
    red: colors.redBg,
    olive: colors.oliveBg,
    lightGray: colors.lightGrayBg,
    white: colors.whiteBg,
    orange: colors.orangeBg,
    green: colors.greenBg,
    navy: colors.navyBg,
    midnight: colors.midnightBg,
    purple: colors.purpleBg,
    orchid: colors.orchidBg,
    eggplant: colors.eggplantBg,
    maroon: colors.maroonBg,
    watermelon: colors.watermelonBg,
    lightWash: colors.lightWashBg,
    darkWash: colors.darkWashBg
    // default: transparent
  }),
  fit: toggle(layout.fit),
  flex: mapping({
    grow: layout.flexGrow,
    none: layout.flexNone
    // default: shrink
  }),
  height: function (_height) {
    function height(_x) {
      return _height.apply(this, arguments);
    }

    height.toString = function () {
      return _height.toString();
    };

    return height;
  }(function (height) {
    return fromInlineStyle({ height: height });
  }),
  justifyContent: mapping({
    end: layout.justifyEnd,
    center: layout.justifyCenter,
    between: layout.justifyBetween,
    around: layout.justifyAround
    // default: start
  }),
  left: toggle(layout.left0),
  deprecatedMargin: function deprecatedMargin(value) {
    var mt = identity();
    var mb = identity();
    var ml = identity();
    var mr = identity();
    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
      case 'number':
        return fromClassName(whitespaceLegacy['m' + formatIntBoint(value)]);
      case 'object':
        if (value.top) {
          mt = fromClassName(whitespaceLegacy['mt' + formatIntBoint(value.top)]);
        }

        if (value.bottom) {
          mb = fromClassName(whitespaceLegacy['mb' + formatIntBoint(value.bottom)]);
        }

        if (value.left) {
          ml = fromClassName(value.left === 'auto' ? whitespaceLegacy.mlAuto : whitespaceLegacy['ml' + formatIntBoint(value.left)]);
        }

        if (value.right) {
          mr = fromClassName(value.right === 'auto' ? whitespaceLegacy.mrAuto : whitespaceLegacy['mr' + formatIntBoint(value.right)]);
        }
        return concat([mt, mb, ml, mr]);
      default:
        return identity();
    }
  },
  marginStart: marginStart,
  marginEnd: marginEnd,
  margin: margin,
  marginTop: marginTop,
  marginRight: marginRight,
  marginBottom: marginBottom,
  marginLeft: marginLeft,
  smMargin: smMargin,
  smMarginTop: smMarginTop,
  smMarginRight: smMarginRight,
  smMarginBottom: smMarginBottom,
  smMarginLeft: smMarginLeft,
  mdMargin: mdMargin,
  mdMarginTop: mdMarginTop,
  mdMarginRight: mdMarginRight,
  mdMarginBottom: mdMarginBottom,
  mdMarginLeft: mdMarginLeft,
  lgMargin: lgMargin,
  lgMarginTop: lgMarginTop,
  lgMarginRight: lgMarginRight,
  lgMarginBottom: lgMarginBottom,
  lgMarginLeft: lgMarginLeft,
  maxHeight: function (_maxHeight) {
    function maxHeight(_x2) {
      return _maxHeight.apply(this, arguments);
    }

    maxHeight.toString = function () {
      return _maxHeight.toString();
    };

    return maxHeight;
  }(function (maxHeight) {
    return fromInlineStyle({ maxHeight: maxHeight });
  }),
  maxWidth: function (_maxWidth) {
    function maxWidth(_x3) {
      return _maxWidth.apply(this, arguments);
    }

    maxWidth.toString = function () {
      return _maxWidth.toString();
    };

    return maxWidth;
  }(function (maxWidth) {
    return fromInlineStyle({ maxWidth: maxWidth });
  }),
  minHeight: function (_minHeight) {
    function minHeight(_x4) {
      return _minHeight.apply(this, arguments);
    }

    minHeight.toString = function () {
      return _minHeight.toString();
    };

    return minHeight;
  }(function (minHeight) {
    return fromInlineStyle({ minHeight: minHeight });
  }),
  minWidth: function (_minWidth) {
    function minWidth(_x5) {
      return _minWidth.apply(this, arguments);
    }

    minWidth.toString = function () {
      return _minWidth.toString();
    };

    return minWidth;
  }(function (minWidth) {
    return fromInlineStyle({ minWidth: minWidth });
  }),
  overflow: mapping({
    hidden: layout.overflowHidden,
    scroll: layout.overflowScroll,
    auto: layout.overflowAuto,
    scrollX: layout.overflowScrollX,
    scrollY: layout.overflowScrollY
    // default: visible
  }),
  deprecatedPadding: function deprecatedPadding(value) {
    switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
      case 'number':
        return fromClassName(whitespaceLegacy['p' + value]);
      case 'object':
        return concat([value.x ? fromClassName(whitespaceLegacy['px' + value.x]) : identity(), value.y ? fromClassName(whitespaceLegacy['py' + value.y]) : identity()]);
      default:
        return identity();
    }
  },
  padding: padding,
  paddingX: paddingX,
  paddingY: paddingY,
  smPadding: smPadding,
  smPaddingX: smPaddingX,
  smPaddingY: smPaddingY,
  mdPadding: mdPadding,
  mdPaddingX: mdPaddingX,
  mdPaddingY: mdPaddingY,
  lgPadding: lgPadding,
  lgPaddingX: lgPaddingX,
  lgPaddingY: lgPaddingY,
  position: mapping({
    absolute: layout.absolute,
    relative: layout.relative,
    fixed: layout.fixed
    // default: static
  }),
  right: toggle(layout.right0),
  shape: mapping({
    circle: borders.circle,
    pill: borders.pill,
    rounded: borders.rounded,
    roundedBottom: borders.roundedBottom,
    roundedLeft: borders.roundedLeft,
    roundedRight: borders.roundedRight,
    roundedTop: borders.roundedTop
    // default: square
  }),
  top: toggle(layout.top0),
  width: function (_width) {
    function width(_x6) {
      return _width.apply(this, arguments);
    }

    width.toString = function () {
      return _width.toString();
    };

    return width;
  }(function (width) {
    return fromInlineStyle({ width: width });
  }),
  wrap: toggle(layout.flexWrap),
  dangerouslySetInlineStyle: function dangerouslySetInlineStyle(value) {
    return (
      /* eslint-disable-next-line no-underscore-dangle */
      value && value.__style ? fromInlineStyle(value.__style) : identity()
    );
  }
};

/*

# The Component

*/

var contains = function contains(key, arr) {
  return arr.indexOf(key) >= 0;
};
var omit = function omit(keys, obj) {
  return Object.keys(obj).reduce(function (acc, k) {
    if (contains(k, keys)) {
      return acc;
    }
    return _extends({}, acc, defineProperty({}, k, obj[k]));
  }, {});
};

function Box(_ref) {
  var children = _ref.children,
      props = objectWithoutProperties(_ref, ['children']);

  // Flow can't reason about the constant nature of Object.keys so we can't use
  // a functional (reduce) style here.

  // Box is a "pass-through" component, meaning that if you pass properties to
  // it that it doesn't know about (`aria-label` for instance) it passes
  // directly back to the underlying `<div/>`. That's generally useful, but
  // we'd also like to strip out a few naughty properties that break style
  // encapsulation (className, style) or accessibility (onClick).
  var blacklist = ['onClick', 'className', 'style'];

  // All Box's are box-sized by default, so we start off building up the styles
  // to be applied with a Box base class.
  var s = fromClassName(styles.box);

  // This loops through each property and if it exists in the previously
  // defined transform map, concatentes the resulting styles to the base
  // styles. If there's a match, we also don't pass through that property. This
  // means Box's runtime is only dependent on the number of properties passed
  // to it (which is typically small) instead of the total number of possible
  // properties (~30 or so). While it may ~feel~ like Box is innefficient, its
  // biggest performance impact is on startup time because there's so much code
  // here.

  // eslint-disable-next-line no-restricted-syntax
  for (var prop in props) {
    if (Object.prototype.hasOwnProperty.call(propToFn, prop)) {
      var fn = propToFn[prop];
      var value = props[prop];
      blacklist = blacklist.concat(prop);
      s = concat([s, fn(value)]);
    }
  }

  // And... magic!
  return React.createElement(
    'div',
    _extends({}, omit(blacklist, props), toProps(s)),
    children
  );
}

/*

# PropTypes

And we're done here :)

*/

var ColumnPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

var MarginPropType = PropTypes.oneOf([-12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

var PaddingPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

Box.propTypes = {
  children: PropTypes.node,
  dangerouslySetInlineStyle: PropTypes.exact({
    __style: PropTypes.object
  }),

  xs: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  sm: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  md: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  lg: PropTypes.exact({
    display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
    column: PropTypes.number
  }),
  deprecatedMargin: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    top: PropTypes.number,
    bottom: PropTypes.number,
    left: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]),
    right: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])])
  })]),
  deprecatedPadding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number
  })]),

  display: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  direction: PropTypes.oneOf(['row', 'column']),
  column: ColumnPropType,

  smDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  smDirection: PropTypes.oneOf(['row', 'column']),
  smColumn: ColumnPropType,

  mdDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  mdDirection: PropTypes.oneOf(['row', 'column']),
  mdColumn: ColumnPropType,

  lgDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
  lgDirection: PropTypes.oneOf(['row', 'column']),
  lgColumn: ColumnPropType,

  alignContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around', 'stretch']),
  alignItems: PropTypes.oneOf(['start', 'end', 'center', 'baseline', 'stretch']),
  alignSelf: PropTypes.oneOf(['auto', 'start', 'end', 'center', 'baseline', 'stretch']),
  bottom: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'darkGray', 'darkWash', 'eggplant', 'gray', 'green', 'lightGray', 'lightWash', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'transparent', 'watermelon', 'white']),
  fit: PropTypes.bool,
  flex: PropTypes.oneOf(['grow', 'shrink', 'none']),
  grow: PropTypes.bool,
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  justifyContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around']),
  left: PropTypes.bool,

  marginStart: MarginPropType,
  marginEnd: MarginPropType,

  margin: MarginPropType,
  marginTop: MarginPropType,
  marginRight: MarginPropType,
  marginBottom: MarginPropType,
  marginLeft: MarginPropType,

  smMargin: MarginPropType,
  smMarginTop: MarginPropType,
  smMarginRight: MarginPropType,
  smMarginBottom: MarginPropType,
  smMarginLeft: MarginPropType,

  mdMargin: MarginPropType,
  mdMarginTop: MarginPropType,
  mdMarginRight: MarginPropType,
  mdMarginBottom: MarginPropType,
  mdMarginLeft: MarginPropType,

  lgMargin: MarginPropType,
  lgMarginTop: MarginPropType,
  lgMarginRight: MarginPropType,
  lgMarginBottom: MarginPropType,
  lgMarginLeft: MarginPropType,

  maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  overflow: PropTypes.oneOf(['visible', 'hidden', 'scroll', 'scrollX', 'scrollY', 'auto']),

  padding: PaddingPropType,
  paddingX: PaddingPropType,
  paddingY: PaddingPropType,

  smPadding: PaddingPropType,
  smPaddingX: PaddingPropType,
  smPaddingY: PaddingPropType,

  mdPadding: PaddingPropType,
  mdPaddingX: PaddingPropType,
  mdPaddingY: PaddingPropType,

  lgPadding: PaddingPropType,
  lgPaddingX: PaddingPropType,
  lgPaddingY: PaddingPropType,

  position: PropTypes.oneOf(['static', 'absolute', 'relative', 'fixed']),
  right: PropTypes.bool,
  shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight']),
  top: PropTypes.bool,
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  wrap: PropTypes.bool
};

var styles$1 = { "icon": "_s1", "iconBlock": "_s2 _29" };

var add = 'M22 10h-8V2a2 2 0 0 0-4 0v8H2a2 2 0 0 0 0 4h8v8a2 2 0 0 0 4 0v-8h8a2 2 0 0 0 0-4';

var addCircle = 'M17.75 13.25h-4.5v4.5a1.25 1.25 0 0 1-2.5 0v-4.5h-4.5a1.25 1.25 0 0 1 0-2.5h4.5v-4.5a1.25 1.25 0 0 1 2.5 0v4.5h4.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var addPin = 'M21.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L19 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76zm-11.25.81a1.25 1.25 0 0 1 0 2.5H7v3.25a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4.5V6.25a1.25 1.25 0 0 1 2.5 0V9.5h3.25z';

var angledPin = 'M13.988,19.153 C15.485,17.656 15.985,15.446 15.481,13.537 L19.740,9.074 L22.662,8.807 L22.645,8.789 C22.739,8.804 22.837,8.780 22.909,8.708 C23.030,8.587 23.031,8.391 22.910,8.271 L15.730,1.090 C15.609,0.970 15.413,0.970 15.292,1.091 C15.220,1.163 15.197,1.262 15.211,1.356 L15.194,1.338 L14.927,4.261 L10.463,8.520 C8.554,8.015 6.344,8.516 4.847,10.012 L8.656,13.821 L3.324,19.153 C2.562,19.915 0.711,22.108 1.039,22.962 C1.892,23.290 4.086,21.438 4.847,20.676 C5.609,19.915 10.179,15.344 10.179,15.344 L13.988,19.153 Z';

var arrowBack = 'M17.28 24c-.57 0-1.14-.22-1.58-.66L4.5 12 15.7.66a2.21 2.21 0 0 1 3.15 0c.87.88.87 2.3 0 3.18L10.79 12l8.06 8.16c.87.88.87 2.3 0 3.18-.44.44-1 .66-1.57.66';

var arrowCircleForward = 'M12.94 16.07c-.49.48-1.28.48-1.77 0a1.25 1.25 0 0 1 0-1.77l1.06-1.07H8.25a1.25 1.25 0 0 1 0-2.5h3.95L11.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.77 0L17 12l-4.06 4.07zM12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0z';

var arrowCircleDown = 'M0 12c0 6.63 5.37 12 12 12s12-5.37 12-12S18.63 0 12 0 0 5.37 0 12zm10.77-3.75a1.25 1.25 0 0 1 2.5 0v3.95l1.03-1.03a1.25 1.25 0 0 1 1.77 0c.48.49.48 1.28 0 1.77L12 17l-4.07-4.06c-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0l1.07 1.06V8.25z';

var arrowDown = 'M12 19.5L.66 8.29c-.88-.86-.88-2.27 0-3.14.88-.87 2.3-.87 3.18 0L12 13.21l8.16-8.06c.88-.87 2.3-.87 3.18 0 .88.87.88 2.28 0 3.14L12 19.5z';

var arrowForward = 'M6.72 24c.57 0 1.14-.22 1.57-.66L19.5 12 8.29.66c-.86-.88-2.27-.88-3.14 0-.87.88-.87 2.3 0 3.18L13.21 12l-8.06 8.16c-.87.88-.87 2.3 0 3.18.43.44 1 .66 1.57.66';

var arrowUp = 'M21.75 19.5c-.58 0-1.15-.22-1.59-.65L12 10.79l-8.16 8.06c-.88.87-2.3.87-3.18 0a2.21 2.21 0 0 1 0-3.15L12 4.5l11.34 11.2c.88.87.88 2.28 0 3.15-.44.43-1.01.65-1.59.65';

var arrowUpRight = 'M4.9283,1 C3.6273,1 2.5713,2.054 2.5713,3.357 C2.5713,4.66 3.6273,5.714 4.9283,5.714 L14.9523,5.714 L1.6893,18.976 C0.7703,19.896 0.7703,21.389 1.6893,22.31 C2.1503,22.771 2.7533,23 3.3573,23 C3.9603,23 4.5633,22.771 5.0243,22.31 L18.2853,9.047 L18.2853,19.071 C18.2853,20.374 19.3413,21.429 20.6433,21.429 C21.9443,21.429 23.0003,20.374 23.0003,19.071 L23.0003,1 L4.9283,1 Z';

var bell = 'M12 24c-1.66 0-3-1.34-3-3h6c0 1.66-1.34 3-3 3zm7-10.83c1.58 1.52 2.67 3.55 3 5.83H2c.33-2.28 1.42-4.31 3-5.83V7c0-3.87 3.13-7 7-7s7 3.13 7 7v6.17z';

var camera = 'M6.36 4.99L8.56 2h6.88l2.2 2.99h3.09c1.8 0 3.27 1.49 3.27 3.33v10.35c0 1.84-1.47 3.33-3.27 3.33H3.27C1.47 22 0 20.51 0 18.67V8.32c0-1.84 1.47-3.33 3.27-3.33h3.09zM12 7.22a5.74 5.74 0 1 0 0 11.48 5.74 5.74 0 0 0 0-11.48m0 2.73c1.66 0 3.01 1.35 3.01 3.01 0 1.66-1.35 3.01-3.01 3.01-1.66 0-3.01-1.35-3.01-3.01 0-1.66 1.35-3.01 3.01-3.01';

var cancel = 'M15.18 12l7.16-7.16c.88-.88.88-2.3 0-3.18-.88-.88-2.3-.88-3.18 0L12 8.82 4.84 1.66c-.88-.88-2.3-.88-3.18 0-.88.88-.88 2.3 0 3.18L8.82 12l-7.16 7.16c-.88.88-.88 2.3 0 3.18.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66L12 15.18l7.16 7.16c.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66.88-.88.88-2.3 0-3.18L15.18 12z';

var check = 'M9.17 21.75L.73 12.79c-.97-1.04-.97-2.71 0-3.75a2.403 2.403 0 0 1 3.53 0l4.91 5.22L19.74 3.03c.98-1.04 2.55-1.04 3.53 0 .97 1.03.97 2.71 0 3.74L9.17 21.75z';

var checkCircle = 'M18.88 9.88l-8.66 8.67-5.12-5.13a1.25 1.25 0 0 1 0-1.77c.48-.49 1.28-.49 1.76 0l3.36 3.36 6.9-6.89c.49-.49 1.28-.49 1.76 0 .49.49.49 1.28 0 1.76M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var circleOutline = 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var clear = 'M15.18 16.95L12 13.77l-3.18 3.18c-.49.49-1.28.49-1.77 0a1.25 1.25 0 0 1 0-1.77L10.23 12 7.05 8.82a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0L12 10.23l3.18-3.18a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.77L13.77 12l3.18 3.18c.49.49.49 1.28 0 1.77s-1.28.49-1.77 0M24 12c0-6.63-5.37-12-12-12S0 5.37 0 12s5.37 12 12 12 12-5.37 12-12';

var clock = 'M17.83 17.83c-.37.36-.85.55-1.33.55-.48 0-.96-.19-1.33-.55l-5.04-5.05V6c0-1.04.83-1.87 1.87-1.87s1.88.83 1.88 1.87v5.22l3.95 3.95c.73.74.73 1.92 0 2.66M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var cog = 'M6.25 2L.5 12l5.75 10h11.5l5.75-10-5.75-10H6.25zm1.703 10a4 4 0 1 1 8 0 4 4 0 0 1-8 0z';

var compass = 'M12.868 12.9A1.25 1.25 0 1 0 11.1 11.13a1.25 1.25 0 0 0 1.77 1.768m2.268 1.134c-.207.517-.62.924-1.139 1.124L5.62 18.38l3.223-8.377c.2-.52.607-.933 1.124-1.139l8.617-3.447-3.447 8.617zm5.348-10.519c-4.686-4.686-12.284-4.686-16.97 0-4.687 4.687-4.687 12.285 0 16.971 4.686 4.686 12.284 4.686 16.97 0 4.686-4.686 4.686-12.284 0-16.97z';

var dash = 'M20 16H4c-2.2 0-4-1.8-4-4s1.8-4 4-4h16c2.2 0 4 1.8 4 4s-1.8 4-4 4';

var edit = 'M13.386 6.018l4.596 4.596L7.097 21.499 1 22.999l1.501-6.096L13.386 6.018zm8.662-4.066a3.248 3.248 0 0 1 0 4.596L19.75 8.848 15.154 4.25l2.298-2.299a3.248 3.248 0 0 1 4.596 0z';

var ellipsis = 'M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3M3 9c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm18 0c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z';

var ellipsisCircleOutline = 'M12 10.5c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5-1.5-.6-1.5-1.5.6-1.5 1.5-1.5zm-4.5 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S6 12.9 6 12s.6-1.5 1.5-1.5zm9 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S15 12.9 15 12s.6-1.5 1.5-1.5zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var envelope = 'M21.53 7.508l-7.586 7.452c-.536.526-1.24.79-1.944.79a2.77 2.77 0 0 1-1.945-.79L2.47 7.508a.728.728 0 0 1 0-1.043.76.76 0 0 1 1.061 0l7.586 7.452c.487.48 1.28.48 1.768 0l7.585-7.452a.76.76 0 0 1 1.061 0 .728.728 0 0 1 0 1.043zM1 19h22V5H1v14z';

var eye = 'M10,12 C10,13.105 10.895,14 12,14 C13.105,14 14,13.105 14,12 C14,10.895 13.105,10 12,10 C10.895,10 10,10.895 10,12 Z M12,17 C9.239,17 7,14.761 7,12 C7,9.239 9.239,7 12,7 C14.761,7 17,9.239 17,12 C17,14.761 14.761,17 12,17 M12,3.5 C6.455,3.5 1.751,7.051 0,12 C1.751,16.949 6.455,20.5 12,20.5 C17.545,20.5 22.249,16.949 24,12 C22.249,7.051 17.545,3.5 12,3.5';

var facebook = 'M17.75 3.984l-2.312.001c-1.811 0-2.163.842-2.163 2.077v2.724h4.323l-.563 4.267h-3.76V24H8.769V13.053H5V8.786h3.769V5.64C8.769 1.988 11.05 0 14.383 0c1.596 0 2.967.116 3.367.168v3.816z';

var faceHappy = 'M12.023 20.713c-2.944 0-5.378-1.96-5.356-4.906.017-2.117 1.728-.536 5.33-.545 3.6-.01 5.322-1.645 5.327.548.007 2.946-2.356 4.903-5.3 4.903m4.439-9.83a1.675 1.675 0 1 1 0-3.351 1.675 1.675 0 0 1 0 3.35M6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0m17.906 2.782C23.994 5.367 18.623 0 12 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12 12C18.624 24 23.995 18.633 24 12.01L24 12l-.001-.01';

var faceSad = 'M17.088 17.841a1.2 1.2 0 0 1-1.593.58 4.517 4.517 0 0 0-.744-.217c-.738-.168-1.653-.27-2.75-.271-1.098 0-2.012.103-2.752.27-.411.094-.657.18-.741.217a1.199 1.199 0 1 1-1.014-2.174c.237-.11.643-.251 1.223-.383.915-.207 2.008-.33 3.284-.33 1.276.001 2.369.123 3.281.33.582.132.988.273 1.226.384.601.279.86.992.58 1.594zm-.624-6.959a1.675 1.675 0 1 1 0-3.35 1.675 1.675 0 0 1 0 3.35zM6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0zM24 11.989C23.995 5.367 18.624 0 12.002 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12.002 12C18.623 24 23.995 18.633 24 12.01v-.02z';

var faceSmiley = 'M16.5 11a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m.449 5.95A6.947 6.947 0 0 1 12 19a6.96 6.96 0 0 1-4.948-2.048.999.999 0 0 1 0-1.414.999.999 0 0 1 1.414-.001A4.968 4.968 0 0 0 12 17c1.336 0 2.592-.52 3.535-1.464a1 1 0 0 1 1.414 1.414M6 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0';

var filter = 'M24 3.5c0-1.1-.9-2-2-2H2c-1.1 0-2 .9-2 2 0 .55.22 1.05.58 1.41L9 13.46v9.04l6-2v-7.05l8.37-8.5c.39-.36.63-.88.63-1.45';

var flag = 'M17 7.5L22 0H2v22c0 1.1.9 2 2 2s2-.9 2-2v-7h16l-5-7.5z';

var flashlight = 'M6 7.08V10H1V7.08A6.086 6.086 0 0 1 7.079 1H10v5H6v1.08zM6 18h4v5H7.079A6.086 6.086 0 0 1 1 16.921V14h5v4zM16.92 1A6.086 6.086 0 0 1 23 7.079V10h-5V6h-4V1h2.92zM18 16.92V14h5v2.92A6.086 6.086 0 0 1 16.921 23H14v-5h4v-1.08z';

var gif = 'M19.5 3h-15C2.02 3 0 5.03 0 7.5v9C0 18.98 2.02 21 4.5 21h15c2.47 0 4.5-2.02 4.5-4.5v-9C24 5.03 21.97 3 19.5 3zm-7.41 12.88v-7.8h1.59v7.8h-1.59zm3.45-7.8h5.58v1.34h-4v1.88h3.39v1.35h-3.39v3.23h-1.58v-7.8zm-11.4 6.83c-.33-.37-.58-.79-.76-1.28-.17-.49-.26-1.03-.26-1.62 0-.66.11-1.26.33-1.8.22-.55.53-1.01.95-1.39.32-.29.68-.51 1.1-.66.41-.15.88-.23 1.4-.23.49 0 .93.06 1.32.19s.72.31 1 .54c.27.23.5.51.67.83.17.32.29.67.35 1.04H8.69a1.67 1.67 0 0 0-.56-.93c-.29-.24-.69-.36-1.19-.36-.37 0-.7.07-.97.21-.27.14-.5.34-.69.59-.18.25-.32.54-.41.88-.09.34-.13.7-.13 1.09 0 .4.05.77.15 1.1.1.34.25.63.43.88.19.24.42.43.69.57.27.14.57.21.9.21.31 0 .59-.05.83-.16.25-.1.46-.23.64-.4.17-.17.31-.36.4-.57.1-.21.14-.42.14-.64v-.04H7.05v-1.22h3.28v4.14H9.14l-.05-1.05h-.03c-.27.45-.58.77-.94.94a2.8 2.8 0 0 1-1.25.27c-.59 0-1.11-.1-1.56-.3-.46-.2-.85-.48-1.17-.83z';

var globe = 'M15.49 20.83c.87-2.01 1.37-4.75 1.48-7.58h4.44a9.53 9.53 0 0 1-5.92 7.58zm-12.9-7.58h4.44c.11 2.83.61 5.57 1.49 7.58-3.15-1.25-5.47-4.12-5.93-7.58zM8.52 3.17c-.88 2.01-1.38 4.75-1.49 7.58H2.59c.46-3.46 2.78-6.33 5.93-7.58zm1.01 7.58C9.76 5.43 11.4 2.54 12 2.5h.01c.67.06 2.24 3.01 2.46 8.25H9.53zm2.48 10.75H12c-.6-.04-2.24-2.93-2.47-8.25h4.94c-.22 5.24-1.79 8.19-2.46 8.25zm9.4-10.75h-4.44c-.11-2.83-.61-5.57-1.48-7.58a9.53 9.53 0 0 1 5.92 7.58zM24 12C24 5.39 18.62.01 12.01 0H12C5.38 0 0 5.38 0 12s5.38 12 12 12h.01C18.62 24 24 18.61 24 12z';

var globeChecked = 'M6.8 9.8H3.1C3.5 7 5.4 4.6 8 3.6c-.7 1.7-1.1 3.9-1.2 6.2m-3.7 2.1h3.7c.1 2.3.5 4.6 1.2 6.2-2.6-1-4.5-3.3-4.9-6.2m7.8-8.8c.5 0 1.8 2.4 2 6.7H8.8c.2-4.3 1.6-6.7 2.1-6.7M9.5 16.3c-.3-1.1-.6-2.6-.7-4.4h2.7c.9-1 2.1-1.7 3.5-2.1-.1-2.3-.5-4.5-1.3-6.2 2.6 1 4.4 3.3 4.9 6.1.7.1 1.5.4 2.1.8-.2-5.3-4.5-9.5-9.8-9.5C5.4 1 1 5.4 1 10.9c0 5.3 4.2 9.6 9.5 9.8-.6-1.1-1-2.3-1-3.7v-.7m10.8-.5L16.2 20l-2.5-2.5c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1 0l1.5 1.5 3.1-3.2c.2-.3.7-.3 1 0 .3.3.3.8 0 1.1M17 11c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6-2.7-6-6-6';

var gmail = 'M3.173 4L12 10.194 20.556 4H3.173zM12 13.29L1 5.806V20h22V5.548L12 13.29z';

var googlePlus = 'M7 11v2.4h3.97c-.16 1.029-1.2 3.02-3.97 3.02-2.39 0-4.34-1.979-4.34-4.42 0-2.44 1.95-4.42 4.34-4.42 1.36 0 2.27.58 2.79 1.08l1.9-1.83C10.47 5.69 8.89 5 7 5c-3.87 0-7 3.13-7 7s3.13 7 7 7c4.04 0 6.721-2.84 6.721-6.84 0-.46-.051-.81-.111-1.16H7zm17 0v2h-3v3h-2v-3h-3v-2h3V8h2v3h3z';

var graphBar = 'M1 23V10h5v13H1zm8.5 0V1h5v22h-5zm8.5 0V7h4.999v16H18z';

var knoop = 'M15 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-6-6c-.83 0-1.5-.67-1.5-1.5S8.17 7.5 9 7.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var lightbulb = 'M20 8c0 2.23-.91 4.24-2.39 5.7h.02c-.99.97-1.6 2.31-1.63 3.8V19H8v-1.5c-.03-1.5-.65-2.85-1.64-3.83A7.955 7.955 0 0 1 4 8c0-4.42 3.58-8 8-8s8 3.58 8 8zM8 22.5V21h8v1.5c0 .83-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z';

var handle = 'M3 15h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 1 1 0-2z';

var handPointing = 'M17.776,22.390 C13.775,23.978 9.246,22.359 7.219,18.770 C7.040,18.503 6.860,18.218 6.688,17.910 C5.132,15.163 3.028,13.782 2.588,13.581 C2.149,13.378 0.595,12.613 1.100,11.692 C1.381,11.180 2.163,10.801 2.878,10.726 C4.000,10.481 5.897,11.034 7.772,12.222 L4.054,3.419 C3.741,2.677 3.989,1.850 4.609,1.379 C4.612,1.376 4.616,1.373 4.621,1.369 C4.676,1.327 4.734,1.289 4.796,1.253 C4.810,1.247 4.821,1.239 4.835,1.231 C4.901,1.195 4.970,1.160 5.042,1.132 C5.044,1.131 5.044,1.131 5.045,1.131 C5.045,1.131 5.045,1.131 5.047,1.129 C5.119,1.101 5.193,1.079 5.267,1.060 C5.281,1.057 5.295,1.054 5.309,1.049 C5.380,1.035 5.449,1.021 5.518,1.013 C5.525,1.013 5.529,1.011 5.534,1.011 C6.317,0.928 7.093,1.347 7.406,2.088 L9.592,7.261 C9.643,6.623 10.055,6.035 10.709,5.776 C11.633,5.410 12.689,5.839 13.069,6.734 C13.071,6.742 13.074,6.752 13.077,6.759 C13.143,6.136 13.552,5.565 14.191,5.312 C15.117,4.946 16.173,5.373 16.551,6.271 C16.567,6.305 16.578,6.341 16.591,6.379 C16.680,5.784 17.079,5.249 17.695,5.006 C18.619,4.640 19.619,4.970 19.999,5.867 L20.001,5.872 C20.001,5.872 21.115,8.039 22.366,11.651 C22.413,11.791 22.457,11.931 22.495,12.072 C24.027,16.161 21.967,20.728 17.776,22.390';

var heart = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25z';

var heartBroken = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25zM15.3 9.54c.4-.4.4-1.06 0-1.46-.4-.4-1.05-.4-1.45 0L12 9.94l-1.85-1.86c-.4-.4-1.05-.4-1.45 0-.4.4-.4 1.06 0 1.46l1.85 1.86-1.85 1.86c-.4.4-.4 1.05 0 1.45.4.4 1.05.41 1.45 0L12 12.85l1.85 1.86c.4.41 1.05.41 1.45 0 .4-.4.4-1.05 0-1.45l-1.85-1.86 1.85-1.86z';

var link = 'M21 15.05c1.1 0 2 .9 2 2V21c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2h4a2 2 0 1 1 0 4H5v14h14v-1.95c0-1.1.9-2 2-2zM12 14c-.51 0-1.02-.2-1.41-.59-.79-.78-.79-2.04 0-2.82L16.16 5 14 5.01c-1.1 0-2-.9-2-2 0-1.11.89-2 2-2L20.99 1h2v2l.01 7a2 2 0 1 1-4 0V7.83l-5.59 5.58c-.39.39-.9.59-1.41.59z';

var location = 'M12 4.5c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3m7.5 3C19.5 3.36 16.14 0 12 0 7.86 0 4.5 3.36 4.5 7.5c0 1.3.36 2.5.94 3.56H5.4L12 24l6.6-12.94h-.04c.58-1.06.94-2.26.94-3.56';

var lock = 'M8 10V7c0-2.206 1.794-4 4-4s4 1.794 4 4v3H8zm11 .017V7c0-3.86-3.141-7-7-7S5 3.14 5 7v3.017a8.698 8.698 0 0 0-1.75 5.233 8.75 8.75 0 1 0 17.5 0A8.698 8.698 0 0 0 19 10.017z';

var maximize = 'M11 2.25c0 .69-.56 1.25-1.25 1.25H5.268l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L3.5 5.268V9.75a1.25 1.25 0 0 1-2.5 0V1h8.75c.69 0 1.25.56 1.25 1.25zM21.75 13c.69 0 1.25.56 1.25 1.25V23h-8.75a1.25 1.25 0 0 1 0-2.5h4.482l-5.366-5.366a1.25 1.25 0 0 1 1.768-1.768l5.366 5.366V14.25c0-.69.56-1.25 1.25-1.25z';

var megaphone = 'M14 17.5c0 1.378-1.122 2.5-2.5 2.5A2.503 2.503 0 0 1 9 17.5V17h5v.5zm8.947-1.87L18.701 2.712a1.022 1.022 0 0 0-1.566-.521l-15.7 11.24c-.37.264-.525.744-.382 1.179l.551 1.678c.14.425.532.712.974.712H7v.5a4.5 4.5 0 0 0 9 0V17h5.973c.7 0 1.195-.696.974-1.37z';

var menu = 'M21.5 9.5c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 14.5 0 13.38 0 12c0-1.37 1.13-2.5 2.5-2.5h19zm-19-3C1.13 6.5 0 5.38 0 4c0-1.37 1.13-2.5 2.5-2.5h19C22.88 1.5 24 2.63 24 4a2.5 2.5 0 0 1-2.5 2.5h-19zm19 11c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 22.5 0 21.38 0 20c0-1.37 1.13-2.5 2.5-2.5h19z';

var minimize = 'M1 9.75c0-.69.56-1.25 1.25-1.25h4.482L1.366 3.134a1.25 1.25 0 0 1 1.768-1.768L8.5 6.732V2.25a1.25 1.25 0 0 1 2.5 0V11H2.25C1.56 11 1 10.44 1 9.75zM14.25 23c-.69 0-1.25-.56-1.25-1.25V13h8.75a1.25 1.25 0 0 1 0 2.5h-4.482l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L15.5 17.268v4.482c0 .69-.56 1.25-1.25 1.25z';

var move = 'M14.3 18.17a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.76L12 24l-4.07-4.07c-.48-.48-.48-1.27 0-1.76a1.25 1.25 0 0 1 1.77 0l1.05 1.04v-3.96a1.25 1.25 0 0 1 2.5 0v3.96l1.05-1.04zm-9.51-4.92l1.04 1.05c.49.49.49 1.28 0 1.77-.48.48-1.28.48-1.76 0L0 12l4.07-4.07c.48-.48 1.28-.48 1.76 0 .49.49.49 1.28 0 1.77l-1.04 1.05h3.96a1.25 1.25 0 0 1 0 2.5H4.79zm15.14-5.32L24 12l-4.07 4.07c-.48.48-1.27.48-1.76 0a1.25 1.25 0 0 1 0-1.77l1.04-1.05h-3.96a1.25 1.25 0 0 1 0-2.5h3.96L18.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.76 0zM9.7 5.83c-.49.49-1.28.49-1.77 0-.48-.49-.48-1.28 0-1.76L12 0l4.07 4.07c.49.48.49 1.27 0 1.76s-1.28.49-1.77 0l-1.05-1.04v3.96a1.25 1.25 0 0 1-2.5 0V4.79L9.7 5.83z';

var mute = 'M5.00,7.94 L5.00,7.96 L12.00,1.00 L12.00,23.00 L5.00,16.91 L5.00,16.94 L2.00,16.94 C0.90,16.94 0.00,16.04 0.00,14.94 L0.00,9.94 C0.00,8.83 0.90,7.94 2.00,7.94 L5.00,7.94 Z M23.63,14.12 C24.12,14.60 24.12,15.39 23.63,15.88 C23.15,16.37 22.35,16.37 21.87,15.88 L19.75,13.77 L17.63,15.88 C17.15,16.37 16.35,16.37 15.87,15.88 C15.38,15.39 15.38,14.60 15.87,14.12 L17.98,12.00 L15.87,9.88 C15.38,9.39 15.38,8.60 15.87,8.12 C16.35,7.63 17.15,7.63 17.63,8.12 L19.75,10.23 L21.86,8.12 C22.35,7.63 23.15,7.63 23.63,8.12 C24.12,8.60 24.12,9.40 23.63,9.88 L21.52,12.00 L23.63,14.12 Z';

var pause = 'M7 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3zm10 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3z';

var people = 'M8 11a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9zm10 3c3.314 0 6 2.713 6 6.061V22H0v-1.919C0 15.618 3.582 12 8 12c2.614 0 4.927 1.272 6.387 3.23A5.927 5.927 0 0 1 18 14zm0-1a3.25 3.25 0 1 1 0-6.5 3.25 3.25 0 0 1 0 6.5z';

var person = 'M12 12c5.523 0 10 4.477 10 10v2H2v-2c0-5.523 4.477-10 10-10zm0-1a5.5 5.5 0 1 1 0-11 5.5 5.5 0 1 1 0 11z';

var personAdd = 'M16.5 12a7.5 7.5 0 0 1 7.5 7.5V21H9v-1.5a7.5 7.5 0 0 1 7.5-7.5zm0-1a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm-7.25 1H6.5v2.75a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4V6.75a1.25 1.25 0 0 1 2.5 0V9.5h2.75a1.25 1.25 0 0 1 0 2.5z';

var pin = 'M18 13.5c0-2.22-1.21-4.15-3-5.19V2.45A2.5 2.5 0 0 0 17 0H7a2.5 2.5 0 0 0 2 2.45v5.86c-1.79 1.04-3 2.97-3 5.19h5v8.46L12 24l1-2.04V13.5h5z';

var pinHide = 'M9.13 6.37c.49.48.49 1.27 0 1.76l-2.61 2.62 2.61 2.62c.49.48.49 1.27 0 1.76-.48.49-1.27.49-1.76 0l-2.62-2.61-2.62 2.61c-.48.49-1.28.49-1.76 0-.49-.49-.49-1.28 0-1.76l2.61-2.62L.37 8.13c-.49-.49-.49-1.28 0-1.76.48-.49 1.28-.49 1.76 0l2.62 2.61 2.62-2.61c.49-.49 1.28-.49 1.76 0zM20.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L18 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76z';

var pinterest = 'M0 12c0 5.123 3.211 9.497 7.73 11.218-.11-.937-.227-2.482.025-3.566.217-.932 1.401-5.938 1.401-5.938s-.357-.715-.357-1.774c0-1.66.962-2.9 2.161-2.9 1.02 0 1.512.765 1.512 1.682 0 1.025-.653 2.557-.99 3.978-.281 1.189.597 2.159 1.769 2.159 2.123 0 3.756-2.239 3.756-5.471 0-2.861-2.056-4.86-4.991-4.86-3.398 0-5.393 2.549-5.393 5.184 0 1.027.395 2.127.889 2.726a.36.36 0 0 1 .083.343c-.091.378-.293 1.189-.332 1.355-.053.218-.173.265-.4.159-1.492-.694-2.424-2.875-2.424-4.627 0-3.769 2.737-7.229 7.892-7.229 4.144 0 7.365 2.953 7.365 6.899 0 4.117-2.595 7.431-6.199 7.431-1.211 0-2.348-.63-2.738-1.373 0 0-.599 2.282-.744 2.84-.282 1.084-1.064 2.456-1.549 3.235C9.584 23.815 10.77 24 12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12';

var play = 'M20.62 9.48L6.63.48C4.63-.8 2 .63 2 3v18c0 2.37 2.63 3.8 4.63 2.52l13.99-9c1.84-1.18 1.84-3.86 0-5.04';

var questionMark = 'M14.34 21.2c0 1.57-1.19 2.8-2.78 2.8-1.58 0-2.77-1.23-2.77-2.8 0-1.57 1.19-2.8 2.77-2.8 1.59 0 2.78 1.23 2.78 2.8m-2.53-10.88c1.41-1.23 3.3-2.05 3.3-3.87 0-1.45-1.24-2.36-2.95-2.36-2.12 0-3.52 1.48-3.55 3.43H3.75C3.88 3.3 6.96 0 12.34 0c4.86 0 7.91 2.52 7.91 6.32 0 2.36-1.09 3.81-2.3 4.78-1.68 1.33-2.84 1.89-3.49 2.61-.5.57-.62 1.04-.65 1.95H9.45c0-2.64.65-3.9 2.36-5.34';

var remove = 'M17.75 13.25H6.25a1.25 1.25 0 0 1 0-2.5h11.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

var report = 'M7.91 18.89A8.013 8.013 0 0 0 18.89 7.91L7.91 18.89zm-2.82-2.83L16.06 5.09A8.015 8.015 0 0 0 5.09 16.06zM12 24C5.37 24 0 18.63 0 12S5.37 0 12 0s12 5.37 12 12-5.37 12-12 12z';

var search = 'M10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6m13.12 2.88l-4.26-4.26A9.842 9.842 0 0 0 20 10c0-5.52-4.48-10-10-10S0 4.48 0 10s4.48 10 10 10c1.67 0 3.24-.41 4.62-1.14l4.26 4.26a3 3 0 0 0 4.24 0 3 3 0 0 0 0-4.24';

var send = 'M6 6l-6 6 7.67 2.56L21 3 9.44 16.34 12 24l6-6 6-18';

var share = 'M21 14c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2v-6c0-1.1.9-2 2-2s2 .9 2 2v4h14v-4c0-1.1.9-2 2-2zM8.82 8.84c-.78.78-2.05.79-2.83 0-.78-.78-.79-2.04-.01-2.82L11.99 0l6.02 6.01c.78.78.79 2.05.01 2.83-.78.78-2.05.79-2.83 0l-1.2-1.19v6.18a2 2 0 1 1-4 0V7.66L8.82 8.84z';

var shoppingBag = 'M9.5 5a2.5 2.5 0 0 1 5 0v2h-5V5zM17 7V5c0-2.76-2.24-5-5-5S7 2.24 7 5v2H2v15c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7h-5z';

var smiley = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71z';

var smileyOutline = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

var sound = 'M20.48 3.51A11.92 11.92 0 0 1 24 12c0 3.2-1.25 6.22-3.51 8.48-.25.25-.57.37-.89.37-.32 0-.64-.12-.88-.37-.49-.48-.49-1.27 0-1.76A9.465 9.465 0 0 0 21.5 12c0-2.54-.99-4.93-2.79-6.72-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0zM5 7.94v.02L12 1v22l-7-6.09v.03H2c-1.1 0-2-.9-2-2v-5a2 2 0 0 1 2-2h3zm11.95-.89A6.96 6.96 0 0 1 19 12c0 1.87-.73 3.63-2.05 4.95-.24.24-.56.36-.88.36-.32 0-.64-.12-.89-.36a1.25 1.25 0 0 1 0-1.77c.85-.85 1.32-1.98 1.32-3.18 0-1.2-.47-2.33-1.32-3.18a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0z';

var speech = 'M12 0C5.85 0 .75 4.94.75 11.08c0 2.7.9 5.24 2.7 7.19L2.1 23.51c-.15.3.3.6.6.45l5.25-2.55c1.35.45 2.7.75 4.05.75 6.15 0 11.25-4.94 11.25-11.08S18.15 0 12 0';

var speechEllipsis = 'M18 12.5a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 18 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 12 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 6 12.5M12 0C5.925 0 1 4.925 1 11c0 2.653.94 5.086 2.504 6.986L2 24l5.336-3.049A10.93 10.93 0 0 0 12 22c6.075 0 11-4.925 11-11S18.075 0 12 0';

var tag = 'M6 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m7.36-6.2l8.84 8.84a2.71 2.71 0 0 1 0 3.85l-7.71 7.71a2.71 2.71 0 0 1-3.85 0L1.8 13.36c-.51-.51-.8-1.2-.8-1.92V3.73C1 2.22 2.22 1 3.73 1h7.71c.72 0 1.41.29 1.92.8';

var twitter = 'M7.548 21.5c9.056 0 14.01-7.31 14.01-13.65 0-.208 0-.414-.015-.62A9.88 9.88 0 0 0 24 4.747c-.899.388-1.852.642-2.828.754a4.838 4.838 0 0 0 2.165-2.653c-.967.559-2.024.953-3.127 1.164-1.526-1.58-3.952-1.968-5.916-.944-1.964 1.025-2.98 3.205-2.475 5.32C7.859 8.194 4.17 6.372 1.67 3.375.363 5.567 1.031 8.372 3.195 9.78a4.986 4.986 0 0 1-2.235-.6v.06c0 2.284 1.653 4.25 3.95 4.703a5.042 5.042 0 0 1-2.223.082c.645 1.954 2.494 3.293 4.6 3.332A10.048 10.048 0 0 1 0 19.345a14.21 14.21 0 0 0 7.548 2.151';

var viewTypeDefault = 'M13.5 24V13.5H24V24H13.5zM0 10.5V0h10.5v10.5H0zm13.5 0V0H24v10.5H13.5zM0 24V13.5h10.5V24H0z';

var viewTypeDense = 'M17.999 24H24v-6h-6.001v6zm-9-17.999V0h6v6.001H9zM0 6.001V0h6v6.001H0zm17.999 0V0H24v6.001h-6.001zM0 15.001V9h6v6H0zm9 0V9h6v6H9zm8.999 0V9H24v6h-6.001zM0 24v-6h6v6H0zm9 0v-6h6v6H9z';

var viewTypeList = 'M0 13.502v-3h24v3H0zm0-7.5V3h24v3.002H0zm0 15v-3h24v3H0z';

var icons = {
  add: add,
  'add-circle': addCircle,
  'add-pin': addPin,
  'angled-pin': angledPin,
  'arrow-back': arrowBack,
  'arrow-circle-down': arrowCircleDown,
  'arrow-circle-forward': arrowCircleForward,
  'arrow-down': arrowDown,
  'arrow-forward': arrowForward,
  'arrow-up': arrowUp,
  'arrow-up-right': arrowUpRight,
  bell: bell,
  camera: camera,
  cancel: cancel,
  check: check,
  'check-circle': checkCircle,
  'circle-outline': circleOutline,
  clear: clear,
  clock: clock,
  cog: cog,
  compass: compass,
  dash: dash,
  edit: edit,
  ellipsis: ellipsis,
  'ellipsis-circle-outline': ellipsisCircleOutline,
  envelope: envelope,
  eye: eye,
  facebook: facebook,
  'face-happy': faceHappy,
  'face-sad': faceSad,
  'face-smiley': faceSmiley,
  filter: filter,
  flag: flag,
  flashlight: flashlight,
  gif: gif,
  globe: globe,
  'globe-checked': globeChecked,
  gmail: gmail,
  'google-plus': googlePlus,
  'graph-bar': graphBar,
  handle: handle,
  'hand-pointing': handPointing,
  heart: heart,
  'heart-broken': heartBroken,
  knoop: knoop,
  lightbulb: lightbulb,
  link: link,
  location: location,
  lock: lock,
  maximize: maximize,
  megaphone: megaphone,
  menu: menu,
  minimize: minimize,
  move: move,
  mute: mute,
  pause: pause,
  people: people,
  person: person,
  'person-add': personAdd,
  pin: pin,
  'pin-hide': pinHide,
  pinterest: pinterest,
  play: play,
  'question-mark': questionMark,
  remove: remove,
  report: report,
  search: search,
  'shopping-bag': shoppingBag,
  smiley: smiley,
  'smiley-outline': smileyOutline,
  send: send,
  share: share,
  sound: sound,
  speech: speech,
  'speech-ellipsis': speechEllipsis,
  tag: tag,
  twitter: twitter,
  'view-type-default': viewTypeDefault,
  'view-type-dense': viewTypeDense,
  'view-type-list': viewTypeList
};

var IconNames = Object.keys(icons);

function Icon(props) {
  var accessibilityLabel = props.accessibilityLabel,
      _props$color = props.color,
      color = _props$color === undefined ? 'gray' : _props$color,
      icon = props.icon,
      inline = props.inline,
      _props$size = props.size,
      size = _props$size === undefined ? 16 : _props$size,
      dangerouslySetSvgPath = props.dangerouslySetSvgPath;


  var cs = classnames(styles$1.icon, colors[color], defineProperty({}, styles$1.iconBlock, !inline));

  var path = icon && icons[icon] ||
  /* eslint-disable-next-line no-underscore-dangle */
  dangerouslySetSvgPath && dangerouslySetSvgPath.__path || undefined;

  var ariaHidden = accessibilityLabel === '' ? true : null;

  return React.createElement(
    'svg',
    {
      className: cs,
      height: size,
      width: size,
      viewBox: '0 0 24 24',
      'aria-hidden': ariaHidden,
      'aria-label': accessibilityLabel,
      role: 'img'
    },
    React.createElement(
      'title',
      null,
      accessibilityLabel
    ),
    React.createElement('path', { d: path })
  );
}

Icon.icons = IconNames;

Icon.propTypes = {
  accessibilityLabel: PropTypes.string.isRequired,
  color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
  dangerouslySetSvgPath: PropTypes.shape({
    __path: PropTypes.string
  }),
  icon: PropTypes.oneOf(IconNames),
  inline: PropTypes.bool,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};

var styles$2 = { "img": "_s3 _29 _45 _2l", "scaled-img": "_s4 _2j", "contain": "_s5 _s4 _2j", "cover": "_s6 _s4 _2j" };

var shouldScaleImage = function shouldScaleImage(fit) {
  return fit === 'cover' || fit === 'contain';
};

var Image = function (_React$PureComponent) {
  inherits(Image, _React$PureComponent);

  function Image() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Image);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Image.__proto__ || Object.getPrototypeOf(Image)).call.apply(_ref, [this].concat(args))), _this), _this.handleLoad = function () {
      if (_this.props.onLoad) {
        _this.props.onLoad();
      }
    }, _this.handleError = function () {
      if (_this.props.onError) {
        _this.props.onError();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Image, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (shouldScaleImage(this.props.fit)) {
        this.loadImage();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var _props = this.props,
          fit = _props.fit,
          src = _props.src;

      if (shouldScaleImage(fit) && prevProps.src !== src) {
        this.loadImage();
      }
    }
  }, {
    key: 'loadImage',
    value: function loadImage() {
      if (typeof window !== 'undefined') {
        var image = new window.Image();
        image.onload = this.handleLoad;
        image.onerror = this.handleError;
        image.src = this.props.src;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          alt = _props2.alt,
          color = _props2.color,
          children = _props2.children,
          fit = _props2.fit,
          naturalHeight = _props2.naturalHeight,
          naturalWidth = _props2.naturalWidth,
          sizes = _props2.sizes,
          src = _props2.src,
          srcSet = _props2.srcSet;


      var isScaledImage = shouldScaleImage(fit);
      var childContent = children ? React.createElement(
        Box,
        { position: 'absolute', top: true, left: true, bottom: true, right: true, overflow: 'hidden' },
        children
      ) : null;

      return isScaledImage ? React.createElement(
        'div',
        {
          'aria-label': alt,
          className: styles$2[fit],
          style: {
            backgroundColor: color,
            backgroundImage: 'url(\'' + src + '\')'
          },
          role: 'img'
        },
        childContent
      ) : React.createElement(
        Box,
        {
          position: 'relative',
          dangerouslySetInlineStyle: {
            __style: {
              backgroundColor: color,
              paddingBottom: naturalHeight / naturalWidth * 100 + '%'
            }
          }
        },
        React.createElement('img', {
          alt: alt,
          className: styles$2.img,
          onError: this.handleError,
          onLoad: this.handleLoad,
          sizes: sizes,
          src: src,
          srcSet: srcSet
        }),
        childContent
      );
    }
  }]);
  return Image;
}(React.PureComponent);

Image.propTypes = {
  alt: PropTypes.string.isRequired,
  children: PropTypes.node,
  color: PropTypes.string,
  fit: PropTypes.oneOf(['contain', 'cover', 'none']),
  naturalHeight: PropTypes.number.isRequired,
  naturalWidth: PropTypes.number.isRequired,
  onError: PropTypes.func,
  onLoad: PropTypes.func,
  sizes: PropTypes.string,
  src: PropTypes.string.isRequired,
  srcSet: PropTypes.string
};
Image.defaultProps = {
  color: 'transparent',
  fit: 'none'
};

var styles$3 = { "Mask": "_s7 _2d _2j", "square": "_s8 _5b", "rounded": "_s9 _5e", "circle": "_sa _5c", "wash": "_sb _2l _2p _2q _2o _2n" };

function Mask(props) {
  var children = props.children,
      _props$shape = props.shape,
      shape = _props$shape === undefined ? 'square' : _props$shape,
      width = props.width,
      height = props.height,
      _props$wash = props.wash,
      wash = _props$wash === undefined ? false : _props$wash;

  return React.createElement(
    'div',
    { className: classnames(styles$3.Mask, styles$3[shape]), style: { width: width, height: height } },
    children,
    wash && React.createElement('div', { className: styles$3.wash })
  );
}

Mask.propTypes = {
  children: PropTypes.node,
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  shape: PropTypes.oneOf(['circle', 'rounded', 'square']),
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  wash: PropTypes.bool
};

var typography = { "antialiased": "_sc", "sansSerif": "_sd", "letterSpacing": "_se", "leadingShort": "_sf", "leadingTall": "_sg", "fontWeightNormal": "_sh", "fontWeightBold": "_si", "fontStyleRegular": "_sj", "fontStyleItalic": "_sk", "underline": "_sl", "noUnderline": "_sm", "breakWord": "_sn", "truncate": "_so", "alignLeft": "_sp", "alignRight": "_sq", "alignCenter": "_sr", "textJustify": "_ss" };

var Square = function Square(props) {
  return React.createElement(
    Box,
    _extends({}, props, { position: 'relative' }),
    React.createElement(Box, {
      dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } },
      position: 'relative'
    }),
    React.createElement(
      Box,
      { position: 'absolute', top: true, left: true, bottom: true, right: true },
      props.children
    )
  );
};

var DefaultAvatar = function DefaultAvatar(_ref) {
  var name = _ref.name;

  var firstInitial = name ? [].concat(toConsumableArray(name))[0].toUpperCase() : '';
  return React.createElement(
    Square,
    { color: 'gray', shape: 'circle' },
    firstInitial && React.createElement(
      'svg',
      {
        width: '100%',
        viewBox: '-50 -50 100 100',
        version: '1.1',
        preserveAspectRatio: 'xMidYMid meet',
        xmlns: 'http://www.w3.org/2000/svg'
      },
      React.createElement(
        'title',
        null,
        name
      ),
      React.createElement(
        'text',
        {
          fontSize: '50px',
          fill: '#fff',
          dominantBaseline: 'central',
          textAnchor: 'middle',
          className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
        },
        firstInitial
      )
    )
  );
};

var sizes = {
  sm: 24,
  md: 40,
  lg: 72
};

var Avatar = function (_React$PureComponent) {
  inherits(Avatar, _React$PureComponent);

  function Avatar() {
    var _ref2;

    var _temp, _this, _ret;

    classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
      isImageLoaded: true
    }, _this.handleImageError = function () {
      return _this.setState({ isImageLoaded: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Avatar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          outline = _props.outline,
          size = _props.size,
          src = _props.src,
          verified = _props.verified;
      var isImageLoaded = this.state.isImageLoaded;

      var width = size ? sizes[size] : '100%';
      var height = size ? sizes[size] : '';
      return React.createElement(
        Box,
        _extends({
          color: 'white'
        }, outline ? {
          dangerouslySetInlineStyle: {
            __style: {
              boxShadow: '0 0 0 2px #fff'
            }
          }
        } : {}, {
          width: width,
          height: height,
          position: 'relative',
          shape: 'circle'
        }),
        src && isImageLoaded ? React.createElement(
          Mask,
          { shape: 'circle', wash: true },
          React.createElement(Image, {
            alt: name,
            color: '#EFEFEF',
            naturalHeight: 1,
            naturalWidth: 1,
            src: src,
            onError: this.handleImageError
          })
        ) : React.createElement(DefaultAvatar, { name: name }),
        verified && React.createElement(
          Box,
          {
            position: 'absolute',
            width: '20%',
            height: '20%',
            minWidth: 8,
            minHeight: 8,
            dangerouslySetInlineStyle: {
              __style: {
                bottom: '4%',
                right: '4%'
              }
            }
          },
          React.createElement(
            Box,
            {
              color: 'white',
              width: '100%',
              height: '100%',
              shape: 'circle',
              dangerouslySetInlineStyle: {
                __style: {
                  boxShadow: '0 0 0 2px #fff'
                }
              }
            },
            React.createElement(Icon, {
              color: 'red',
              icon: 'check-circle',
              accessibilityLabel: '',
              size: '100%'
            })
          )
        )
      );
    }
  }]);
  return Avatar;
}(React.PureComponent);

Avatar.propTypes = {
  name: PropTypes.string.isRequired,
  outline: PropTypes.bool,
  src: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  verified: PropTypes.bool
};

var styles$4 = { "button": "_st _2u", "solid": "_su _5j", "enabled": "_sv _3r _t7", "sm": "_sw _2r", "md": "_sx _2s", "lg": "_sy _2t", "block": "_sz _45 _29", "inline": "_t0 _2b", "disabled": "_t1 _5p", "gray": "_t2 _5p", "red": "_t3 _5l", "blue": "_t4 _61", "transparent": "_t5 _6i", "white": "_t6 _5n" };

var styles$5 = { "Text": "_tf _sc _sd _se", "fontSize1": "_tg", "fontSize2": "_th", "fontSize3": "_ti", "fontSize4": "_tj", "fontSize5": "_tk", "smFontSize1": "_tl", "smFontSize2": "_tm", "smFontSize3": "_tn", "smFontSize4": "_to", "smFontSize5": "_tp", "mdFontSize1": "_tq", "mdFontSize2": "_tr", "mdFontSize3": "_ts", "mdFontSize4": "_tt", "mdFontSize5": "_tu", "lgFontSize1": "_tv", "lgFontSize2": "_tw", "lgFontSize3": "_tx", "lgFontSize4": "_ty", "lgFontSize5": "_tz" };

var SIZE_SCALE = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};

function Text(_ref) {
  var _ref$align = _ref.align,
      align = _ref$align === undefined ? 'left' : _ref$align,
      _ref$bold = _ref.bold,
      bold = _ref$bold === undefined ? false : _ref$bold,
      children = _ref.children,
      _ref$color = _ref.color,
      color = _ref$color === undefined ? 'darkGray' : _ref$color,
      _ref$inline = _ref.inline,
      inline = _ref$inline === undefined ? false : _ref$inline,
      _ref$italic = _ref.italic,
      italic = _ref$italic === undefined ? false : _ref$italic,
      _ref$overflow = _ref.overflow,
      overflow = _ref$overflow === undefined ? 'breakWord' : _ref$overflow,
      _ref$size = _ref.size,
      size = _ref$size === undefined ? 'md' : _ref$size,
      smSize = _ref.smSize,
      mdSize = _ref.mdSize,
      lgSize = _ref.lgSize,
      _ref$leading = _ref.leading,
      leading = _ref$leading === undefined ? 'short' : _ref$leading,
      _ref$truncate = _ref.truncate,
      truncate = _ref$truncate === undefined ? false : _ref$truncate,
      _ref$__dangerouslyInc = _ref.__dangerouslyIncreaseLineHeight,
      __dangerouslyIncreaseLineHeight = _ref$__dangerouslyInc === undefined ? false : _ref$__dangerouslyInc;

  var scale = SIZE_SCALE[size];
  var smScale = SIZE_SCALE[smSize];
  var mdScale = SIZE_SCALE[mdSize];
  var lgScale = SIZE_SCALE[lgSize];

  var cs = classnames(styles$5.Text, styles$5['fontSize' + scale], lgSize && styles$5['lgFontSize' + lgScale], mdSize && styles$5['mdFontSize' + mdScale], smSize && styles$5['smFontSize' + smScale], color === 'blue' && colors.blue, color === 'darkGray' && colors.darkGray, color === 'eggplant' && colors.eggplant, color === 'gray' && colors.gray, color === 'green' && colors.green, color === 'lightGray' && colors.lightGray, color === 'maroon' && colors.maroon, color === 'midnight' && colors.midnight, color === 'navy' && colors.navy, color === 'olive' && colors.olive, color === 'orange' && colors.orange, color === 'orchid' && colors.orchid, color === 'pine' && colors.pine, color === 'purple' && colors.purple, color === 'red' && colors.red, color === 'watermelon' && colors.watermelon, color === 'white' && colors.white, leading === 'short' && typography.leadingShort, (leading === 'tall' || __dangerouslyIncreaseLineHeight) && typography.leadingTall, align === 'center' && typography.alignCenter, align === 'justify' && typography.alignJustify, align === 'left' && typography.alignLeft, align === 'right' && typography.alignRight, overflow === 'breakWord' && typography.breakWord, italic && typography.fontStyleItalic, !italic && typography.fontStyleNormal, bold && typography.fontWeightBold, !bold && typography.fontWeightNormal, truncate && typography.truncate);
  var Tag = inline ? 'span' : 'div';

  return React.createElement(
    Tag,
    _extends({
      className: cs
    }, truncate && typeof children === 'string' ? { title: children } : null),
    children
  );
}

Text.propTypes = {
  __dangerouslyIncreaseLineHeight: PropTypes.bool,
  align: PropTypes.oneOf(['left', 'right', 'center', 'justify']),
  bold: PropTypes.bool,
  children: PropTypes.node,
  color: PropTypes.oneOf(['green', 'pine', 'olive', 'blue', 'navy', 'midnight', 'purple', 'orchid', 'eggplant', 'maroon', 'watermelon', 'orange', 'darkGray', 'gray', 'lightGray', 'red', 'white']),
  inline: PropTypes.bool,
  italic: PropTypes.bool,
  leading: PropTypes.oneOf(['tall', 'short']),
  lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  overflow: PropTypes.oneOf(['normal', 'breakWord']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  truncate: PropTypes.bool
};

function Button(props) {
  var _classnames;

  var accessibilityExpanded = props.accessibilityExpanded,
      accessibilityHaspopup = props.accessibilityHaspopup,
      accessibilityLabel = props.accessibilityLabel,
      _props$color = props.color,
      color = _props$color === undefined ? 'gray' : _props$color,
      _props$disabled = props.disabled,
      disabled = _props$disabled === undefined ? false : _props$disabled,
      _props$inline = props.inline,
      inline = _props$inline === undefined ? false : _props$inline,
      name = props.name,
      onClick = props.onClick,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size,
      text = props.text,
      _props$type = props.type,
      type = _props$type === undefined ? 'button' : _props$type;


  var textColor = {
    blue: 'white',
    gray: 'darkGray',
    red: 'white',
    transparent: 'white',
    white: 'darkGray'
  };

  var classes = classnames(styles$4.button, (_classnames = {}, defineProperty(_classnames, styles$4.sm, size === 'sm'), defineProperty(_classnames, styles$4.md, size === 'md'), defineProperty(_classnames, styles$4.lg, size === 'lg'), defineProperty(_classnames, styles$4.solid, color !== 'transparent'), defineProperty(_classnames, styles$4[color], !disabled), defineProperty(_classnames, styles$4.disabled, disabled), defineProperty(_classnames, styles$4.enabled, !disabled), defineProperty(_classnames, styles$4.inline, inline), defineProperty(_classnames, styles$4.block, !inline), _classnames));

  /* eslint-disable react/button-has-type */
  return React.createElement(
    'button',
    {
      'aria-expanded': accessibilityExpanded,
      'aria-haspopup': accessibilityHaspopup,
      'aria-label': accessibilityLabel,
      className: classes,
      disabled: disabled,
      name: name,
      onClick: function (_onClick) {
        function onClick(_x) {
          return _onClick.apply(this, arguments);
        }

        onClick.toString = function () {
          return _onClick.toString();
        };

        return onClick;
      }(function (event) {
        return onClick && onClick({ event: event });
      }),
      type: type
    },
    React.createElement(
      Text,
      {
        align: 'center',
        bold: true,
        color: disabled ? 'gray' : textColor[color],
        overflow: 'normal',
        size: size
      },
      text
    )
  );
  /* eslint-enable react/button-has-type */
}

Button.propTypes = {
  accessibilityExpanded: PropTypes.bool,
  accessibilityHaspopup: PropTypes.bool,
  accessibilityLabel: PropTypes.string,
  color: PropTypes.oneOf(['blue', 'gray', 'red', 'transparent', 'white']),
  disabled: PropTypes.bool,
  inline: PropTypes.bool,
  name: PropTypes.string,
  onClick: PropTypes.func,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  text: PropTypes.string.isRequired,
  type: PropTypes.oneOf(['button', 'submit'])
};

var styles$6 = { "card": "_u0 _2l _5e _2n _2o _2p _2q _2v", "hover": "_u1", "animateIn": "_u2" };

var Card = function (_React$Component) {
  inherits(Card, _React$Component);

  function Card() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Card);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Card.__proto__ || Object.getPrototypeOf(Card)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      hovered: false
    }, _this.handleMouseEnter = function (event) {
      var onMouseEnter = _this.props.onMouseEnter;

      _this.setState({ hovered: true }, onMouseEnter && function () {
        return onMouseEnter({ event: event });
      });
    }, _this.handleMouseLeave = function (event) {
      var onMouseLeave = _this.props.onMouseLeave;

      _this.setState({ hovered: false }, onMouseLeave && function () {
        return onMouseLeave({ event: event });
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Card, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          active = _props.active,
          children = _props.children,
          image = _props.image;
      var hovered = this.state.hovered;


      var classes = classnames(styles$6.card, defineProperty({}, styles$6.hover, active || active == null && hovered));

      return React.createElement(
        Box,
        {
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          position: 'relative'
        },
        image && React.createElement(
          Box,
          { marginBottom: 1 },
          image
        ),
        React.createElement(
          Box,
          null,
          children
        ),
        React.createElement('div', { className: classes })
      );
    }
  }]);
  return Card;
}(React.Component);

Card.propTypes = {
  active: PropTypes.bool,
  children: PropTypes.node,
  image: PropTypes.node,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func
};

var styles$7 = { "border": "_u3", "borderError": "_u4", "borderDark": "_u5", "check": "_u6 _29 _2u _2w _34 _3e", "checkEnabled": "_u7 _t7", "checkFocused": "_u8 _3s", "checkSm": "_u9", "checkMd": "_ua", "input": "_ub _2l _pb", "inputEnabled": "_uc _t7", "inputSm": "_ud", "inputMd": "_ue" };

var Checkbox = function (_React$Component) {
  inherits(Checkbox, _React$Component);

  function Checkbox() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Checkbox);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({ event: event, checked: checked });
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      return _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Checkbox, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.indeterminate) {
        this.setIndeterminate(!!this.props.indeterminate);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(previousProps) {
      if (previousProps.indeterminate !== this.props.indeterminate) {
        this.setIndeterminate(!!this.props.indeterminate);
      }
    }
  }, {
    key: 'setIndeterminate',
    value: function setIndeterminate(indeterminate) {
      if (this.input) {
        this.input.indeterminate = indeterminate;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _classnames,
          _this2 = this,
          _classnames2;

      var _props = this.props,
          checked = _props.checked,
          disabled = _props.disabled,
          hasError = _props.hasError,
          id = _props.id,
          indeterminate = _props.indeterminate,
          name = _props.name,
          size = _props.size;


      var borderStyle = styles$7.border;
      if (!disabled && (checked || indeterminate)) {
        borderStyle = styles$7.borderDark;
      } else if (hasError) {
        borderStyle = styles$7.borderError;
      }

      return React.createElement(
        Box,
        { position: 'relative' },
        React.createElement('input', {
          checked: checked,
          className: classnames(styles$7.input, (_classnames = {}, defineProperty(_classnames, styles$7.inputEnabled, !disabled), defineProperty(_classnames, styles$7.indeterminate, indeterminate), defineProperty(_classnames, styles$7.inputSm, size === 'sm'), defineProperty(_classnames, styles$7.inputMd, size === 'md'), _classnames)),
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          ref: function ref(el) {
            _this2.input = el;
          },
          type: 'checkbox'
        }),
        React.createElement(
          'div',
          {
            className: classnames(borderStyle, styles$7.check,
            // eslint-disable-next-line no-nested-ternary
            disabled ? checked || indeterminate ? colors.grayBg : colors.lightGrayBg : checked || indeterminate ? colors.darkGrayBg : colors.whiteBg, (_classnames2 = {}, defineProperty(_classnames2, styles$7.checkEnabled, !disabled), defineProperty(_classnames2, styles$7.checkFocused, this.state.focused), defineProperty(_classnames2, styles$7.checkMd, size === 'md'), defineProperty(_classnames2, styles$7.checkSm, size === 'sm'), _classnames2))
          },
          (checked || indeterminate) && React.createElement(Icon, {
            accessibilityLabel: '',
            color: 'white',
            icon: indeterminate ? 'dash' : 'check',
            size: size === 'sm' ? 8 : 12
          })
        )
      );
    }
  }]);
  return Checkbox;
}(React.Component);

Checkbox.propTypes = {
  checked: PropTypes.bool,
  disabled: PropTypes.bool,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  indeterminate: PropTypes.bool,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  size: PropTypes.oneOf(['sm', 'md'])
};
Checkbox.defaultProps = {
  checked: false,
  disabled: false,
  hasError: false,
  indeterminate: false,
  size: 'md'
};

var Collection = function (_React$PureComponent) {
  inherits(Collection, _React$PureComponent);

  function Collection() {
    classCallCheck(this, Collection);
    return possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).apply(this, arguments));
  }

  createClass(Collection, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Item = _props.Item,
          layout$$1 = _props.layout,
          _props$viewportTop = _props.viewportTop,
          viewportTop = _props$viewportTop === undefined ? 0 : _props$viewportTop,
          _props$viewportLeft = _props.viewportLeft,
          viewportLeft = _props$viewportLeft === undefined ? 0 : _props$viewportLeft;

      // Calculate the full dimensions of the item layer

      var width = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
        return item.left + item.width;
      })));
      var height = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
        return item.top + item.height;
      })));

      // Default the viewport to being the full width of the content layer
      var _props2 = this.props,
          _props2$viewportWidth = _props2.viewportWidth,
          viewportWidth = _props2$viewportWidth === undefined ? width : _props2$viewportWidth,
          _props2$viewportHeigh = _props2.viewportHeight,
          viewportHeight = _props2$viewportHeigh === undefined ? height : _props2$viewportHeigh;

      // Calculates which items from the item layer to render in the viewport
      // layer.

      var items = layout$$1.reduce(function (acc, position, idx) {
        if (position.top + position.height > viewportTop && position.top < viewportHeight + viewportTop && position.left < viewportWidth + viewportLeft && position.left + position.width > viewportLeft) {
          acc.push(_extends({ idx: idx }, position));
        }
        return acc;
      }, []);

      return React.createElement(
        'div',
        { className: layout.relative, style: { width: width, height: height } },
        items.map(function (_ref) {
          var idx = _ref.idx,
              style = objectWithoutProperties(_ref, ['idx']);
          return React.createElement(
            'div',
            { key: idx, className: layout.absolute, style: style },
            React.createElement(Item, { idx: idx })
          );
        })
      );
    }
  }]);
  return Collection;
}(React.PureComponent);

Collection.propTypes = {
  // eslint-disable-next-line react/forbid-prop-types
  Item: PropTypes.any,
  layout: PropTypes.arrayOf(PropTypes.exact({
    top: PropTypes.number.isRequired,
    left: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired
  }).isRequired),
  viewportHeight: PropTypes.number,
  viewportLeft: PropTypes.number,
  viewportTop: PropTypes.number,
  viewportWidth: PropTypes.number
};
Collection.defaultProps = {
  layout: [],
  viewportLeft: 0,
  viewportTop: 0
};

/*

This function just implements the design constraints for asymetrical columns in
a very simple way. It's not perfect, but it's very predictible. If you do
anything, improve it so that it takes these constraints and generates them
for n > 4.

1 + n columns:
  first column is 50/50
  can't have 3 columns in a row be 50/50

*/
var UP = [0.75, 0.25];
var DOWN = [0.25, 0.75];
var MID = [0.5, 0.5];
var columnLayout = function columnLayout(numOfColumns) {
  switch (numOfColumns) {
    case 1:
      return [[MID], [UP], [DOWN]];
    case 2:
      return [[UP, MID], [DOWN, MID], [MID, UP], [MID, DOWN]];
    case 4:
      return [[MID, UP, MID, MID], [MID, DOWN, MID, MID], [MID, MID, UP, MID], [MID, MID, DOWN, MID], [MID, UP, MID, DOWN], [MID, DOWN, MID, UP]];
    case 3:
    default:
      return [[MID, UP, MID], [MID, DOWN, MID], [MID, MID, UP], [MID, MID, DOWN]];
  }
};

var paddingAll = function paddingAll(gutter, positions) {
  return positions.map(function (_ref) {
    var top = _ref.top,
        left = _ref.left,
        width = _ref.width,
        height = _ref.height;
    return {
      top: top,
      left: left,
      width: width - gutter,
      height: height - gutter
    };
  });
};

var mindex = function mindex(arr) {
  return arr.reduce(function (minIndex, item, i) {
    return item < arr[minIndex] ? i : minIndex;
  }, 0);
};

var columnsForCollageWithCover = function columnsForCollageWithCover(numOfColumns) {
  return numOfColumns === 4 ? 2 : 1;
};

function getCollageLayout(_ref2) {
  var gutter = _ref2.gutter,
      cover = _ref2.cover,
      numCols = _ref2.columns,
      h = _ref2.height,
      w = _ref2.width,
      layoutKey = _ref2.layoutKey;

  var positions = [];
  var width = w + gutter;
  var height = h + gutter;

  // If there's a cover image, we'll add that later. It should be a little
  // less than half the width of the collage. We do this now (and not later
  // when we add the cover image) because of `columnLayout`'s constraints
  // needing the exact number of columns that are displayed.
  var gridCols = cover ? columnsForCollageWithCover(numCols) : numCols;

  // Selects the layout that we're going to use for the grid
  var columns = columnLayout(gridCols);
  var layoutIdx = layoutKey % columns.length;
  var layout = columns[layoutIdx];

  // This does a really simple version of our masonry layout. Why replicate
  // that here? a.) fewer dependencies and b.) we need the algorithm to
  // roughly preserve the order of the collages from when they were ordered
  // by Masonry.
  var colHeights = new Array(gridCols).fill(0);
  var colCounts = new Array(gridCols).fill(0);

  // We iterate over every position that we think we could _potentially_ have
  // so that we can fill them with empty sections if need be.
  for (var i = 0; i < 2 * gridCols; i += 1) {
    var col = mindex(colHeights);
    var colIdx = colCounts[col];
    var itemHeight = layout[col][colIdx] * height;

    positions.push({
      top: colHeights[col],
      left: col * (width / numCols),
      width: width / numCols,
      height: itemHeight
    });

    colHeights[col] += itemHeight;
    colCounts[col] += 1;
  }

  // If we have a cover image, figure out how big it is, then move all the
  // existing columns over.
  if (cover) {
    var coverImageWidth = Math.ceil(numCols / 2) * (width / numCols);
    positions = positions.map(function (position) {
      return _extends({}, position, {
        left: coverImageWidth + position.left
      });
    });
    positions.unshift({ top: 0, left: 0, width: coverImageWidth, height: height });
  }

  // This adds the space between any items that we have. It's nice to do
  // this as a separate pass after everything else, because the math earlier
  // becomes easier and it's less brittle to change.
  if (gutter) {
    positions = paddingAll(gutter, positions);
  }

  return positions;
}

function Collage(props) {
  var columns = props.columns,
      cover = props.cover,
      gutter = props.gutter,
      height = props.height,
      layoutKey = props.layoutKey,
      renderImage = props.renderImage,
      width = props.width;

  var positions = getCollageLayout({
    columns: columns,
    cover: !!cover,
    width: width,
    height: height,
    gutter: gutter || 0,
    layoutKey: layoutKey || 0
  });
  return React.createElement(Collection, {
    Item: function Item(_ref3) {
      var index = _ref3.idx;
      return renderImage({
        index: index,
        width: positions[index].width,
        height: positions[index].height
      });
    },
    layout: positions
  });
}

Collage.propTypes = {
  columns: PropTypes.oneOf([2, 3, 4]).isRequired,
  cover: PropTypes.bool,
  gutter: PropTypes.number,
  height: PropTypes.number.isRequired,
  layoutKey: PropTypes.number,
  renderImage: PropTypes.func.isRequired,
  width: PropTypes.number.isRequired
};

var styles$8 = { "deprecatedColumn": "_uf", "xsCol0": "_ug", "xsCol1": "_uh _3u", "xsCol2": "_ui _3v", "xsCol3": "_uj _3w", "xsCol4": "_uk _3x", "xsCol5": "_ul _3y", "xsCol6": "_um _3z", "xsCol7": "_un _40", "xsCol8": "_uo _41", "xsCol9": "_up _42", "xsCol10": "_uq _43", "xsCol11": "_ur _44", "xsCol12": "_us _45", "smCol0": "_ut", "smCol1": "_uu _46", "smCol2": "_uv _47", "smCol3": "_uw _48", "smCol4": "_ux _49", "smCol5": "_uy _4a", "smCol6": "_uz _4b", "smCol7": "_v0 _4c", "smCol8": "_v1 _4d", "smCol9": "_v2 _4e", "smCol10": "_v3 _4f", "smCol11": "_v4 _4g", "smCol12": "_v5 _4h", "mdCol0": "_v6", "mdCol1": "_v7 _4i", "mdCol2": "_v8 _4j", "mdCol3": "_v9 _4k", "mdCol4": "_va _4l", "mdCol5": "_vb _4m", "mdCol6": "_vc _4n", "mdCol7": "_vd _4o", "mdCol8": "_ve _4p", "mdCol9": "_vf _4q", "mdCol10": "_vg _4r", "mdCol11": "_vh _4s", "mdCol12": "_vi _4t", "lgCol0": "_vj", "lgCol1": "_vk _4u", "lgCol2": "_vl _4v", "lgCol3": "_vm _4w", "lgCol4": "_vn _4x", "lgCol5": "_vo _4y", "lgCol6": "_vp _4z", "lgCol7": "_vq _50", "lgCol8": "_vr _51", "lgCol9": "_vs _52", "lgCol10": "_vt _53", "lgCol11": "_vu _54", "lgCol12": "_vv _55" };

function Column(props) {
  var children = props.children;

  var cs = classnames((props.xs !== undefined || props.sm !== undefined || props.md !== undefined || props.lg !== undefined) && styles$8.deprecatedColumn, props.xs && styles$8['xsCol' + props.xs], props.sm && styles$8['smCol' + props.sm], props.md && styles$8['mdCol' + props.md], props.lg && styles$8['lgCol' + props.lg], props.span != null && styles$8['xsCol' + props.span], props.smSpan != null && styles$8['smCol' + props.smSpan], props.mdSpan != null && styles$8['mdCol' + props.mdSpan], props.lgSpan != null && styles$8['lgCol' + props.lgSpan]);
  return React.createElement(
    'div',
    { className: cs },
    children
  );
}

Column.propTypes = {
  children: PropTypes.node,
  xs: PropTypes.number,
  sm: PropTypes.number,
  md: PropTypes.number,
  lg: PropTypes.number,
  span: PropTypes.number,
  smSpan: PropTypes.number,
  mdSpan: PropTypes.number,
  lgSpan: PropTypes.number
};

function Container(props) {
  var children = props.children;

  return React.createElement(
    Box,
    { justifyContent: 'center', display: 'flex' },
    React.createElement(
      Box,
      { maxWidth: 800, width: '100%' },
      children
    )
  );
}

Container.propTypes = {
  children: PropTypes.node
};

var styles$9 = { "divider": "_vw _29 _57 _pb" };

function Divider() {
  return React.createElement('hr', { className: styles$9.divider });
}

function Caret(props) {
  var direction = props.direction;

  var path = void 0;
  switch (direction) {
    case 'up':
      path = 'M0 0 L12 12 L24 0';
      break;
    case 'right':
      path = 'M24 0 L12 12 L24 24';
      break;
    case 'down':
      path = 'M0 24 L12 12 L24 24';
      break;
    case 'left':
      path = 'M0 0 L12 12 L0 24';
      break;
    default:
  }

  return React.createElement(
    'svg',
    { width: '24', height: '24' },
    React.createElement('path', { d: path })
  );
}

Caret.propTypes = {
  direction: PropTypes.oneOf(['up', 'right', 'down', 'left'])
};

var styles$10 = { "container": "_vx _2l", "contents": "_vy _2l _29 _2u _5e", "dimensions": "_vz", "innerContents": "_w0 _2w _2h _5e", "caret": "_w1 _2l" };

/* Needed until this Flow issue is fixed: https://github.com/facebook/flow/issues/380 */
/* eslint quote-props: 0 */
var SPACES_INDEX_MAP = {
  '0': 'up',
  '1': 'right',
  '2': 'down',
  '3': 'left'
};

var DIR_INDEX_MAP = {
  up: 0,
  right: 1,
  down: 2,
  left: 3
};

var MARGIN = 24;
var CARET_HEIGHT = 24;
var CARET_OFFSET_FROM_SIDE = 24;
var BORDER_RADIUS = 8;

/**
 * Determines the main direction the flyout opens
 */
function getMainDir(flyoutSize, idealDirection, triggerRect, windowSize) {
  // Calculates the available space if we were to place the flyout in the 4 main directions
  // to determine which 'quadrant' to position the flyout inside of
  var up = triggerRect.top - flyoutSize.height - CARET_HEIGHT;
  var right = windowSize.width - flyoutSize.width - CARET_HEIGHT - triggerRect.right;
  var down = windowSize.height - flyoutSize.height - CARET_HEIGHT - triggerRect.bottom;
  var left = triggerRect.left - flyoutSize.width - CARET_HEIGHT;

  // overrides available space when the trigger is close to the edge of the screen
  // trigger is too close to top/bottom of screen for left & right flyouts
  if (triggerRect.top < BORDER_RADIUS || windowSize.height - triggerRect.bottom < BORDER_RADIUS) {
    left = 0;
    right = 0;
  }

  // trigger is too close to the left/right of screen for up & down flyouts
  if (triggerRect.left < BORDER_RADIUS || windowSize.width - triggerRect.right < BORDER_RADIUS) {
    up = 0;
    down = 0;
  }

  var spaces = [up, right, down, left];

  // Identify best direction of available spaces
  var max = Math.max.apply(Math, spaces);

  // Chose the main direction for the flyout based on available spaces & user preference
  var mainDir = void 0;
  if (idealDirection && spaces[DIR_INDEX_MAP[idealDirection]] > 0) {
    // user pref
    mainDir = idealDirection;
  } else {
    // If no direction pref, chose the direction in which there is the most space available
    mainDir = SPACES_INDEX_MAP[spaces.indexOf(max)];
  }
  return mainDir;
}

/**
 * Determines the sub direction of how the flyout is positioned within the main dir
 */
function getSubDir(flyoutSize, mainDir, triggerRect, windowSize) {
  // Now that we have the main direction, chose from 3 caret placements for that direction
  var offset = void 0;
  var triggerMid = void 0;
  var windowSpaceAvailable = void 0;

  if (mainDir === 'right' || mainDir === 'left') {
    offset = flyoutSize.height / 2;
    triggerMid = triggerRect.top + (triggerRect.bottom - triggerRect.top) / 2;
    windowSpaceAvailable = windowSize.height;
  } else {
    // (mainDir === 'up' || mainDir === 'down')
    offset = flyoutSize.width / 2;
    triggerMid = triggerRect.left + (triggerRect.right - triggerRect.left) / 2;
    windowSpaceAvailable = windowSize.width;
  }

  var aboveOrLeft = triggerMid - offset - MARGIN;
  var belowOrRight = windowSpaceAvailable - triggerMid - offset - MARGIN;
  var subDir = void 0;
  if (aboveOrLeft > 0 && belowOrRight > 0) {
    // caret should go in middle b/c it can
    subDir = 'middle';
  } else if (belowOrRight > 0) {
    // caret should go at top for left/right and left for up/down
    subDir = mainDir === 'left' || mainDir === 'right' ? 'up' : 'left';
  } else {
    // caret should go at bottom for left/right and right for up/down
    subDir = mainDir === 'left' || mainDir === 'right' ? 'down' : 'right';
  }
  return subDir;
}

/**
 * Calculates the amount the flyout & caret need to shift over to align with designs
 */
function calcEdgeShifts(subDir, triggerRect, windowSize) {
  // Target values for flyout and caret shifts
  var flyoutVerticalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.height - CARET_HEIGHT) / 2;
  var flyoutHorizontalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.width - CARET_HEIGHT) / 2;
  var caretVerticalShift = CARET_HEIGHT;
  var caretHorizontalShift = CARET_HEIGHT;

  // Covers edge case where trigger is in a corner and we need to adjust the offset of the caret
  // to something smaller than normal in order
  var isCloseVertically = triggerRect.top - flyoutVerticalShift < 0 || triggerRect.bottom + flyoutVerticalShift > windowSize.height;
  var isCloseHorizontally = triggerRect.left - flyoutHorizontalShift < 0 || triggerRect.right + flyoutHorizontalShift > windowSize.width;
  if (isCloseVertically) {
    flyoutVerticalShift = BORDER_RADIUS - (triggerRect.height - CARET_HEIGHT) / 2;
    caretVerticalShift = BORDER_RADIUS;
  }
  if (isCloseHorizontally) {
    flyoutHorizontalShift = BORDER_RADIUS - (triggerRect.width - CARET_HEIGHT) / 2;
    caretHorizontalShift = BORDER_RADIUS;
  }

  return {
    flyout: {
      x: flyoutHorizontalShift,
      y: flyoutVerticalShift
    },
    caret: {
      x: caretHorizontalShift,
      y: caretVerticalShift
    }
  };
}

/**
 * Calculates flyout and caret offsets for styling
 */
function adjustOffsets(base, edgeShift, flyoutSize, mainDir, subDir, triggerRect) {
  var flyoutLeft = base.left;
  var flyoutTop = base.top;

  var caretTop = mainDir === 'down' ? -CARET_HEIGHT : null;
  var caretRight = mainDir === 'left' ? -CARET_HEIGHT : null;
  var caretBottom = null;
  var caretLeft = mainDir === 'right' ? -CARET_HEIGHT : null;

  if (subDir === 'up') {
    flyoutTop = base.top - edgeShift.flyout.y;
    caretTop = edgeShift.caret.y;
  } else if (subDir === 'down') {
    flyoutTop = base.top - flyoutSize.height + triggerRect.height + edgeShift.flyout.y;
    caretBottom = edgeShift.caret.y;
  } else if (subDir === 'left') {
    flyoutLeft = base.left - edgeShift.flyout.x;
    caretLeft = edgeShift.caret.x;
  } else if (subDir === 'right') {
    flyoutLeft = base.left - flyoutSize.width + triggerRect.width + edgeShift.flyout.x;
    caretRight = edgeShift.caret.x;
  } else if (subDir === 'middle') {
    if (mainDir === 'left' || mainDir === 'right') {
      var triggerMid = flyoutTop + triggerRect.height / 2;
      flyoutTop = triggerMid - flyoutSize.height / 2;
      caretTop = (flyoutSize.height - CARET_HEIGHT) / 2;
    }
    if (mainDir === 'up' || mainDir === 'down') {
      var _triggerMid = flyoutLeft + triggerRect.width / 2;
      flyoutLeft = _triggerMid - flyoutSize.width / 2;
      caretLeft = (flyoutSize.width - CARET_HEIGHT) / 2;
    }
  }

  return {
    flyoutOffset: {
      top: flyoutTop,
      left: flyoutLeft
    },
    caretOffset: {
      top: caretTop,
      right: caretRight,
      bottom: caretBottom,
      left: caretLeft
    }
  };
}

/* Calculates baseline top and left offset for flyout */
function baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize) {
  var HALF_CARET = CARET_HEIGHT / 2;
  // TOP OFFSET
  var top = void 0;
  if (mainDir === 'down') {
    top = windowSize.scrollY + triggerRect.bottom + HALF_CARET;
  } else if (mainDir === 'up') {
    top = windowSize.scrollY + (triggerRect.top - flyoutSize.height - HALF_CARET);
  } else {
    // left and right
    top = windowSize.scrollY + triggerRect.top;
  }

  // LEFT OFFSET
  var left = void 0;
  if (mainDir === 'left') {
    left = windowSize.scrollX + (triggerRect.left - flyoutSize.width - HALF_CARET);
  } else if (mainDir === 'right') {
    left = windowSize.scrollX + triggerRect.right + HALF_CARET;
  } else {
    // down and up
    left = windowSize.scrollX + triggerRect.left;
  }

  // Adjusts for the relative parent container
  top -= relativeOffset.y;
  left -= relativeOffset.x;
  return { top: top, left: left };
}

var Contents = function (_React$Component) {
  inherits(Contents, _React$Component);

  function Contents() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Contents);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Contents.__proto__ || Object.getPrototypeOf(Contents)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      flyoutOffset: {
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      },
      caretOffset: {
        top: undefined,
        right: undefined,
        bottom: undefined,
        left: undefined
      },
      mainDir: null
    }, _this.setFlyoutPosition = function (props) {
      var relativeOffset = props.relativeOffset,
          idealDirection = props.idealDirection,
          positionRelativeToAnchor = props.positionRelativeToAnchor,
          triggerRect = props.triggerRect,
          width = props.width;

      // Scroll not needed for relative elements
      // We can't use window.scrollX / window.scrollY since it's not supported by IE11

      var scrollX = positionRelativeToAnchor ? 0 : window.pageXOffset || document.documentElement && document.documentElement.scrollLeft || 0;
      var scrollY = positionRelativeToAnchor ? 0 : window.pageYOffset || document.documentElement && document.documentElement.scrollTop || 0;

      var windowSize = {
        height: window.innerHeight,
        width: window.innerWidth,
        scrollX: scrollX,
        scrollY: scrollY
      };

      var flyoutSize = {
        height: _this.flyout ? _this.flyout.clientHeight : 0,
        width: width
      };

      // First choose one of 4 main direction
      var mainDir = getMainDir(flyoutSize, idealDirection, triggerRect, windowSize);

      // Now that we have the main direction, chose from 3 caret placements for that direction
      var subDir = getSubDir(flyoutSize, mainDir, triggerRect, windowSize);

      // Gets the base offset that positions the flyout based on the main direction only
      var base = baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize);

      // Gets the edge shifts for the flyout
      var edgeShifts = calcEdgeShifts(subDir, triggerRect, windowSize);

      // Adjusts for the subdirection of the caret

      var _adjustOffsets = adjustOffsets(base, edgeShifts, flyoutSize, mainDir, subDir, triggerRect),
          flyoutOffset = _adjustOffsets.flyoutOffset,
          caretOffset = _adjustOffsets.caretOffset;

      _this.setState({
        caretOffset: caretOffset,
        flyoutOffset: flyoutOffset,
        mainDir: mainDir
      });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Contents, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.setFlyoutPosition(this.props);
      setTimeout(function () {
        if (_this2.props.shouldFocus && _this2.flyout) {
          _this2.flyout.focus();
        }
      });
      window.addEventListener('resize', this.props.onResize);
      window.addEventListener('keydown', this.props.onKeyDown);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setFlyoutPosition(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.props.onResize);
      window.removeEventListener('keydown', this.props.onKeyDown);
    }

    /**
     * Determines the main direciton, sub direction, and corresponding offsets needed
     * to correctly position the offset
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          bgColor = _props.bgColor,
          children = _props.children,
          width = _props.width;

      // Needed to prevent UI thrashing

      var visibility = this.state.mainDir === null ? 'hidden' : 'visible';
      var background = bgColor + 'Bg';
      var stroke = bgColor === 'white' ? '#efefef' : null;
      var borderColor = bgColor === 'white' ? 'lightGray' : bgColor;

      return React.createElement(
        'div',
        {
          className: styles$10.container,
          style: _extends({ stroke: stroke, visibility: visibility }, this.state.flyoutOffset)
        },
        React.createElement(
          'div',
          {
            className: classnames(colors[background], colors[borderColor], styles$10.dimensions, styles$10.contents),
            ref: function ref(c) {
              _this3.flyout = c;
            },
            tabIndex: -1
          },
          React.createElement(
            'div',
            {
              className: classnames(styles$10.dimensions, styles$10.innerContents),
              style: { width: width }
            },
            children
          ),
          React.createElement(
            'div',
            {
              className: classnames(colors[bgColor], styles$10.caret),
              style: _extends({}, this.state.caretOffset)
            },
            React.createElement(Caret, { direction: this.state.mainDir })
          )
        )
      );
    }
  }]);
  return Contents;
}(React.Component);
Contents.propTypes = {
  bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onKeyDown: PropTypes.func.isRequired,
  onResize: PropTypes.func.isRequired,
  relativeOffset: PropTypes.exact({ x: PropTypes.number, y: PropTypes.number }),
  positionRelativeToAnchor: PropTypes.bool,
  shouldFocus: PropTypes.bool,
  triggerRect: PropTypes.exact({
    bottom: PropTypes.number,
    height: PropTypes.number,
    left: PropTypes.number,
    right: PropTypes.number,
    top: PropTypes.number,
    width: PropTypes.number
  }),
  width: PropTypes.number
};

var OutsideEventBehavior = function (_React$Component) {
  inherits(OutsideEventBehavior, _React$Component);

  function OutsideEventBehavior() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, OutsideEventBehavior);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = OutsideEventBehavior.__proto__ || Object.getPrototypeOf(OutsideEventBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickEvent = function (event) {
      // eslint-disable-next-line react/no-find-dom-node
      var el = reactDom.findDOMNode(_this);
      if (!_this.props.onClick || !el || event.target instanceof Node && el.contains(event.target)) {
        return;
      }
      _this.props.onClick(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(OutsideEventBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('click', this.handleClickEvent, {
        capture: true
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('click', this.handleClickEvent, {
        capture: true
      });
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return OutsideEventBehavior;
}(React.Component);

var SIZE_WIDTH_MAP = {
  xs: 185,
  sm: 230,
  md: 284,
  lg: 320,
  xl: 375
};

var ESCAPE_KEY_CODE = 27;

var Controller = function (_React$Component) {
  inherits(Controller, _React$Component);

  function Controller() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Controller);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Controller.__proto__ || Object.getPrototypeOf(Controller)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      relativeOffset: {
        x: 0,
        y: 0
      },
      triggerBoundingRect: {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      }
    }, _this.handleKeyDown = function (event) {
      if (event.keyCode === ESCAPE_KEY_CODE) {
        _this.props.onDismiss();
      }
    }, _this.handlePageClick = function (event) {
      if (event.target instanceof Node && _this.props.anchor && !_this.props.anchor.contains(event.target)) {
        _this.props.onDismiss();
      }
    }, _this.handleResize = function () {
      _this.updateTriggerRect(_this.props);
    }, _this.updateTriggerRect = function (props) {
      var anchor = props.anchor,
          positionRelativeToAnchor = props.positionRelativeToAnchor;

      var triggerBoundingRect = void 0;
      var relativeOffset = void 0;
      if (anchor) {
        triggerBoundingRect = anchor.getBoundingClientRect();

        // Needed for correct positioning within Contents.js
        relativeOffset = {
          x: positionRelativeToAnchor ? triggerBoundingRect.left - anchor.offsetLeft : 0,
          y: positionRelativeToAnchor ? triggerBoundingRect.top - anchor.offsetTop : 0
        };
      }

      _this.setState({ relativeOffset: relativeOffset, triggerBoundingRect: triggerBoundingRect });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Controller, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateTriggerRect(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.updateTriggerRect(nextProps);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          anchor = _props.anchor,
          bgColor = _props.bgColor,
          children = _props.children,
          idealDirection = _props.idealDirection,
          positionRelativeToAnchor = _props.positionRelativeToAnchor,
          shouldFocus = _props.shouldFocus;

      if (!anchor) {
        return null;
      }
      var size = this.props.size ? this.props.size : 'sm';
      var width = typeof size === 'string' ? SIZE_WIDTH_MAP[size] : size;
      return React.createElement(
        OutsideEventBehavior,
        { onClick: this.handlePageClick },
        React.createElement(
          Contents,
          {
            bgColor: bgColor,
            idealDirection: idealDirection,
            onKeyDown: this.handleKeyDown,
            onResize: this.handleResize,
            positionRelativeToAnchor: positionRelativeToAnchor,
            relativeOffset: this.state.relativeOffset,
            shouldFocus: shouldFocus,
            triggerRect: this.state.triggerBoundingRect,
            width: width
          },
          children
        )
      );
    }
  }]);
  return Controller;
}(React.Component);


Controller.propTypes = {
  anchor: PropTypes.shape({
    contains: PropTypes.func,
    getBoundingClientRect: PropTypes.func
  }),
  bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onDismiss: PropTypes.func.isRequired,
  positionRelativeToAnchor: PropTypes.bool,
  shouldFocus: PropTypes.bool,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
  )
};

function Flyout(props) {
  var anchor = props.anchor,
      children = props.children,
      idealDirection = props.idealDirection,
      onDismiss = props.onDismiss,
      _props$positionRelati = props.positionRelativeToAnchor,
      positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
      _props$color = props.color,
      color = _props$color === undefined ? 'white' : _props$color,
      size = props.size;


  if (!anchor) {
    return null;
  }

  return React.createElement(
    Controller,
    {
      anchor: anchor,
      bgColor: color,
      idealDirection: idealDirection,
      onDismiss: onDismiss,
      positionRelativeToAnchor: positionRelativeToAnchor,
      shouldFocus: color !== 'orange',
      size: size
    },
    children
  );
}

Flyout.propTypes = {
  anchor: PropTypes.shape({
    contains: PropTypes.func,
    getBoundingClientRect: PropTypes.func
  }),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onDismiss: PropTypes.func.isRequired,
  positionRelativeToAnchor: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'orange', 'white']),
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
  )
};

var styles$11 = { "wash": "_w2 _2l _2n _2q _2o _2p" };

function zip(a, b) {
  return a.map(function (item, idx) {
    return [item, b[idx]];
  });
}

var BORDER_WIDTH = 2;

var AVATAR_SIZES = {
  sm: 24,
  md: 40,
  lg: 72
};

var avatarLayout = function avatarLayout(n, size) {
  switch (n) {
    case 0:
    case 1:
      return [{ top: 0, left: 0, width: size, height: size, textLayout: 'center' }];
    case 2:
      return [{
        top: 0,
        left: 0,
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }, {
        top: 0,
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }];
    default:
      return [{
        top: 0,
        left: 0,
        width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        height: size,
        textLayout: 'center'
      }, {
        top: 0,
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50%)',
        height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        textLayout: 'topLeft'
      }, {
        top: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
        width: 'calc(50%)',
        height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
        textLayout: 'bottomLeft'
      }];
  }
};

var degToRad = function degToRad(deg) {
  return deg * (Math.PI / 180);
};

var DefaultAvatar$1 = function DefaultAvatar(props) {
  var size = props.size,
      name = props.name,
      textLayout = props.textLayout;


  var quarterPadding = 'calc(' + Math.sin(degToRad(45)) + ' * (' + size + ') / 2)';

  var initial = React.createElement(
    'svg',
    {
      width: '100%',
      viewBox: '-50 -50 100 100',
      version: '1.1',
      preserveAspectRatio: 'xMidYMid meet',
      xmlns: 'http://www.w3.org/2000/svg'
    },
    React.createElement(
      'title',
      null,
      name
    ),
    React.createElement(
      'text',
      {
        fontSize: '50px',
        fill: '#fff',
        dominantBaseline: 'central',
        textAnchor: 'middle',
        className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
      },
      name ? [].concat(toConsumableArray(name))[0].toUpperCase() : ''
    )
  );
  switch (textLayout) {
    case 'bottomLeft':
      return React.createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'end',
          dangerouslySetInlineStyle: {
            __style: {
              paddingBottom: quarterPadding,
              paddingRight: quarterPadding
            }
          }
        },
        initial
      );
    case 'topLeft':
      return React.createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'start',
          dangerouslySetInlineStyle: {
            __style: {
              paddingTop: quarterPadding,
              paddingRight: quarterPadding
            }
          }
        },
        initial
      );
    default:
      return React.createElement(
        Box,
        {
          'aria-label': name,
          color: 'gray',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        },
        initial
      );
  }
};

function GroupAvatar(props) {
  var collaborators = props.collaborators,
      outline = props.outline,
      size = props.size;

  var avatarWidth = size ? AVATAR_SIZES[size] : '100%';
  var avatarHeight = size ? AVATAR_SIZES[size] : '';
  var positions = avatarLayout(collaborators.length, avatarWidth);
  return React.createElement(
    Box,
    {
      color: 'white',
      overflow: 'hidden',
      shape: 'circle',
      width: avatarWidth,
      height: avatarHeight,
      position: 'relative',
      dangerouslySetInlineStyle: {
        __style: _extends({}, outline ? { boxShadow: '0 0 0 2px #fff' } : {}, {
          // willChange: transform fixes a strange behavior where the border of the children
          // are not properly trimmed even though overflow: hidden is set
          willChange: 'transform'
        })
      }
    },
    React.createElement(Box, { dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } } }),
    zip(positions, collaborators).map(function (_ref, idx) {
      var _ref2 = slicedToArray(_ref, 2),
          position = _ref2[0],
          _ref2$ = _ref2[1],
          collaborator = _ref2$ === undefined ? { name: '', src: undefined } : _ref2$;

      var width = position.width,
          height = position.height,
          top = position.top,
          left = position.left,
          textLayout = position.textLayout;
      var name = collaborator.name,
          src = collaborator.src;

      return React.createElement(
        Box,
        {
          key: idx,
          position: 'absolute',
          width: width,
          height: height,
          dangerouslySetInlineStyle: { __style: { top: top, left: left } }
        },
        src ? React.createElement(Image, {
          alt: name,
          color: '#EFEFEF',
          src: src,
          naturalWidth: 1,
          naturalHeight: 1,
          fit: 'cover'
        }) : React.createElement(DefaultAvatar$1, {
          name: name,
          textLayout: textLayout,
          size: height
        }),
        React.createElement('div', { className: styles$11.wash })
      );
    })
  );
}

GroupAvatar.propTypes = {
  collaborators: PropTypes.arrayOf(PropTypes.exact({
    name: PropTypes.string.isRequired,
    src: PropTypes.string
  })).isRequired,
  outline: PropTypes.bool,
  size: PropTypes.oneOf(['sm', 'md', 'lg'])
};

var styles$12 = { "Heading": "_w3 _sc _sd _se _sf", "fontSize1": "_w4", "fontSize2": "_w5", "fontSize3": "_w6", "fontSize4": "_w7", "fontSize5": "_w8", "smFontSize1": "_w9", "smFontSize2": "_wa", "smFontSize3": "_wb", "smFontSize4": "_wc", "smFontSize5": "_wd", "mdFontSize1": "_we", "mdFontSize2": "_wf", "mdFontSize3": "_wg", "mdFontSize4": "_wh", "mdFontSize5": "_wi", "lgFontSize1": "_wj", "lgFontSize2": "_wk", "lgFontSize3": "_wl", "lgFontSize4": "_wm", "lgFontSize5": "_wn" };

var defaultHeadingLevels = {
  xs: 5,
  sm: 4,
  md: 3,
  lg: 2,
  xl: 1
};

var SIZE_SCALE$1 = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};

function Heading(props) {
  var accessibilityLevel = props.accessibilityLevel,
      children = props.children,
      _props$color = props.color,
      color = _props$color === undefined ? 'darkGray' : _props$color,
      _props$id = props.id,
      id = _props$id === undefined ? null : _props$id,
      lgSize = props.lgSize,
      mdSize = props.mdSize,
      _props$overflow = props.overflow,
      overflow = _props$overflow === undefined ? 'breakWord' : _props$overflow,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size,
      smSize = props.smSize,
      _props$truncate = props.truncate,
      truncate = _props$truncate === undefined ? false : _props$truncate;


  var cs = classnames(styles$12.Heading, styles$12['fontSize' + SIZE_SCALE$1[size]], smSize && styles$12['smFontSize' + SIZE_SCALE$1[smSize]], mdSize && styles$12['mdFontSize' + SIZE_SCALE$1[mdSize]], lgSize && styles$12['lgFontSize' + SIZE_SCALE$1[lgSize]], colors[color], overflow === 'breakWord' && typography.breakWord, truncate && typography.truncate);

  var headingLevel = accessibilityLevel || defaultHeadingLevels[size];
  return React.createElement('h' + headingLevel, _extends({
    className: cs,
    id: id
  }, truncate && typeof children === 'string' ? { title: children } : null), children);
}

Heading.propTypes = {
  accessibilityLevel: PropTypes.oneOf([1, 2, 3, 4, 5, 6]),
  children: PropTypes.node,
  color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
  id: PropTypes.string,
  overflow: PropTypes.oneOf(['normal', 'breakWord']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  truncate: PropTypes.bool
};

var styles$13 = { "button": "_wo _29 _5j _pg _t7" };

var styles$14 = { "pog": "_wp _5c _2w _34 _3e", "focused": "_wq _3s", "transparent": "_wr _6i", "hovered": "_ws", "white": "_wt _5n", "active": "_wu", "lightGray": "_wv _5p" };

var SIZE_NAME_TO_PIXEL = {
  xs: 24,
  sm: 32,
  md: 40,
  lg: 48,
  xl: 56
};

var defaultIconButtonIconColors = {
  transparent: 'gray',
  lightGray: 'gray',
  white: 'gray'
};

function Pog(props) {
  var _classnames;

  var _props$active = props.active,
      active = _props$active === undefined ? false : _props$active,
      _props$bgColor = props.bgColor,
      bgColor = _props$bgColor === undefined ? 'transparent' : _props$bgColor,
      _props$focused = props.focused,
      focused = _props$focused === undefined ? false : _props$focused,
      _props$hovered = props.hovered,
      hovered = _props$hovered === undefined ? false : _props$hovered,
      _props$iconColor = props.iconColor,
      iconColor = _props$iconColor === undefined ? defaultIconButtonIconColors[bgColor] : _props$iconColor,
      icon = props.icon,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size;


  var iconSize = SIZE_NAME_TO_PIXEL[size] / 2;

  var inlineStyle = {
    height: SIZE_NAME_TO_PIXEL[size],
    width: SIZE_NAME_TO_PIXEL[size]
  };

  var classes = classnames(styles$14.pog, styles$14[bgColor], (_classnames = {}, defineProperty(_classnames, styles$14.active, active), defineProperty(_classnames, styles$14.focused, focused), defineProperty(_classnames, styles$14.hovered, hovered && !focused && !active), _classnames));

  return React.createElement(
    'div',
    { className: classes, style: inlineStyle },
    React.createElement(
      Box,
      { shape: 'circle' },
      React.createElement(Icon, {
        color: iconColor,
        icon: icon,
        size: iconSize,
        accessibilityLabel: ''
      })
    )
  );
}

Pog.propTypes = {
  active: PropTypes.bool,
  bgColor: PropTypes.oneOf(['transparent', 'lightGray', 'white']),
  focused: PropTypes.bool,
  hovered: PropTypes.bool,
  iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
  icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
  size: PropTypes.oneOf(Object.keys(SIZE_NAME_TO_PIXEL))
};

var IconButton = function (_React$Component) {
  inherits(IconButton, _React$Component);

  function IconButton() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, IconButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IconButton.__proto__ || Object.getPrototypeOf(IconButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      active: false,
      focused: false,
      hovered: false
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _this.handleMouseDown = function () {
      _this.setState({ active: true });
    }, _this.handleMouseEnter = function () {
      _this.setState({ hovered: true });
    }, _this.handleMouseLeave = function () {
      _this.setState({
        active: false,
        hovered: false
      });
    }, _this.handleMouseUp = function () {
      _this.setState({ active: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(IconButton, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityExpanded = _props.accessibilityExpanded,
          accessibilityHaspopup = _props.accessibilityHaspopup,
          accessibilityLabel = _props.accessibilityLabel,
          bgColor = _props.bgColor,
          iconColor = _props.iconColor,
          icon = _props.icon,
          size = _props.size,
          onClick = _props.onClick;
      var _state = this.state,
          active = _state.active,
          focused = _state.focused,
          hovered = _state.hovered;


      return React.createElement(
        'button',
        {
          'aria-expanded': accessibilityExpanded,
          'aria-haspopup': accessibilityHaspopup,
          'aria-label': accessibilityLabel,
          className: styles$13.button,
          onBlur: this.handleBlur,
          onClick: function (_onClick) {
            function onClick(_x) {
              return _onClick.apply(this, arguments);
            }

            onClick.toString = function () {
              return _onClick.toString();
            };

            return onClick;
          }(function (event) {
            return onClick && onClick({ event: event });
          }),
          onFocus: this.handleFocus,
          onMouseDown: this.handleMouseDown,
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          onMouseUp: this.handleMouseUp,
          type: 'button'
        },
        React.createElement(Pog, {
          active: active,
          bgColor: bgColor,
          focused: focused,
          hovered: hovered,
          iconColor: iconColor,
          icon: icon,
          size: size
        })
      );
    }
  }]);
  return IconButton;
}(React.Component);

IconButton.propTypes = {
  accessibilityExpanded: PropTypes.bool,
  accessibilityHaspopup: PropTypes.bool,
  accessibilityLabel: PropTypes.string.isRequired,
  bgColor: PropTypes.oneOf(['transparent', 'lightGray', 'white']),
  icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
  iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
  onClick: PropTypes.func,
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
};

var styles$15 = { "label": "_ww _29 _t7" };

function Label(props) {
  var children = props.children,
      htmlFor = props.htmlFor;


  return React.createElement(
    'label',
    { className: styles$15.label, htmlFor: htmlFor },
    children
  );
}

Label.propTypes = {
  children: PropTypes.node,
  htmlFor: PropTypes.string.isRequired
};

var Layer = function (_React$Component) {
  inherits(Layer, _React$Component);

  function Layer(props) {
    classCallCheck(this, Layer);

    var _this = possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, props));

    _this.el = document.createElement('div');
    return _this;
  }

  createClass(Layer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (document.body) {
        document.body.appendChild(this.el);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (document.body) {
        document.body.removeChild(this.el);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;

      return reactDom.createPortal(children, this.el);
    }
  }]);
  return Layer;
}(React.Component);

/*
  Much of the math and understanding about this component comes from @vjeaux's
  excellent blog post on image resizing.

  http://blog.vjeux.com/2013/image/css-container-and-cover.html

  I highly recommend you read that first before continuing on reading.
*/

var aspectRatio = function aspectRatio(width, height) {
  return width / height;
};

function Letterbox(_ref) {
  var children = _ref.children,
      contentAspectRatio = _ref.contentAspectRatio,
      height = _ref.height,
      width = _ref.width;

  var viewportAspectRatio = aspectRatio(width, height);

  var contentHeight = void 0;
  var contentWidth = void 0;

  if (contentAspectRatio < viewportAspectRatio) {
    contentWidth = width;
    contentHeight = width / contentAspectRatio;
  } else {
    contentWidth = height * contentAspectRatio;
    contentHeight = height;
  }

  var offsetTop = (contentHeight - height) / -2;
  var offsetLeft = (contentWidth - width) / -2;

  return React.createElement(
    Mask,
    { width: width, height: height },
    React.createElement(
      'div',
      { style: { marginTop: offsetTop, marginLeft: offsetLeft } },
      React.createElement(
        Mask,
        { width: contentWidth, height: contentHeight },
        children
      )
    )
  );
}

Letterbox.propTypes = {
  children: PropTypes.node,
  contentAspectRatio: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  width: PropTypes.number.isRequired
};

var styles$16 = { "link": "_wx _sm", "accessibleFocusStyle": "_wy _3r", "block": "_wz _29" };

var TAB_KEY_CODE = 9;

var Link = function (_React$Component) {
  inherits(Link, _React$Component);

  function Link() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Link.__proto__ || Object.getPrototypeOf(Link)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      enableFocusStyles: true
    }, _this.handleClick = function (event) {
      var _this$props = _this.props,
          href = _this$props.href,
          onClick = _this$props.onClick;

      if (onClick && href) {
        onClick({ event: event });
      }
    }, _this.handleMouseDown = function () {
      var _this$props2 = _this.props,
          href = _this$props2.href,
          target = _this$props2.target;

      if (target === 'blank' && href) {
        _this.setState({ enableFocusStyles: false });
      }
    }, _this.handleKeyUp = function (event) {
      var _this$props3 = _this.props,
          href = _this$props3.href,
          target = _this$props3.target;

      if (target === 'blank' && event.keyCode === TAB_KEY_CODE && href) {
        _this.setState({ enableFocusStyles: true });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Link, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          _props$inline = _props.inline,
          inline = _props$inline === undefined ? false : _props$inline,
          _props$target = _props.target,
          target = _props$target === undefined ? null : _props$target,
          href = _props.href;

      var rel = target === 'blank' ? 'noopener noreferrer' : null;
      var linkTarget = target ? '_' + target : null;

      return React.createElement(
        'a',
        {
          className: classnames(styles$16.link, this.state.enableFocusStyles ? styles$16.accessibleFocusStyle : '', inline ? '' : styles$16.block),
          href: href,
          onMouseDown: this.handleMouseDown,
          onKeyUp: this.handleKeyUp,
          onClick: this.handleClick,
          rel: rel,
          target: linkTarget
        },
        children
      );
    }
  }]);
  return Link;
}(React.Component);

Link.propTypes = {
  children: PropTypes.node.isRequired,
  href: PropTypes.string.isRequired,
  inline: PropTypes.bool,
  onClick: PropTypes.func,
  target: PropTypes.oneOf([null, 'self', 'blank'])
};

/**
 * FetchItems is a logic component that renders no content itself. Its job
 * is to manage when the given fetchMore method should be called based on
 * the given scroll/size props.
 *
 * While no element is actually passed to FetchItems, it is intended to be used
 * in conjunction with a large scroll container that uses async fetching to
 * load and render additional data. Based on the height of this container and
 * its current scroll position, FetchItems is responsible for triggering future
 * fetch calls.
 */

var FetchItems = function (_React$PureComponent) {
  inherits(FetchItems, _React$PureComponent);

  function FetchItems() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, FetchItems);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FetchItems.__proto__ || Object.getPrototypeOf(FetchItems)).call.apply(_ref, [this].concat(args))), _this), _this.check = function () {
      var _this$props = _this.props,
          containerHeight = _this$props.containerHeight,
          isAtEnd = _this$props.isAtEnd,
          isFetching = _this$props.isFetching,
          fetchMore = _this$props.fetchMore,
          scrollHeight = _this$props.scrollHeight,
          scrollTop = _this$props.scrollTop;


      if (isAtEnd || isFetching || !fetchMore) {
        return;
      }
      var scrollBuffer = containerHeight * 3;

      if (scrollTop + scrollBuffer > scrollHeight) {
        fetchMore();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(FetchItems, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      setTimeout(this.check);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.check();
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);
  return FetchItems;
}(React.PureComponent);

FetchItems.propTypes = {
  containerHeight: PropTypes.number.isRequired,
  isAtEnd: PropTypes.bool,
  isFetching: PropTypes.bool.isRequired,
  fetchMore: PropTypes.func,
  scrollHeight: PropTypes.number.isRequired,
  scrollTop: PropTypes.number.isRequired
};

var MeasurementStore = function () {
  function MeasurementStore() {
    classCallCheck(this, MeasurementStore);
    this.map = new WeakMap();
  }

  createClass(MeasurementStore, [{
    key: 'get',
    value: function get$$1(key) {
      return this.map.get(key);
    }
  }, {
    key: 'has',
    value: function has(key) {
      return this.map.has(key);
    }
  }, {
    key: 'set',
    value: function set$$1(key, value) {
      this.map.set(key, value);
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.map = new WeakMap();
    }
  }]);
  return MeasurementStore;
}();

/**
 * debounce prevents a particular function from being called until after a given
 * cooldown period (default 100ms). Every time the function is called, it resets
 * the cooldown.
 */

function debounce(fn) {
  var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

  var deferTimer = null;

  var debounced = function debounced() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (deferTimer) {
      clearTimeout(deferTimer);
    }

    deferTimer = setTimeout(function () {
      deferTimer = null;
      fn.apply(undefined, toConsumableArray(args));
    }, threshhold);
  };

  debounced.clearTimeout = function () {
    if (deferTimer) {
      clearTimeout(deferTimer);
    }
  };

  return debounced;
}

var styles$17 = { "Masonry": "_x0 _2j", "Masonry__Item": "_x1 _2l", "Masonry__Item__Mounted": "_x2" };

/**
 * ScrollContainer is a pass-through component that simply sets up an onScroll
 * handler on the given scrollContainer element (or the element that is
 * returned as result of calling the scrollContainer method). This allows for
 * the event listener subscription of the scrollContainer to be managed inside
 * the React lifecycle without adding bloat to Masonry or other onScroll
 * subscribers.
 *
 * Note that this Component renders its children without creating any
 * additional content. Also note that, while the component is built to manage
 * onScroll inside of the React lifecycle, it doesn't change onScroll events
 * or the API at all, so it could easily be adapted to other event types.
 */

function getScrollContainer(scrollContainer) {
  return typeof scrollContainer === 'function' ? scrollContainer() : scrollContainer;
}

var ScrollContainer = function (_React$Component) {
  inherits(ScrollContainer, _React$Component);

  function ScrollContainer() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ScrollContainer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollContainer.__proto__ || Object.getPrototypeOf(ScrollContainer)).call.apply(_ref, [this].concat(args))), _this), _this.getScrollContainerRef = function () {
      return _this.scrollContainer;
    }, _this.handleScroll = function (event) {
      _this.props.onScroll(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(ScrollContainer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var scrollContainer = getScrollContainer(this.props.scrollContainer);
      if (scrollContainer) {
        this.updateScrollContainer(scrollContainer);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var nextScrollContainer = getScrollContainer(this.props.scrollContainer);
      if (nextScrollContainer && nextScrollContainer !== this.scrollContainer) {
        this.updateScrollContainer(nextScrollContainer);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener('scroll', this.handleScroll);
      }
    }
  }, {
    key: 'updateScrollContainer',
    value: function updateScrollContainer(scrollContainer) {
      if (this.scrollContainer) {
        // cleanup existing scroll container if it exists
        this.scrollContainer.removeEventListener('scroll', this.handleScroll);
      }
      this.scrollContainer = scrollContainer;
      this.scrollContainer.addEventListener('scroll', this.handleScroll);
    }
  }, {
    key: 'render',
    value: function render() {
      return React.Children.only(this.props.children);
    }
  }]);
  return ScrollContainer;
}(React.Component);

ScrollContainer.propTypes = {
  children: PropTypes.node.isRequired,
  onScroll: PropTypes.func.isRequired,
  scrollContainer: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
};

/**
 * throttle limits the number of times a function can be called to a
 * given threshhold (100ms by default). The function is always called
 * on the leading and trailing edge.
 */

function throttle(fn) {
  var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

  var last = void 0;
  var deferTimer = void 0;
  var throttled = function throttled() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var now = Date.now();
    if (last !== undefined && now - last < threshhold) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        fn.apply(undefined, toConsumableArray(args));
      }, threshhold - (now - last));
    } else {
      last = now;
      fn.apply(undefined, toConsumableArray(args));
    }
  };

  throttled.clearTimeout = function () {
    if (deferTimer) {
      clearTimeout(deferTimer);
    }
  };

  return throttled;
}

/**
 * Measuring scroll positions, element heights, etc is different between
 * different browsers and the window object vs other DOM nodes. These
 * utils abstract away these differences.
 */

function getElementHeight(element) {
  return element === window ? window.innerHeight : element.clientHeight;
}

function getWindowScrollPos() {
  if (window.scrollY !== undefined) {
    // Modern browser
    return window.scrollY;
  }
  if (document.documentElement && document.documentElement.scrollTop !== undefined) {
    // IE support.
    return document.documentElement.scrollTop;
  }
  return 0;
}

function getRelativeScrollTop(element) {
  return element === window ? getWindowScrollPos() : element.scrollTop - element.getBoundingClientRect().top;
}

function getScrollHeight(element) {
  return element === window && document.documentElement ? document.documentElement.scrollHeight : element.scrollHeight;
}

function getScrollPos(element) {
  return element === window ? getWindowScrollPos() : element.scrollTop;
}

var DefaultLayoutSymbol = Symbol('default');
var UniformRowLayoutSymbol = Symbol('uniformRow');

var mindex$1 = function mindex(arr) {
  var idx = 0;
  for (var i = 0; i < arr.length; i += 1) {
    if (arr[i] < arr[idx]) {
      idx = i;
    }
  }
  return idx;
};

var offscreen = function offscreen(width) {
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  return {
    top: -9999,
    left: -9999,
    width: width,
    height: height
  };
};

var defaultLayout = (function (_ref) {
  var cache = _ref.cache,
      _ref$columnWidth = _ref.columnWidth,
      columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
      width = _ref.width;
  return function (items) {
    if (width == null) {
      return items.map(function () {
        return offscreen(columnWidth);
      });
    }

    var columnWidthAndGutter = columnWidth + gutter;
    var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);
    // the total height of each column
    var heights = new Array(columnCount).fill(0);
    var centerOffset = Math.max(Math.floor((width - columnWidthAndGutter * columnCount + gutter) / 2), 0);

    return items.reduce(function (acc, item) {
      var positions = acc;
      // $FlowFixMe
      var height = cache.get(item);
      var position = void 0;

      if (height == null) {
        position = offscreen(columnWidth);
      } else {
        var heightAndGutter = height + gutter;
        var col = mindex$1(heights);
        var _top = heights[col];
        var _left = col * columnWidthAndGutter + centerOffset;

        heights[col] += heightAndGutter;
        position = { top: _top, left: _left, width: columnWidth, height: height };
      }
      positions.push(position);
      return positions;
    }, []);
  };
});

var offscreen$1 = function offscreen(width) {
  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  return {
    top: -9999,
    left: -9999,
    width: width,
    height: height
  };
};

var uniformRowLayout = (function (_ref) {
  var cache = _ref.cache,
      _ref$columnWidth = _ref.columnWidth,
      columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
      _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
      width = _ref.width,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 3 : _ref$minCols;
  return function (items) {
    if (width == null) {
      return items.map(function () {
        return offscreen$1(columnWidth);
      });
    }

    var columnWidthAndGutter = columnWidth + gutter;
    var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);

    var positions = [];
    var heights = [];

    for (var i = 0; i < items.length; i += 1) {
      var position = void 0;
      var _height = cache.get(items[i]);

      if (_height == null) {
        position = offscreen$1(columnWidth);
      } else {
        var column = i % columnCount;
        var row = Math.floor(i / columnCount);

        if (column === 0 || _height > heights[row]) {
          heights[row] = _height;
        }

        var _top = row > 0 ? heights.slice(0, row).reduce(function (sum, y) {
          return sum + y + gutter;
        }, 0) : 0;

        position = {
          top: _top,
          left: column * columnWidthAndGutter,
          width: columnWidth,
          height: _height
        };
      }
      positions.push(position);
    }
    return positions;
  };
});

var mindex$2 = function mindex(arr) {
  var idx = 0;
  for (var i = 0; i < arr.length; i += 1) {
    if (arr[i] < arr[idx]) {
      idx = i;
    }
  }
  return idx;
};

var fullWidthLayout = (function (_ref) {
  var _ref$gutter = _ref.gutter,
      gutter = _ref$gutter === undefined ? 0 : _ref$gutter,
      cache = _ref.cache,
      _ref$minCols = _ref.minCols,
      minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
      _ref$idealColumnWidth = _ref.idealColumnWidth,
      idealColumnWidth = _ref$idealColumnWidth === undefined ? 240 : _ref$idealColumnWidth,
      width = _ref.width;

  if (width == null) {
    return function (items) {
      return items.map(function () {
        return {
          top: Infinity,
          left: Infinity,
          width: Infinity,
          height: Infinity
        };
      });
    };
  }

  // "This is kind of crazy!" - you
  // Yes, indeed. The "guessing" here is meant to replicate the pass that the
  // original implementation takes with CSS.
  var colguess = Math.floor(width / idealColumnWidth);
  var columnCount = Math.max(Math.floor((width - colguess * gutter) / idealColumnWidth), minCols);
  var columnWidth = Math.floor(width / columnCount);

  return function (items) {
    // the total height of each column
    var heights = new Array(columnCount).fill(0);

    return items.reduce(function (acc, item) {
      var positions = acc;
      var height = cache.get(item);
      var position = void 0;

      if (height == null) {
        position = {
          top: Infinity,
          left: Infinity,
          width: columnWidth,
          height: Infinity
        };
      } else {
        var col = mindex$2(heights);
        var _top = heights[col];
        var _left = col * columnWidth + gutter / 2;

        heights[col] += height;
        position = {
          top: _top,
          left: _left,
          width: columnWidth - gutter,
          height: height
        };
      }

      positions.push(position);
      return positions;
    }, []);
  };
});

var MasonryLayout = function MasonryLayout() {
  classCallCheck(this, MasonryLayout);
};

var UniformRowLayout = function UniformRowLayout() {
  classCallCheck(this, UniformRowLayout);
};

var RESIZE_DEBOUNCE = 300;
// Multiplied against container height.
// The amount of extra buffer space for populating visible items.
var VIRTUAL_BUFFER_FACTOR = 0.7;

var layoutNumberToCssDimension = function layoutNumberToCssDimension(n) {
  return n !== Infinity ? n : undefined;
};

function layoutClass(_ref, _ref2) {
  var columnWidth = _ref.columnWidth,
      flexible = _ref.flexible,
      gutter = _ref.gutterWidth,
      layout = _ref.layout,
      measurementStore = _ref.measurementStore,
      minCols = _ref.minCols;
  var width = _ref2.width;

  if (flexible && width !== null) {
    return fullWidthLayout({
      gutter: gutter,
      cache: measurementStore,
      minCols: minCols,
      idealColumnWidth: columnWidth,
      width: width
    });
  }
  if (layout === UniformRowLayoutSymbol || layout instanceof UniformRowLayout) {
    return uniformRowLayout({
      cache: measurementStore,
      columnWidth: columnWidth,
      gutter: gutter,
      minCols: minCols,
      width: width
    });
  }
  return defaultLayout({
    cache: measurementStore,
    columnWidth: columnWidth,
    gutter: gutter,
    minCols: minCols,
    width: width
  });
}

function statesForRendering(props, state) {
  var measurementStore = props.measurementStore,
      minCols = props.minCols;
  var items = state.items;

  // Full layout is possible

  var itemsToRender = items.filter(function (item) {
    return item && measurementStore.has(item);
  });

  var layout = layoutClass(props, state);
  var renderPositions = layout(itemsToRender);
  // Math.max() === -Infinity when there are no renderPositions
  var height = renderPositions.length ? Math.max.apply(Math, toConsumableArray(renderPositions.map(function (pos) {
    return pos.top + pos.height;
  }))) : 0;

  var itemsToMeasure = items.filter(function (item) {
    return item && !measurementStore.has(item);
  }).slice(0, minCols);
  var measuringPositions = layout(itemsToMeasure);

  return {
    height: height,
    itemsToRender: itemsToRender,
    itemsToMeasure: itemsToMeasure,
    measuringPositions: measuringPositions,
    renderPositions: renderPositions
  };
}

/**
 * TODO this should be renamed to MasronyBeta or something else so it is clear
 * that this is not the exported Masonry.
 *
 * The goal is to eventually not have any scroll fetching concerns in this component.
 * The name is kept for now to have an easier time seeing the diffs.
 */

var Masonry = function (_React$Component) {
  inherits(Masonry, _React$Component);

  function Masonry(props) {
    classCallCheck(this, Masonry);

    var _this = possibleConstructorReturn(this, (Masonry.__proto__ || Object.getPrototypeOf(Masonry)).call(this, props));

    _this.handleResize = debounce(function () {
      if (_this.gridWrapper) {
        _this.setState({ width: _this.gridWrapper.clientWidth });
      }
    }, RESIZE_DEBOUNCE);
    _this.updateScrollPosition = throttle(function () {
      if (!_this.scrollContainer) {
        return;
      }
      var scrollContainer = _this.scrollContainer.getScrollContainerRef();

      if (!scrollContainer) {
        return;
      }

      _this.setState({
        scrollTop: getScrollPos(scrollContainer)
      });

      _this.handleVirtualizationWindowUpdate();
    });
    _this.measureContainerAsync = debounce(function () {
      _this.measureContainer();
    }, 0);

    _this.setGridWrapperRef = function (ref) {
      _this.gridWrapper = ref;
    };

    _this.setScrollContainerRef = function (ref) {
      _this.scrollContainer = ref;
    };

    _this.handleVirtualizationWindowUpdate = function () {
      var _this$state = _this.state,
          height = _this$state.height,
          width = _this$state.width;

      if (typeof _this.props.onVirtualizationWindowUpdate === 'function' && _this.containerHeight) {
        var _viewport = {
          top: _this.state.scrollTop,
          left: 0,
          height: _this.containerHeight,
          width: width || 0
        };
        var _content = {
          top: _this.containerOffset,
          left: 0,
          height: height,
          width: width || 0
        };

        _this.props.onVirtualizationWindowUpdate(_content, _viewport);
      }
    };

    _this.handleOnAutoMeasuringUpdate = function (state) {
      if (_this.props.onAutoMeasuringUpdate) {
        _this.props.onAutoMeasuringUpdate(state);
      }
    };

    _this.renderMasonryComponent = function (itemData, idx, position) {
      var _this$props = _this.props,
          Component = _this$props.comp,
          virtualize = _this$props.virtualize,
          virtualBoundsTop = _this$props.virtualBoundsTop,
          virtualBoundsBottom = _this$props.virtualBoundsBottom;
      var top = position.top,
          left = position.left,
          width = position.width,
          height = position.height;


      var isVisible = void 0;
      if (_this.props.scrollContainer) {
        var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR;
        var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
        var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
        var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

        isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
      } else {
        // if no scroll container is passed in, items should always be visible
        isVisible = true;
      }

      var itemComponent = React.createElement(
        'div',
        {
          key: 'item-' + idx,
          className: [styles$17.Masonry__Item, styles$17.Masonry__Item__Mounted].join(' '),
          'data-grid-item': true,
          style: {
            top: 0,
            left: 0,
            transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
            width: layoutNumberToCssDimension(width),
            height: layoutNumberToCssDimension(height)
          }
        },
        React.createElement(Component, { data: itemData, itemIdx: idx, isMeasuring: false })
      );

      return virtualize ? isVisible && itemComponent || null : itemComponent;
    };

    _this.containerHeight = 0;
    _this.containerOffset = 0;

    _this.state = {
      hasPendingMeasurements: props.items.some(function (item) {
        return !!item && !props.measurementStore.has(item);
      }),
      height: 0,
      itemsToRender: [],
      itemsToMeasure: [],
      // eslint-disable-next-line react/no-unused-state
      items: props.items,
      measuringPositions: [],
      renderPositions: [],
      scrollTop: 0,
      width: undefined
    };
    return _this;
  }

  /**
   * Adds hooks after the component mounts.
   */

  /**
   * Delays resize handling in case the scroll container is still being resized.
   */


  createClass(Masonry, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      window.addEventListener('resize', this.handleResize);

      this.measureContainer();

      var scrollTop = this.state.scrollTop;

      if (this.scrollContainer != null) {
        var _scrollContainer = this.scrollContainer.getScrollContainerRef();
        if (_scrollContainer) {
          scrollTop = getScrollPos(_scrollContainer);
        }
      }

      this.setState(function (prevState) {
        return {
          scrollTop: scrollTop,
          width: _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width
        };
      });

      // need to make sure parent component has the correct pending measurement value
      this.handleOnAutoMeasuringUpdate(this.state.hasPendingMeasurements ? 'measuring' : 'idle');
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var _this3 = this;

      var _props = this.props,
          items = _props.items,
          measurementStore = _props.measurementStore;


      this.measureContainerAsync();

      if (prevState.width != null && this.state.width !== prevState.width) {
        measurementStore.reset();
      }
      // calculate whether we still have pending measurements
      var hasPendingMeasurements = items.some(function (item) {
        return !!item && !measurementStore.has(item);
      });

      if (hasPendingMeasurements && !prevState.hasPendingMeasurements) {
        this.handleOnAutoMeasuringUpdate('measuring');
      } else if (!hasPendingMeasurements && prevState.hasPendingMeasurements) {
        this.handleOnAutoMeasuringUpdate('idle');
      }
      this.handleVirtualizationWindowUpdate();

      if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
        this.insertAnimationFrame = requestAnimationFrame(function () {
          var renderingStates = statesForRendering(_this3.props, _this3.state);
          _this3.setState(_extends({
            hasPendingMeasurements: hasPendingMeasurements
          }, renderingStates));
        });
      } else if (hasPendingMeasurements || prevState.items !== items) {
        this.insertAnimationFrame = requestAnimationFrame(function () {
          var renderingStates = statesForRendering(_this3.props, _this3.state);
          _this3.setState(_extends({}, renderingStates));
        });
      }
    }

    /**
     * Remove listeners when unmounting.
     */

  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.insertAnimationFrame) {
        cancelAnimationFrame(this.insertAnimationFrame);
      }

      // Make sure async methods are cancelled.
      this.measureContainerAsync.clearTimeout();
      this.handleResize.clearTimeout();
      this.updateScrollPosition.clearTimeout();

      window.removeEventListener('resize', this.handleResize);
    }
  }, {
    key: 'measureContainer',
    value: function measureContainer() {
      if (this.scrollContainer != null) {
        var _scrollContainer2 = this.scrollContainer;

        var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
        if (scrollContainerRef) {
          this.containerHeight = getElementHeight(scrollContainerRef);
          var el = this.gridWrapper;
          if (el instanceof HTMLElement) {
            var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
            this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
          }
        }
      }
    }

    /**
     * Clear measurements/positions and force a reflow of the entire grid.
     * Only use this if absolutely necessary - ex: We need to reflow items if the
     * number of columns we would display should change after a resize.
     */

  }, {
    key: 'reflow',
    value: function reflow() {
      this.props.measurementStore.reset();
      this.measureContainer();
      this.handleVirtualizationWindowUpdate();
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      var _props2 = this.props,
          columnWidth = _props2.columnWidth,
          Component = _props2.comp,
          flexible = _props2.flexible,
          measurementStore = _props2.measurementStore,
          items = _props2.items;
      var _state = this.state,
          hasPendingMeasurements = _state.hasPendingMeasurements,
          height = _state.height,
          itemsToMeasure = _state.itemsToMeasure,
          itemsToRender = _state.itemsToRender,
          measuringPositions = _state.measuringPositions,
          renderPositions = _state.renderPositions,
          width = _state.width;


      var gridBody = void 0;
      if (width == null && hasPendingMeasurements) {
        // When hyrdating from a server render, we don't have the width of the grid
        // and the measurement store is empty
        gridBody = React.createElement(
          'div',
          {
            className: styles$17.Masonry,
            style: { height: 0, width: '100%' },
            ref: this.setGridWrapperRef
          },
          items.filter(function (item) {
            return item;
          }).map(function (item, i) {
            return React.createElement(
              'div',
              { // keep this in sync with renderMasonryComponent
                className: 'static',
                'data-grid-item': true,
                key: i,
                style: {
                  top: 0,
                  left: 0,
                  transform: 'translateX(0px) translateY(0px)',
                  WebkitTransform: 'translateX(0px) translateY(0px)',
                  width: flexible ? undefined : layoutNumberToCssDimension(columnWidth) // we can't set a width for server rendered flexible items
                },
                ref: function ref(el) {
                  if (el && !flexible) {
                    // only measure flexible items on client
                    measurementStore.set(item, el.clientHeight);
                  }
                }
              },
              React.createElement(Component, { data: item, itemIdx: i, isMeasuring: false })
            );
          })
        );
      } else if (width == null) {
        // When the width is empty (usually after a re-mount) render an empty
        // div to collect the width for layout
        gridBody = React.createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
      } else {
        gridBody = React.createElement(
          'div',
          { style: { width: '100%' }, ref: this.setGridWrapperRef },
          React.createElement(
            'div',
            { className: styles$17.Masonry, style: { height: height, width: width } },
            itemsToRender.map(function (item, i) {
              return (
                // $FlowFixMe this is the right definition, it an Array<T>
                _this4.renderMasonryComponent(item, i, renderPositions[i])
              );
            })
          ),
          React.createElement(
            'div',
            { className: styles$17.Masonry, style: { width: width } },
            itemsToMeasure.map(function (data, i) {
              // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
              // we normalize the index here relative to the item list as a whole so that itemIdx is correct
              // and so that React doesnt reuse the measurement nodes
              var measurementIndex = itemsToRender.length + i;
              var position = measuringPositions[i];
              return React.createElement(
                'div',
                {
                  key: 'measuring-' + measurementIndex,
                  style: {
                    visibility: 'hidden',
                    position: 'absolute',
                    top: layoutNumberToCssDimension(position.top),
                    left: layoutNumberToCssDimension(position.left),
                    width: layoutNumberToCssDimension(position.width),
                    height: layoutNumberToCssDimension(position.height)
                  },
                  ref: function ref(el) {
                    if (el) {
                      measurementStore.set(data, el.clientHeight);
                    }
                  }
                },
                React.createElement(Component, {
                  data: data,
                  itemIdx: measurementIndex,
                  isMeasuring: true
                })
              );
            })
          )
        );
      }

      return this.props.scrollContainer ? React.createElement(
        ScrollContainer,
        {
          ref: this.setScrollContainerRef,
          onScroll: this.updateScrollPosition,
          scrollContainer: this.props.scrollContainer
        },
        gridBody
      ) : gridBody;
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var items = props.items,
          measurementStore = props.measurementStore;
      // whenever we're receiving new props, determine whether any items need to be measured
      // TODO - we should treat items as immutable

      var hasPendingMeasurements = items.some(function (item) {
        return item && !measurementStore.has(item);
      });

      // Shallow compare all items, if any change reflow the grid.
      for (var i = 0; i < items.length; i += 1) {
        // We've reached the end of our current props and everything matches.
        // If we hit this case it means we need to insert new items.
        if (state.items[i] === undefined) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          };
        }

        // Reset grid items when:
        if (
        // An item object ref does not match.
        items[i] !== state.items[i] ||
        // Or less items than we currently have are passed in.
        items.length < state.items.length) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          };
        }
      }

      // Reset items if new items array is empty.
      if (items.length === 0 && state.items.length > 0) {
        return {
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        };
      }
      if (hasPendingMeasurements !== state.hasPendingMeasurements) {
        // make sure we always update hasPendingMeasurements
        return {
          hasPendingMeasurements: hasPendingMeasurements,
          items: items
        };
      }

      // Return null to indicate no change to state.
      return null;
    }
  }]);
  return Masonry;
}(React.Component);

Masonry.propTypes = {
  /**
   * The preferred/target item width. If `flexible` is set, the item width will
   * grow to fill column space, and shrink to fit if below min columns.
   */
  columnWidth: PropTypes.number,

  /**
   * The component to render.
   */
  /* eslint react/no-unused-prop-types: 0 */
  comp: PropTypes.func.isRequired,

  /**
   * The preferred/target item width. Item width will grow to fill
   * column space, and shrink to fit if below min columns.
   */
  flexible: PropTypes.bool,

  /**
   * The amount of space between each item.
   */
  gutterWidth: PropTypes.number,

  /**
   * An array of all objects to display in the grid.
   */
  items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

  /**
   * Measurement Store
   */
  measurementStore: PropTypes.instanceOf(MeasurementStore),

  /**
   * Layout system to use for items
   */
  layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

  /**
   * A callback which the grid calls when we need to load more items as the user scrolls.
   * The callback should update the state of the items, and pass those in as props
   * to this component.
   */
  loadItems: PropTypes.func,

  /**
   * Minimum number of columns to display.
   */
  minCols: PropTypes.number,

  /**
   * Function that the grid calls to get the scroll container.
   * This is required if the grid is expected to be scrollable.
   */
  scrollContainer: PropTypes.func,

  /**
   * Whether or not to use actual virtualization
   */
  virtualize: PropTypes.bool
};
Masonry.defaultProps = {
  columnWidth: 236,
  measurementStore: new MeasurementStore(),
  minCols: 3,
  layout: DefaultLayoutSymbol,
  loadItems: function loadItems() {},
  virtualize: false
};

/**
 * This MasonryInfinite is backward compatible and serves to help with migrating
 * to a Masrony that doesn't have the scrol fetch concerns
 */
var MasonryInfinite = function (_React$Component) {
  inherits(MasonryInfinite, _React$Component);
  createClass(MasonryInfinite, null, [{
    key: 'createMeasurementStore',
    value: function createMeasurementStore() {
      return new MeasurementStore();
    }
  }]);

  function MasonryInfinite(props) {
    classCallCheck(this, MasonryInfinite);

    var _this = possibleConstructorReturn(this, (MasonryInfinite.__proto__ || Object.getPrototypeOf(MasonryInfinite)).call(this, props));

    _this.onVirtualizationWindowUpdate = function (content, viewport) {
      var _this$state = _this.state,
          containerHeight = _this$state.containerHeight,
          scrollTop = _this$state.scrollTop,
          scrollHeight = _this$state.scrollHeight;

      if (viewport.height !== containerHeight || viewport.top !== scrollTop || content.height !== scrollHeight) {
        _this.setState({
          containerHeight: viewport.height,
          scrollTop: viewport.top,
          scrollHeight: content.height
        });
      }
    };

    _this.setRef = function (ref) {
      if (ref) {
        _this.gridRef = ref;
      }
    };

    _this.fetchMore = function () {
      var loadItems = _this.props.loadItems;

      if (loadItems && typeof loadItems === 'function') {
        _this.setState({
          isFetching: true
        }, function () {
          return loadItems({ from: _this.props.items.length });
        });
      }
    };

    _this.handleOnAutoMeasuringUpdate = function (state) {
      var hasPendingMeasurements = state === 'measuring';
      if (_this.state.hasPendingMeasurements !== hasPendingMeasurements) {
        _this.setState({ hasPendingMeasurements: hasPendingMeasurements });
      }

      if (typeof _this.props.onAutoMeasuringUpdate === 'function') {
        _this.props.onAutoMeasuringUpdate(state);
      }
    };

    _this.reflow = function () {
      if (_this.gridRef) {
        _this.gridRef.reflow();
      }
    };

    _this.handleResize = function () {
      if (_this.gridRef) {
        _this.gridRef.handleResize();
      }
    };

    _this.state = {
      containerHeight: 0,
      hasPendingMeasurements: false,
      isFetching: false,
      // eslint-disable-next-line react/no-unused-state
      items: props.items,
      scrollTop: 0,
      scrollHeight: 0
    };
    return _this;
  }

  /**
   * Content layer and Viewport layer is as defined in Collection.
   */


  createClass(MasonryInfinite, [{
    key: 'render',
    value: function render() {
      return this.props.scrollContainer ? React.createElement(
        React.Fragment,
        null,
        React.createElement(FetchItems, {
          containerHeight: this.state.containerHeight,
          fetchMore: this.fetchMore,
          isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
          scrollHeight: this.state.scrollHeight,
          scrollTop: this.state.scrollTop
        }),
        React.createElement(Masonry, _extends({}, this.props, {
          onVirtualizationWindowUpdate: this.onVirtualizationWindowUpdate,
          onAutoMeasuringUpdate: this.handleOnAutoMeasuringUpdate,
          ref: this.setRef
        }))
      ) : React.createElement(Masonry, _extends({}, this.props, { ref: this.setRef }));
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      var items = props.items;

      // assume immutable items

      if (props.items !== state.items) {
        return {
          items: items,
          isFetching: false
        };
      }

      // Return null to indicate no change to state.
      return null;
    }
  }]);
  return MasonryInfinite;
}(React.Component);

MasonryInfinite.defaultProps = Masonry.defaultProps;

var NoScrollBehavior = function (_React$Component) {
  inherits(NoScrollBehavior, _React$Component);

  function NoScrollBehavior(props) {
    classCallCheck(this, NoScrollBehavior);

    var _this = possibleConstructorReturn(this, (NoScrollBehavior.__proto__ || Object.getPrototypeOf(NoScrollBehavior)).call(this, props));

    _this.prevOverflow = null;
    return _this;
  }

  createClass(NoScrollBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (typeof window !== 'undefined') {
        this.prevOverflow = window.document.body.style.overflow;
        window.document.body.style.overflow = 'hidden';
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (typeof window !== 'undefined') {
        window.document.body.style.overflow = this.prevOverflow;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);
  return NoScrollBehavior;
}(React.Component);

function queryFocusableAll(el) {
  var selector = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[tabindex="-1"]', '[tabindex="0"]', '[contenteditable]', 'audio[controls]', 'video[controls]', 'summary'].join(',');
  return el.querySelectorAll(selector);
}

var focusElement = function focusElement(el) {
  if (typeof el.focus === 'function') {
    el.focus();
  }
};

var TrapFocusBehavior = function (_React$Component) {
  inherits(TrapFocusBehavior, _React$Component);

  function TrapFocusBehavior() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TrapFocusBehavior);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TrapFocusBehavior.__proto__ || Object.getPrototypeOf(TrapFocusBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.setElRef = function (el) {
      if (el) {
        _this.el = el;
      }
    }, _this.handleFocus = function (event) {
      if (!_this.el || event.target instanceof Node && _this.el.contains(event.target)) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      _this.focusFirstChild();
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TrapFocusBehavior, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.previouslyFocusedEl = document.activeElement;
      this.focusFirstChild();
      document.addEventListener('focus', this.handleFocus, true);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('focus', this.handleFocus, true);
      if (this.previouslyFocusedEl) {
        focusElement(this.previouslyFocusedEl);
      }
    }
  }, {
    key: 'focusFirstChild',
    value: function focusFirstChild() {
      var el = this.el;

      if (el) {
        focusElement(queryFocusableAll(el)[0]);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { ref: this.setElRef },
        this.props.children
      );
    }
  }]);
  return TrapFocusBehavior;
}(React.Component);

var styles$18 = { "Backdrop": "_x3 _2l _2q _2n _2o _2p _t9 _5t", "container": "_x4 _2k _2u _2w _3e _2q _2n _34 _45", "wrapper": "_x5 _2j _2d _2w _5n _5e _7y _7w" };

var SIZE_WIDTH_MAP$1 = {
  sm: 414,
  md: 544,
  lg: 804
};

var ESCAPE_KEY_CODE$1 = 27;

var Backdrop = function Backdrop(_ref) {
  var children = _ref.children;
  return React.createElement(
    React.Fragment,
    null,
    React.createElement('div', { className: styles$18.Backdrop }),
    children
  );
};

var Modal = function (_React$Component) {
  inherits(Modal, _React$Component);

  function Modal() {
    var _ref2;

    var _temp, _this, _ret;

    classCallCheck(this, Modal);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref2, [this].concat(args))), _this), _this.handleOutsideClick = function () {
      _this.props.onDismiss();
    }, _this.handleCloseClick = function () {
      _this.props.onDismiss();
    }, _this.handleKeyUp = function (event) {
      if (event.keyCode === ESCAPE_KEY_CODE$1) {
        _this.props.onDismiss();
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Modal, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      window.addEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('keyup', this.handleKeyUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityCloseLabel = _props.accessibilityCloseLabel,
          accessibilityModalLabel = _props.accessibilityModalLabel,
          children = _props.children,
          footer = _props.footer,
          heading = _props.heading,
          _props$role = _props.role,
          role = _props$role === undefined ? 'dialog' : _props$role,
          _props$size = _props.size,
          size = _props$size === undefined ? 'sm' : _props$size;

      var width = SIZE_WIDTH_MAP$1[size];

      return React.createElement(
        NoScrollBehavior,
        null,
        React.createElement(
          TrapFocusBehavior,
          null,
          React.createElement(
            'div',
            {
              'aria-label': accessibilityModalLabel,
              className: styles$18.container,
              role: role
            },
            React.createElement(
              Backdrop,
              null,
              React.createElement(
                OutsideEventBehavior,
                { onClick: this.handleOutsideClick },
                React.createElement(
                  'div',
                  { className: styles$18.wrapper, tabIndex: -1, style: { width: width } },
                  React.createElement(
                    Box,
                    {
                      flex: 'grow',
                      position: 'relative',
                      display: 'flex',
                      direction: 'column'
                    },
                    React.createElement(
                      Box,
                      { fit: true },
                      role === 'dialog' ? React.createElement(
                        Box,
                        {
                          dangerouslySetInlineStyle: {
                            __style: { paddingLeft: 50, paddingRight: 50 }
                          },
                          display: 'flex',
                          justifyContent: 'center',
                          paddingY: 5
                        },
                        React.createElement(
                          Heading,
                          { size: 'xs', accessibilityLevel: 1 },
                          heading
                        )
                      ) : React.createElement(
                        Box,
                        { display: 'flex', padding: 4 },
                        React.createElement(
                          Heading,
                          { size: 'sm', accessibilityLevel: 1 },
                          heading
                        )
                      ),
                      role === 'dialog' && React.createElement(
                        Box,
                        { padding: 2, position: 'absolute', top: true, right: true },
                        React.createElement(IconButton, {
                          accessibilityLabel: accessibilityCloseLabel,
                          icon: 'cancel',
                          onClick: this.handleCloseClick
                        })
                      ),
                      role === 'dialog' && React.createElement(Divider, null)
                    ),
                    React.createElement(
                      Box,
                      { flex: 'grow', overflow: 'auto', position: 'relative' },
                      children
                    ),
                    React.createElement(
                      Box,
                      { fit: true },
                      footer && React.createElement(
                        Box,
                        null,
                        role === 'dialog' && React.createElement(Divider, null),
                        React.createElement(
                          Box,
                          { padding: 4 },
                          footer
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      );
    }
  }]);
  return Modal;
}(React.Component);

Modal.propTypes = {
  children: PropTypes.node,
  accessibilityCloseLabel: PropTypes.string.isRequired,
  footer: PropTypes.node,
  heading: PropTypes.string.isRequired,
  accessibilityModalLabel: PropTypes.string.isRequired,
  onDismiss: PropTypes.func,
  role: PropTypes.oneOf(['alertdialog', 'dialog']),
  size: PropTypes.oneOf(['sm', 'md', 'lg'])
};

var styles$19 = { "innerCircle": "_x6 _2u", "PulseAnimation": "_x7", "outerCircle": "_x8", "AppearAnimation": "_x9" };

function Pulsar(props) {
  var paused = props.paused,
      _props$size = props.size,
      size = _props$size === undefined ? 135 : _props$size;


  return React.createElement(
    Box,
    {
      dangerouslySetInlineStyle: {
        __style: {
          animationIterationCount: paused ? 0 : 'infinite',
          outline: 'none',
          boxShadow: 'none'
        }
      },
      display: paused ? 'none' : 'block',
      height: size,
      position: 'relative',
      width: size
    },
    React.createElement(
      'div',
      { className: styles$19.innerCircle },
      React.createElement('div', { className: styles$19.outerCircle })
    )
  );
}

Pulsar.propTypes = {
  paused: PropTypes.bool,
  size: PropTypes.number
};

var styles$20 = { "RadioButton": "_xa _29 _2u _5c _2w _34 _3e", "RadioButtonSm": "_xb", "RadioButtonMd": "_xc", "RadioButtonIsFocused": "_xd _3s", "RadioButtonWhiteBg": "_xe _5n", "RadioButtonLightGrayBg": "_xf _5p", "Input": "_xg _2l _pb", "InputEnabled": "_xh _t7", "InputSm": "_xi", "InputMd": "_xj", "Check": "_xk _5c", "CheckEnabled": "_xl _5t", "CheckDisabled": "_xm _5r" };

var RadioButton = function (_React$Component) {
  inherits(RadioButton, _React$Component);

  function RadioButton() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, RadioButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({ checked: checked, event: event });
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(RadioButton, [{
    key: 'render',
    value: function render() {
      var _classnames, _classnames2, _classnames3;

      var _props = this.props,
          checked = _props.checked,
          disabled = _props.disabled,
          id = _props.id,
          name = _props.name,
          size = _props.size,
          value = _props.value;

      return React.createElement(
        'div',
        {
          className: classnames(styles$20.RadioButton, (_classnames = {}, defineProperty(_classnames, styles$20.RadioButtonIsFocused, this.state.focused), defineProperty(_classnames, styles$20.RadioButtonSm, size === 'sm'), defineProperty(_classnames, styles$20.RadioButtonMd, size === 'md'), defineProperty(_classnames, styles$20.RadioButtonWhiteBg, !disabled || checked), defineProperty(_classnames, styles$20.RadioButtonLightGrayBg, disabled && !checked), _classnames))
        },
        React.createElement('input', {
          checked: checked,
          className: classnames(styles$20.Input, (_classnames2 = {}, defineProperty(_classnames2, styles$20.InputEnabled, !disabled), defineProperty(_classnames2, styles$20.InputSm, size === 'sm'), defineProperty(_classnames2, styles$20.InputMd, size === 'md'), _classnames2)),
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          type: 'radio',
          value: value
        }),
        checked && React.createElement('div', {
          className: classnames(styles$20.Check, (_classnames3 = {}, defineProperty(_classnames3, styles$20.CheckSm, size === 'sm'), defineProperty(_classnames3, styles$20.CheckMd, size === 'md'), defineProperty(_classnames3, styles$20.CheckEnabled, !disabled), defineProperty(_classnames3, styles$20.CheckDisabled, disabled), _classnames3))
        })
      );
    }
  }]);
  return RadioButton;
}(React.Component);

RadioButton.propTypes = {
  checked: PropTypes.bool,
  disabled: PropTypes.bool,
  id: PropTypes.string.isRequired,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  value: PropTypes.string.isRequired,
  size: PropTypes.oneOf(['sm', 'md'])
};
RadioButton.defaultProps = {
  checked: false,
  disabled: false,
  size: 'md'
};

var ScrollFetch = function (_React$PureComponent) {
  inherits(ScrollFetch, _React$PureComponent);

  function ScrollFetch() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, ScrollFetch);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollFetch.__proto__ || Object.getPrototypeOf(ScrollFetch)).call.apply(_ref, [this].concat(args))), _this), _this.updatePosition = throttle(function () {
      _this.setState(_this.getScrollState());
    }), _this.state = {
      containerHeight: 0,
      scrollHeight: 0,
      scrollTop: 0
    }, _this.getScrollHeight = function () {
      var container = _this.props.container;

      if (!container) {
        return 0;
      }
      return getScrollHeight(container);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  /**
   * Fetches additional items if needed.
   */


  createClass(ScrollFetch, [{
    key: 'componentDidMount',


    /**
     * Adds scroll listener after the component mounts.
     */
    value: function componentDidMount() {
      var _this2 = this;

      var container = this.props.container;

      if (!container) {
        return;
      }
      setTimeout(function () {
        _this2.setState(_extends({
          containerHeight: getElementHeight(container)
        }, _this2.getScrollState()));
      });
    }

    /**
     * Update scroll buffer and check after the component updates.
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      // setTimeout so the parent component can calculate renderHeight().
      this.updatePosition();
    }

    /**
     * Returns the scrollable content height.
     */

  }, {
    key: 'getScrollState',
    value: function getScrollState() {
      var _props = this.props,
          container = _props.container,
          renderHeight = _props.renderHeight;

      if (!container) {
        return null;
      }
      var scrollHeight = renderHeight || this.getScrollHeight;

      return {
        scrollHeight: scrollHeight(),
        scrollTop: getScrollPos(container)
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          containerHeight = _state.containerHeight,
          scrollHeight = _state.scrollHeight,
          scrollTop = _state.scrollTop;
      var _props2 = this.props,
          container = _props2.container,
          fetchMore = _props2.fetchMore,
          isAtEnd = _props2.isAtEnd,
          isFetching = _props2.isFetching;


      var props = {
        containerHeight: containerHeight,
        fetchMore: fetchMore,
        isAtEnd: isAtEnd,
        isFetching: isFetching,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      };

      if (!container || isAtEnd) {
        return null;
      }
      return React.createElement(
        ScrollContainer,
        {
          onScroll: this.updatePosition,
          scrollContainer: container
        },
        React.createElement(FetchItems, props)
      );
    }
  }]);
  return ScrollFetch;
}(React.PureComponent);


ScrollFetch.propTypes = {
  /**
   * The scroll container to use. Defaults to window.
   */
  container: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func
  }),
  renderHeight: PropTypes.func,
  isAtEnd: PropTypes.bool,
  isFetching: PropTypes.bool,
  fetchMore: PropTypes.func
};

ScrollFetch.defaultProps = {
  container: typeof window !== 'undefined' ? window : null
};

var styles$21 = { "input": "_xn _3r _56 _2u _2s _5s _tf _sc _sd _se _ti _si _5p _45", "clear": "_xo _5j _t7 _7q _7p _2j" };

var SearchField = function (_React$Component) {
  inherits(SearchField, _React$Component);

  function SearchField() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, SearchField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SearchField.__proto__ || Object.getPrototypeOf(SearchField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      hovered: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        value: event.currentTarget.value,
        syntheticEvent: event
      });
    }, _this.handleClear = function (event) {
      _this.props.onChange({
        value: '',
        syntheticEvent: event
      });
    }, _this.handleMouseEnter = function () {
      return _this.setState({ hovered: true });
    }, _this.handleMouseLeave = function () {
      return _this.setState({ hovered: false });
    }, _this.handleFocus = function (event) {
      _this.setState({ focused: true });

      if (_this.props.onFocus) {
        _this.props.onFocus({
          value: event.currentTarget.value,
          syntheticEvent: event
        });
      }
    }, _this.handleBlur = function (event) {
      _this.setState({ focused: false });

      if (_this.props.onBlur) {
        _this.props.onBlur({ event: event });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(SearchField, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityLabel = _props.accessibilityLabel,
          id = _props.id,
          placeholder = _props.placeholder,
          value = _props.value;

      // This mirrors the built in browser behavior. If there's a value, show the
      // clear button if you're hovering or if you've focused on the field

      var showClear = (this.state.focused || this.state.hovered) && value && value.length > 0;

      return React.createElement(
        Box,
        {
          display: 'flex',
          position: 'relative',
          alignItems: 'center',
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          color: 'white'
        },
        React.createElement(
          Box,
          {
            dangerouslySetInlineStyle: {
              __style: {
                pointerEvents: 'none',
                // Added the following lines for Safari support
                top: '50%',
                transform: 'translateY(-50%)'
              }
            },
            position: 'absolute',
            left: true,
            paddingX: 4
          },
          React.createElement(Icon, { icon: 'search', accessibilityLabel: '' })
        ),
        React.createElement('input', {
          'aria-label': accessibilityLabel,
          className: styles$21.input,
          id: id,
          onChange: this.handleChange,
          placeholder: placeholder,
          role: 'searchbox',
          type: 'search',
          value: value
        }),
        showClear && React.createElement(
          Box,
          { position: 'absolute', right: true, top: true },
          React.createElement(
            'button',
            {
              className: styles$21.clear,
              onClick: this.handleClear,
              tabIndex: -1,
              type: 'button'
            },
            React.createElement(Icon, { icon: 'clear', accessibilityLabel: '' })
          )
        )
      );
    }
  }]);
  return SearchField;
}(React.Component);

SearchField.propTypes = {
  accessibilityLabel: PropTypes.string.isRequired,
  id: PropTypes.string.isRequired,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  placeholder: PropTypes.string,
  value: PropTypes.string
};

var styles$22 = { "SegmentedControl": "_xp _2u _5p _2w _3f", "md": "_xq _2s", "lg": "_xr _2t", "item": "_xs _3r _3n _pb _5j _t7", "itemIsNotSelected": "_xt", "itemIsSelected": "_xu _5n" };

function SegmentedControl(props) {
  var _classnames;

  var items = props.items,
      onChange = props.onChange,
      selectedItemIndex = props.selectedItemIndex,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size;

  return React.createElement(
    'div',
    {
      className: classnames(styles$22.SegmentedControl, (_classnames = {}, defineProperty(_classnames, styles$22.md, size === 'md'), defineProperty(_classnames, styles$22.lg, size === 'lg'), _classnames)),
      role: 'tablist'
    },
    items.map(function (item, i) {
      var _classnames2;

      var isSelected = i === selectedItemIndex;
      var cs = classnames(styles$22.item, (_classnames2 = {}, defineProperty(_classnames2, styles$22.itemIsNotSelected, !isSelected), defineProperty(_classnames2, styles$22.itemIsSelected, isSelected), _classnames2));
      return React.createElement(
        'button',
        {
          'aria-selected': isSelected,
          className: cs,
          key: i,
          onClick: function onClick(e) {
            return onChange({ event: e, activeIndex: i });
          },
          role: 'tab',
          type: 'button'
        },
        typeof item === 'string' ? React.createElement(
          Text,
          {
            bold: true,
            color: isSelected ? 'darkGray' : 'gray',
            align: 'center',
            size: size
          },
          item
        ) : React.createElement(
          Box,
          { display: 'flex', justifyContent: 'center' },
          item
        )
      );
    })
  );
}

SegmentedControl.propTypes = {
  items: PropTypes.arrayOf(PropTypes.node).isRequired,
  onChange: PropTypes.func.isRequired,
  selectedItemIndex: PropTypes.number.isRequired
};

var styles$23 = { "select": "_xv _3r _tf _sc _sd _se _ti _5s _t7 _2j _2s _6i _45", "normal": "_xw", "errored": "_xx", "enabled": "_xy _5s _5n", "disabled": "_xz _5q _5p" };

var SelectList = function (_React$Component) {
  inherits(SelectList, _React$Component);

  function SelectList() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, SelectList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleOnChange = function (event) {
      if (event.target instanceof HTMLSelectElement && _this.props.value !== event.target.value) {
        _this.props.onChange({ event: event, value: event.target.value });

        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: false });
        }
      }
    }, _this.handleBlur = function () {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
    }, _this.handleFocus = function () {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(SelectList, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          options = _props.options,
          placeholder = _props.placeholder,
          value = _props.value;


      var classes = classnames(styles$23.select, disabled ? styles$23.disabled : styles$23.enabled, errorMessage ? styles$23.errored : styles$23.normal);

      return React.createElement(
        Box,
        {
          color: disabled ? 'lightGray' : 'white',
          dangerouslySetInlineStyle: { __style: { borderRadius: 4 } },
          display: 'flex',
          position: 'relative',
          width: '100%'
        },
        React.createElement(
          Box,
          {
            alignItems: 'center',
            bottom: true,
            dangerouslySetInlineStyle: {
              __style: { paddingRight: 14, paddingTop: 2 }
            },
            display: 'flex',
            position: 'absolute',
            right: true,
            top: true
          },
          React.createElement(Icon, {
            icon: 'arrow-down',
            size: 12,
            color: disabled ? 'gray' : 'darkGray',
            accessibilityLabel: ''
          })
        ),
        React.createElement(
          'select',
          {
            'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
            'aria-invalid': errorMessage ? 'true' : 'false',
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onFocus: this.handleFocus,
            onChange: this.handleOnChange,
            ref: function ref(c) {
              _this2.select = c;
            },
            value: value
          },
          placeholder && !value && React.createElement(
            'option',
            { selected: true, disabled: true, value: true, hidden: true },
            placeholder
          ),
          options.map(function (option) {
            return React.createElement(
              'option',
              { key: option.value, value: option.value },
              option.label
            );
          })
        ),
        errorMessage && this.state.errorIsOpen && React.createElement(
          Flyout,
          {
            anchor: this.select,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            size: 'sm'
          },
          React.createElement(
            Box,
            { padding: 3 },
            React.createElement(
              Text,
              { bold: true, color: 'white' },
              React.createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return SelectList;
}(React.Component);

SelectList.propTypes = {
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  options: PropTypes.arrayOf(PropTypes.exact({
    label: PropTypes.string.isRequired,
    value: PropTypes.string.isRequired
  })),
  placeholder: PropTypes.string,
  value: PropTypes.string
};
SelectList.defaultProps = {
  disabled: false,
  idealErrorDirection: 'right',
  options: []
};

var styles$24 = { "icon": "_y0 _29", "spin": "_y1" };

var SIZE = 40;

function Spinner(_ref) {
  var accessibilityLabel = _ref.accessibilityLabel,
      show = _ref.show;

  return show ? React.createElement(
    Box,
    { xs: { display: 'flex' }, justifyContent: 'around', overflow: 'hidden' },
    React.createElement(
      'div',
      { className: styles$24.icon },
      React.createElement(Icon, {
        icon: 'knoop',
        accessibilityLabel: accessibilityLabel,
        size: SIZE
      })
    )
  ) : React.createElement('div', null);
}

Spinner.propTypes = {
  show: PropTypes.bool.isRequired,
  accessibilityLabel: PropTypes.string.isRequired
};

function Sticky(props) {
  var _props$dangerouslySet = props.dangerouslySetZIndex,
      dangerouslySetZIndex = _props$dangerouslySet === undefined ? { __zIndex: 1 } : _props$dangerouslySet,
      children = props.children;

  var style = {
    top: props.top != null ? props.top : undefined,
    left: props.left != null ? props.left : undefined,
    right: props.right != null ? props.right : undefined,
    bottom: props.bottom != null ? props.bottom : undefined,
    // eslint-disable-next-line no-underscore-dangle
    zIndex: dangerouslySetZIndex.__zIndex
  };
  return React.createElement(
    'div',
    { className: layout.sticky, style: style },
    children
  );
}

Sticky.propTypes = {
  children: PropTypes.node,
  dangerouslySetZIndex: PropTypes.exact({
    __zIndex: PropTypes.number
  }),
  top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  right: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};

var styles$25 = { "switch": "_y2 _29 _2u _2j", "focused": "_y3 _3s", "switchDarkGray": "_y4 _5t", "switchGray": "_y5 _5r", "switchLightGray": "_y6 _5p", "switchWhite": "_y7 _5n", "slider": "_y8 _2u _2l _5n _5c", "sliderRight": "_y9", "sliderLeft": "_ya", "sliderDark": "_yb", "sliderLight": "_yc", "checkbox": "_yd _2l _45 _pb _5j _pg", "checkboxEnabled": "_ye _t7" };

var Switch = function (_React$Component) {
  inherits(Switch, _React$Component);

  function Switch() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Switch);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Switch.__proto__ || Object.getPrototypeOf(Switch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false
    }, _this.handleBlur = function () {
      return _this.setState({ focused: false });
    }, _this.handleChange = function (event) {
      var checked = event.target.checked;

      _this.props.onChange({
        event: event,
        value: checked
      });
    }, _this.handleFocus = function () {
      _this.setState({ focused: true });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Switch, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          disabled = _props.disabled,
          id = _props.id,
          name = _props.name,
          switched = _props.switched;


      var switchStyles = classnames(styles$25.switch, defineProperty({}, styles$25.focused, this.state.focused),
      // eslint-disable-next-line no-nested-ternary
      disabled ? switched ? styles$25.switchGray : styles$25.switchLightGray : switched ? styles$25.switchDarkGray : styles$25.switchWhite);

      var sliderStyles = classnames(styles$25.slider, switched ? styles$25.sliderRight : styles$25.sliderLeft, switched && !disabled ? styles$25.sliderDark : styles$25.sliderLight);

      var inputStyles = classnames(styles$25.checkbox, defineProperty({}, styles$25.checkboxEnabled, !disabled));

      return React.createElement(
        'div',
        { className: switchStyles },
        React.createElement('input', {
          checked: switched,
          className: inputStyles,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          type: 'checkbox'
        }),
        React.createElement('div', { className: sliderStyles })
      );
    }
  }]);
  return Switch;
}(React.Component);

Switch.propTypes = {
  disabled: PropTypes.bool,
  id: PropTypes.string.isRequired,
  name: PropTypes.string,
  onChange: PropTypes.func.isRequired,
  switched: PropTypes.bool
};
Switch.defaultProps = {
  disabled: false,
  switched: false
};

var styles$26 = { "Tabs": "_yf _2w", "tab": "_yg _3r _2u _2s _2w _30 undefined _3e _5j _5d _pb _t7", "tabIsNotActive": "_yh _6i _5q", "tabIsActive": "_yi _5p _5s" };

var Tabs = function (_React$Component) {
  inherits(Tabs, _React$Component);

  function Tabs() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Tabs);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focusedTabIndex: undefined,
      hoveredTabIndex: undefined
    }, _this.handleTabClick = function (i, e) {
      var onChange = _this.props.onChange;

      onChange({ activeTabIndex: i, event: e });
    }, _this.handleTabFocus = function (i) {
      return _this.setState({ focusedTabIndex: i });
    }, _this.handleTabBlur = function () {
      return _this.setState({ focusedTabIndex: undefined });
    }, _this.handleTabMouseEnter = function (i) {
      return _this.setState({ hoveredTabIndex: i });
    }, _this.handleTabMouseLeave = function () {
      return _this.setState({ hoveredTabIndex: undefined });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Tabs, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          tabs = _props.tabs,
          activeTabIndex = _props.activeTabIndex;
      var _state = this.state,
          focusedTabIndex = _state.focusedTabIndex,
          hoveredTabIndex = _state.hoveredTabIndex;

      return React.createElement(
        'div',
        { className: styles$26.Tabs, role: 'tablist' },
        tabs.map(function (_ref2, i) {
          var _classnames;

          var text = _ref2.text,
              href = _ref2.href;

          var isActive = i === activeTabIndex;
          var isHovered = i === hoveredTabIndex;
          var isFocused = i === focusedTabIndex;
          var cs = classnames(styles$26.tab, (_classnames = {}, defineProperty(_classnames, styles$26.tabIsNotActive, !isActive), defineProperty(_classnames, styles$26.tabIsActive, isActive), _classnames));
          return React.createElement(
            'a',
            {
              'aria-selected': isActive,
              className: cs,
              href: href,
              key: i,
              onClick: function onClick(e) {
                return _this2.handleTabClick(i, e);
              },
              onFocus: function onFocus() {
                return _this2.handleTabFocus(i);
              },
              onBlur: _this2.handleTabBlur,
              onMouseEnter: function onMouseEnter() {
                return _this2.handleTabMouseEnter(i);
              },
              onMouseLeave: _this2.handleTabMouseLeave,
              role: 'tab'
            },
            React.createElement(
              Text,
              {
                bold: true,
                color: isActive || isHovered || isFocused ? 'darkGray' : 'gray',
                size: 'md'
              },
              text
            )
          );
        })
      );
    }
  }]);
  return Tabs;
}(React.Component);

Tabs.propTypes = {
  activeTabIndex: PropTypes.number.isRequired,
  tabs: PropTypes.arrayOf(PropTypes.exact({
    text: PropTypes.node,
    href: PropTypes.string
  })).isRequired,
  onChange: PropTypes.func.isRequired
};

var styles$27 = { "textArea": "_yj _3r _2u _tf _sc _sd _se _ti _sg _45", "normal": "_yk", "errored": "_yl", "enabled": "_ym _5s _5n", "disabled": "_yn _5q _5p" };

var TextArea = function (_React$Component) {
  inherits(TextArea, _React$Component);

  function TextArea() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TextArea);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        event: event,
        value: event.currentTarget.value
      });

      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
    }, _this.handleBlur = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
      if (_this.props.onBlur) {
        _this.props.onBlur({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleFocus = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
      if (_this.props.onFocus) {
        _this.props.onFocus({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleKeyDown = function (event) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TextArea, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          hasError = _props.hasError,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          placeholder = _props.placeholder,
          rows = _props.rows,
          value = _props.value;


      var classes = classnames(styles$27.textArea, disabled ? styles$27.disabled : styles$27.enabled, hasError || errorMessage ? styles$27.errored : styles$27.normal);

      return React.createElement(
        'span',
        null,
        React.createElement('textarea', {
          'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
          'aria-invalid': errorMessage || hasError ? 'true' : 'false',
          className: classes,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          onKeyDown: this.handleKeyDown,
          placeholder: placeholder,
          ref: function ref(c) {
            _this2.textarea = c;
          },
          rows: rows,
          value: value
        }),
        errorMessage && this.state.errorIsOpen ? React.createElement(
          Flyout,
          {
            anchor: this.textarea,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            size: 'sm'
          },
          React.createElement(
            Box,
            { padding: 3 },
            React.createElement(
              Text,
              { bold: true, color: 'white' },
              React.createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        ) : null
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return TextArea;
}(React.Component);

TextArea.propTypes = {
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onKeyDown: PropTypes.func,
  placeholder: PropTypes.string,
  rows: PropTypes.number,
  value: PropTypes.string
};
TextArea.defaultProps = {
  disabled: false,
  hasError: false,
  idealErrorDirection: 'right',
  rows: 3
};

var styles$28 = { "textField": "_yo _3r _2u _2s _tf _sc _sd _se _ti _45", "normal": "_yp", "errored": "_yq", "enabled": "_yr _5s _5n", "disabled": "_ys _5q _5p" };

var TextField = function (_React$Component) {
  inherits(TextField, _React$Component);

  function TextField() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TextField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextField.__proto__ || Object.getPrototypeOf(TextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      focused: false,
      errorIsOpen: false
    }, _this.handleChange = function (event) {
      _this.props.onChange({
        event: event,
        value: event.currentTarget.value
      });
    }, _this.handleBlur = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: false });
      }
      if (_this.props.onBlur) {
        _this.props.onBlur({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleFocus = function (event) {
      if (_this.props.errorMessage) {
        _this.setState({ errorIsOpen: true });
      }
      if (_this.props.onFocus) {
        _this.props.onFocus({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _this.handleKeyDown = function (event) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown({
          event: event,
          value: event.currentTarget.value
        });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TextField, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          autoComplete = _props.autoComplete,
          disabled = _props.disabled,
          errorMessage = _props.errorMessage,
          hasError = _props.hasError,
          id = _props.id,
          idealErrorDirection = _props.idealErrorDirection,
          name = _props.name,
          placeholder = _props.placeholder,
          type = _props.type,
          value = _props.value;


      var classes = classnames(styles$28.textField, disabled ? styles$28.disabled : styles$28.enabled, hasError || errorMessage ? styles$28.errored : styles$28.normal);

      // type='number' doesn't work on ios safari without a pattern
      // https://stackoverflow.com/questions/14447668/input-type-number-is-not-showing-a-number-keypad-on-ios
      var pattern = type === 'number' ? '\\d*' : undefined;

      return React.createElement(
        'span',
        null,
        React.createElement('input', {
          'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
          'aria-invalid': errorMessage || hasError ? 'true' : 'false',
          autoComplete: autoComplete,
          className: classes,
          disabled: disabled,
          id: id,
          name: name,
          onBlur: this.handleBlur,
          onChange: this.handleChange,
          onFocus: this.handleFocus,
          onKeyDown: this.handleKeyDown,
          pattern: pattern,
          placeholder: placeholder,
          ref: function ref(c) {
            _this2.textfield = c;
          },
          type: type,
          value: value
        }),
        errorMessage && this.state.errorIsOpen && React.createElement(
          Flyout,
          {
            anchor: this.textfield,
            color: 'orange',
            idealDirection: idealErrorDirection,
            onDismiss: function onDismiss() {
              return _this2.setState({ errorIsOpen: false });
            },
            size: 'sm'
          },
          React.createElement(
            Box,
            { padding: 3 },
            React.createElement(
              Text,
              { bold: true, color: 'white' },
              React.createElement(
                'span',
                { id: id + '-gestalt-error' },
                errorMessage
              )
            )
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      if (props.errorMessage !== state.errorMessage) {
        return {
          errorIsOpen: !!props.errorMessage,
          errorMessage: props.errorMessage
        };
      }

      return null;
    }
  }]);
  return TextField;
}(React.Component);

TextField.propTypes = {
  autoComplete: PropTypes.oneOf(['current-password', 'on', 'off', 'username']),
  disabled: PropTypes.bool,
  errorMessage: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string.isRequired,
  idealErrorDirection: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func.isRequired,
  onFocus: PropTypes.func,
  onKeyDown: PropTypes.func,
  placeholder: PropTypes.string,
  type: PropTypes.oneOf(['date', 'email', 'number', 'password', 'text', 'url']),
  value: PropTypes.string
};
TextField.defaultProps = {
  disabled: false,
  hasError: false,
  idealErrorDirection: 'right',
  type: 'text'
};

function Toast(props) {
  var _props$color = props.color,
      color = _props$color === undefined ? 'darkGray' : _props$color,
      icon = props.icon,
      thumbnail = props.thumbnail,
      text = props.text;


  var contents = void 0;
  // Confirmation Toasts
  if (text instanceof Array && text.length > 1) {
    contents = React.createElement(
      Box,
      { xs: { display: 'flex' } },
      React.createElement(
        Box,
        { xs: { display: 'flexColumn' }, flex: 'none', justifyContent: 'center' },
        thumbnail ? React.createElement(
          Mask,
          { shape: 'rounded', height: 48, width: 48 },
          thumbnail
        ) : null
      ),
      React.createElement(
        Box,
        {
          xs: { display: 'flexColumn' },
          justifyContent: 'center',
          dangerouslySetInlineStyle: { __style: { paddingLeft: 10 } }
        },
        React.createElement(
          Box,
          {
            dangerouslySetInlineStyle: { __style: { fontWeight: 'normal' } }
          },
          React.createElement(
            Text,
            { color: 'white', size: 'lg' },
            text[0]
          )
        ),
        React.createElement(
          Text,
          { bold: true, color: 'white', size: 'lg' },
          text[1]
        )
      )
    );
  } else {
    // Toasts as Guides
    contents = React.createElement(
      Box,
      {
        xs: { display: 'flex' },
        justifyContent: 'between',
        alignItems: 'center'
      },
      React.createElement(
        Text,
        { bold: true, color: 'white', size: 'lg' },
        text
      ),
      icon && React.createElement(
        Box,
        { dangerouslySetInlineStyle: { __style: { paddingLeft: 24 } } },
        React.createElement(Icon, { accessibilityLabel: '', color: 'white', icon: icon, size: 36 })
      )
    );
  }

  return React.createElement(
    Box,
    { marginBottom: 3, paddingX: 4, maxWidth: 376, width: '100vw' },
    React.createElement(
      Box,
      { color: color, fit: true, paddingX: 8, paddingY: 5, shape: 'pill' },
      contents
    )
  );
}

Toast.propTypes = {
  color: PropTypes.oneOf(['darkGray', 'orange']),
  icon: PropTypes.oneOf(['arrow-circle-forward']), // leaving open to additional icons in the future
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,
  thumbnail: PropTypes.node
};

function Tooltip(props) {
  var anchor = props.anchor,
      children = props.children,
      idealDirection = props.idealDirection,
      onDismiss = props.onDismiss,
      _props$positionRelati = props.positionRelativeToAnchor,
      positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
      _props$size = props.size,
      size = _props$size === undefined ? 'md' : _props$size;


  if (!anchor) {
    return null;
  }

  return React.createElement(
    Controller,
    {
      anchor: anchor,
      bgColor: 'darkGray',
      idealDirection: idealDirection,
      positionRelativeToAnchor: positionRelativeToAnchor,
      onDismiss: onDismiss,
      size: size
    },
    React.createElement(
      Box,
      { column: 12, padding: 3 },
      children
    )
  );
}

Tooltip.propTypes = {
  anchor: PropTypes.shape({
    contains: PropTypes.func,
    getBoundingClientRect: PropTypes.func
  }),
  children: PropTypes.node,
  idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
  onDismiss: PropTypes.func.isRequired,
  positionRelativeToAnchor: PropTypes.bool,
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
};

var styles$29 = { "touchable": "_yt _3r", "fullHeight": "_yu", "fullWidth": "_yv _45", "square": "_yw _5b", "circle": "_yx _5c", "rounded": "_yy _5e", "roundedTop": "_yz _5f", "roundedRight": "_z0 _5g", "roundedBottom": "_z1 _5h", "roundedLeft": "_z2 _5i", "pill": "_z3 _5d", "pointer": "_z4 _t7", "zoomIn": "_z5 _t8", "zoomOut": "_z6 _t9", "copy": "_z7 _ta", "move": "_z8 _tb", "noDrop": "_z9 _tc", "grab": "_za _td", "grabbing": "_zb _te" };

var SPACE_CHAR_CODE = 32;
var ENTER_CHAR_CODE = 13;

var Touchable = function (_React$Component) {
  inherits(Touchable, _React$Component);

  function Touchable() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Touchable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Touchable.__proto__ || Object.getPrototypeOf(Touchable)).call.apply(_ref, [this].concat(args))), _this), _this.handleKeyPress = function (event) {
      var onTouch = _this.props.onTouch;
      // Check to see if space or enter were pressed

      if (onTouch && (event.charCode === SPACE_CHAR_CODE || event.charCode === ENTER_CHAR_CODE)) {
        // Prevent the default action to stop scrolling when space is pressed
        event.preventDefault();
        onTouch({ event: event });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Touchable, [{
    key: 'render',
    value: function render() {
      var _classnames;

      var _props = this.props,
          children = _props.children,
          _props$fullWidth = _props.fullWidth,
          fullWidth = _props$fullWidth === undefined ? true : _props$fullWidth,
          fullHeight = _props.fullHeight,
          _props$mouseCursor = _props.mouseCursor,
          mouseCursor = _props$mouseCursor === undefined ? 'pointer' : _props$mouseCursor,
          onMouseEnter = _props.onMouseEnter,
          onMouseLeave = _props.onMouseLeave,
          onTouch = _props.onTouch,
          _props$shape = _props.shape,
          shape = _props$shape === undefined ? 'square' : _props$shape;


      var classes = classnames(styles$29.touchable, styles$29[mouseCursor], styles$29[shape], (_classnames = {}, defineProperty(_classnames, styles$29.fullHeight, fullHeight), defineProperty(_classnames, styles$29.fullWidth, fullWidth), _classnames));

      return React.createElement(
        'div',
        {
          className: classes,
          onClick: function onClick(event) {
            return onTouch && onTouch({ event: event });
          },
          onMouseEnter: function (_onMouseEnter) {
            function onMouseEnter(_x) {
              return _onMouseEnter.apply(this, arguments);
            }

            onMouseEnter.toString = function () {
              return _onMouseEnter.toString();
            };

            return onMouseEnter;
          }(function (event) {
            return onMouseEnter && onMouseEnter({ event: event });
          }),
          onMouseLeave: function (_onMouseLeave) {
            function onMouseLeave(_x2) {
              return _onMouseLeave.apply(this, arguments);
            }

            onMouseLeave.toString = function () {
              return _onMouseLeave.toString();
            };

            return onMouseLeave;
          }(function (event) {
            return onMouseLeave && onMouseLeave({ event: event });
          }),
          onKeyPress: this.handleKeyPress,
          role: 'button',
          tabIndex: '0'
        },
        children
      );
    }
  }]);
  return Touchable;
}(React.Component);


Touchable.propTypes = {
  children: PropTypes.node,
  fullHeight: PropTypes.bool,
  fullWidth: PropTypes.bool,
  mouseCursor: PropTypes.oneOf(['copy', 'grab', 'grabbing', 'move', 'noDrop', 'pointer', 'zoomIn', 'zoomOut']),
  onTouch: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight'])
};

var styles$30 = { "video": "_zc _29 _2l _45", "player": "_zd _2j _45", "playhead": "_ze _2w _34 _45 _t7", "controls": "_zf _2l _2w _34 _2p _2q _2o _7c _7b" };

var VideoPlayhead = function (_React$PureComponent) {
  inherits(VideoPlayhead, _React$PureComponent);

  function VideoPlayhead() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, VideoPlayhead);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoPlayhead.__proto__ || Object.getPrototypeOf(VideoPlayhead)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      seeking: false
    }, _this.setPlayheadRef = function (ref) {
      _this.playhead = ref;
    }, _this.seek = function (clientX) {
      if (_this.playhead) {
        var _this$props = _this.props,
            _duration = _this$props.duration,
            _seek = _this$props.seek;

        var _this$playhead$getBou = _this.playhead.getBoundingClientRect(),
            left = _this$playhead$getBou.left,
            width = _this$playhead$getBou.width;

        var percent = Math.max(0, Math.min((clientX - left) / width, 1));
        var newTime = percent * _duration;
        _seek(newTime);
      }
    }, _this.stopClick = function (event) {
      return event.stopPropagation();
    }, _this.handleMouseDown = function (event) {
      _this.setState({ seeking: true });
      _this.seek(event.clientX);
    }, _this.handleMouseMove = function (event) {
      var seeking = _this.state.seeking;

      if (seeking) {
        _this.seek(event.clientX);
      }
    }, _this.handleMouseUp = function () {
      _this.setState({ seeking: false });
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(VideoPlayhead, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          currentTime = _props.currentTime,
          duration = _props.duration;

      var width = Math.floor(currentTime * 10000 / duration) / 100 + '%';
      return React.createElement(
        Box,
        {
          position: 'relative',
          display: 'flex',
          flex: 'grow',
          alignItems: 'center',
          height: 16
        },
        React.createElement(
          'div',
          {
            'aria-valuemax': duration,
            'aria-valuemin': '0',
            'aria-valuenow': currentTime,
            className: styles$30.playhead,
            onClick: this.stopClick,
            onKeyPress: this.stopClick,
            onMouseDown: this.handleMouseDown,
            onMouseMove: this.handleMouseMove,
            onMouseUp: this.handleMouseUp,
            ref: this.setPlayheadRef,
            role: 'progressbar',
            tabIndex: '-1'
          },
          React.createElement(
            Box,
            {
              left: true,
              right: true,
              position: 'absolute',
              color: 'lightGray',
              shape: 'rounded',
              height: 4
            },
            React.createElement(Box, { color: 'white', shape: 'rounded', height: '100%', width: width })
          ),
          React.createElement(
            Box,
            {
              position: 'absolute',
              shape: 'rounded',
              height: 4,
              dangerouslySetInlineStyle: { __style: { left: width } }
            },
            React.createElement(Box, {
              shape: 'circle',
              width: 16,
              height: 16,
              color: 'white',
              marginLeft: -2,
              dangerouslySetInlineStyle: { __style: { marginTop: -6 } }
            })
          )
        )
      );
    }
  }]);
  return VideoPlayhead;
}(React.PureComponent);

VideoPlayhead.propTypes = {
  currentTime: PropTypes.number.isRequired,
  duration: PropTypes.number.isRequired,
  seek: PropTypes.func.isRequired
};

var fullscreenEnabled = function fullscreenEnabled() {
  return (
    // $FlowIssue - vendor prefix missing from Flow
    document.fullscreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitFullscreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.mozFullScreenEnabled ||
    // $FlowIssue - vendor prefix missing from Flow
    document.msFullscreenEnabled
  );
};

var timeToString = function timeToString(time) {
  var rounded = Math.floor(time || 0);
  var minutes = Math.floor(rounded / 60);
  var seconds = rounded - minutes * 60;
  var minutesStr = minutes < 10 ? '0' + minutes : minutes;
  var secondsStr = seconds < 10 ? '0' + seconds : seconds;
  return minutesStr + ':' + secondsStr;
};

var VideoControls = function (_React$Component) {
  inherits(VideoControls, _React$Component);

  function VideoControls() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, VideoControls);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoControls.__proto__ || Object.getPrototypeOf(VideoControls)).call.apply(_ref, [this].concat(args))), _this), _this.handleFullscreenChange = function (_ref2) {
      var event = _ref2.event;
      var onFullscreenChange = _this.props.onFullscreenChange;

      event.stopPropagation();
      onFullscreenChange();
    }, _this.handlePlayingChange = function (_ref3) {
      var event = _ref3.event;
      var _this$props = _this.props,
          playing = _this$props.playing,
          onPause = _this$props.onPause,
          onPlay = _this$props.onPlay;

      if (playing) {
        onPause(event);
      } else {
        onPlay(event);
      }
    }, _this.handleVolumeChange = function (_ref4) {
      var event = _ref4.event;
      var onVolumeChange = _this.props.onVolumeChange;

      onVolumeChange(event);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(VideoControls, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          accessibilityMaximizeLabel = _props.accessibilityMaximizeLabel,
          accessibilityMinimizeLabel = _props.accessibilityMinimizeLabel,
          accessibilityMuteLabel = _props.accessibilityMuteLabel,
          accessibilityPauseLabel = _props.accessibilityPauseLabel,
          accessibilityPlayLabel = _props.accessibilityPlayLabel,
          accessibilityUnmuteLabel = _props.accessibilityUnmuteLabel,
          currentTime = _props.currentTime,
          duration = _props.duration,
          fullscreen = _props.fullscreen,
          playing = _props.playing,
          seek = _props.seek,
          volume = _props.volume;

      var muted = volume === 0;
      var showFullscreenButton = typeof document !== 'undefined' && !!fullscreenEnabled();
      return React.createElement(
        'div',
        { className: styles$30.controls },
        React.createElement(
          Box,
          { padding: 2 },
          React.createElement(
            Touchable,
            { onTouch: this.handlePlayingChange, fullWidth: false },
            React.createElement(Icon, {
              accessibilityLabel: playing ? accessibilityPauseLabel : accessibilityPlayLabel,
              color: 'white',
              icon: playing ? 'pause' : 'play',
              size: 20
            })
          )
        ),
        React.createElement(
          Box,
          { width: 50, padding: 2 },
          React.createElement(
            Text,
            { color: 'white', align: 'right', size: 'xs' },
            timeToString(currentTime)
          )
        ),
        React.createElement(
          Box,
          { padding: 2, flex: 'grow' },
          React.createElement(VideoPlayhead, {
            currentTime: currentTime,
            duration: duration,
            seek: seek
          })
        ),
        React.createElement(
          Box,
          { width: 50, padding: 2 },
          React.createElement(
            Text,
            { color: 'white', align: 'right', size: 'xs' },
            timeToString(duration)
          )
        ),
        React.createElement(
          Box,
          { padding: 2 },
          React.createElement(
            Touchable,
            { onTouch: this.handleVolumeChange, fullWidth: false },
            React.createElement(Icon, {
              accessibilityLabel: muted ? accessibilityUnmuteLabel : accessibilityMuteLabel,
              color: 'white',
              icon: muted ? 'mute' : 'sound',
              size: 20
            })
          )
        ),
        showFullscreenButton && React.createElement(
          Box,
          { padding: 2 },
          React.createElement(
            Touchable,
            { onTouch: this.handleFullscreenChange, fullWidth: false },
            React.createElement(Icon, {
              accessibilityLabel: fullscreen ? accessibilityMinimizeLabel : accessibilityMaximizeLabel,
              color: 'white',
              icon: fullscreen ? 'minimize' : 'maximize',
              size: 20
            })
          )
        )
      );
    }
  }]);
  return VideoControls;
}(React.Component);

VideoControls.propTypes = {
  accessibilityMaximizeLabel: PropTypes.string.isRequired,
  accessibilityMinimizeLabel: PropTypes.string.isRequired,
  accessibilityMuteLabel: PropTypes.string.isRequired,
  accessibilityPauseLabel: PropTypes.string.isRequired,
  accessibilityPlayLabel: PropTypes.string.isRequired,
  accessibilityUnmuteLabel: PropTypes.string.isRequired,
  currentTime: PropTypes.number.isRequired,
  duration: PropTypes.number.isRequired,
  fullscreen: PropTypes.bool.isRequired,
  onFullscreenChange: PropTypes.func.isRequired,
  onPause: PropTypes.func.isRequired,
  onPlay: PropTypes.func.isRequired,
  onVolumeChange: PropTypes.func.isRequired,
  playing: PropTypes.bool.isRequired,
  seek: PropTypes.func.isRequired,
  volume: PropTypes.number.isRequired
};

// For more information on fullscreen and vendor prefixes see
// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API

var requestFullscreen = function requestFullscreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.webkitRequestFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.webkitRequestFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.mozRequestFullScreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.mozRequestFullScreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (element.msRequestFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    element.msRequestFullscreen();
  }
};

var exitFullscreen = function exitFullscreen() {
  // $FlowIssue - vendor prefix missing from Flow
  if (document.exitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.exitFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.webkitExitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitExitFullscreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.mozCancelFullScreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.mozCancelFullScreen();
    // $FlowIssue - vendor prefix missing from Flow
  } else if (document.msExitFullscreen) {
    // $FlowIssue - vendor prefix missing from Flow
    document.msExitFullscreen();
  }
};

// Normally document.fullscreen suffices here as a flag, but IE11 does not
// have a vendor specific version so we must instead use the actual element
var isFullscreen = function isFullscreen() {
  return (
    // $FlowIssue - vendor prefix missing from Flow
    document.fullscreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.webkitFullscreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.mozFullScreenElement ||
    // $FlowIssue - vendor prefix missing from Flow
    document.msFullscreenElement
  );
};

var addFullscreenEventListener = function addFullscreenEventListener(listener) {
  document.addEventListener('fullscreenchange', listener);
  document.addEventListener('webkitfullscreenchange', listener);
  document.addEventListener('mozfullscreenchange', listener);
  document.addEventListener('MSFullscreenChange', listener);
};

var removeFullscreenEventListener = function removeFullscreenEventListener(listener) {
  document.removeEventListener('fullscreenchange', listener);
  document.removeEventListener('webkitfullscreenchange', listener);
  document.removeEventListener('mozfullscreenchange', listener);
  document.removeEventListener('MSFullscreenChange', listener);
};

var isNewSource = function isNewSource(oldSource, newSource) {
  if ((typeof oldSource === 'undefined' ? 'undefined' : _typeof(oldSource)) !== (typeof newSource === 'undefined' ? 'undefined' : _typeof(newSource))) {
    // If the source type changed from string to Array
    // or vice versa, we have a new source
    return true;
  }
  if (Array.isArray(newSource)) {
    if (oldSource.length !== newSource.length) {
      // If the sources are both an Array, and the lengths
      // do not match we evaluate as a new source
      return true;
    }
    // If the sources are both an Array and the same length,
    // verify every element stayed the same
    return newSource.some(function (source, index) {
      return !Array.isArray(oldSource) || source.type !== oldSource[index].type || source.src !== oldSource[index].src;
    });
  }
  // If the sources are both a string, simply compare
  // the new with the old
  return newSource !== oldSource;
};

var Video = function (_React$PureComponent) {
  inherits(Video, _React$PureComponent);

  function Video() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, Video);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Video.__proto__ || Object.getPrototypeOf(Video)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      currentTime: 0,
      duration: 0,
      fullscreen: false
    }, _this.setPlayerRef = function (ref) {
      _this.player = ref;
    }, _this.setVideoRef = function (ref) {
      _this.video = ref;
    }, _this.setPlaybackRate = function (playbackRate) {
      if (_this.video) {
        _this.video.playbackRate = playbackRate;
      }
    }, _this.setVolume = function (volume) {
      if (_this.video) {
        _this.video.volume = volume;
      }
    }, _this.load = function () {
      if (_this.video) {
        _this.video.load();
      }
    }, _this.pause = function () {
      if (_this.video) {
        _this.video.pause();
      }
    }, _this.play = function () {
      if (_this.video) {
        _this.video.play();
      }
    }, _this.seek = function (time) {
      if (_this.video) {
        _this.video.currentTime = time;
      }
    }, _this.toggleFullscreen = function () {
      if (isFullscreen()) {
        exitFullscreen();
      } else if (_this.player) {
        requestFullscreen(_this.player);
      }
    }, _this.handleCanPlay = function (event) {
      var onReady = _this.props.onReady;


      if (onReady) {
        onReady({ event: event });
      }
    }, _this.handleDurationChange = function (event) {
      var onDurationChange = _this.props.onDurationChange;

      var duration = _this.video && _this.video.duration || 0;
      _this.setState({ duration: duration });

      if (onDurationChange) {
        onDurationChange({ event: event, duration: duration });
      }
    }, _this.handleEnded = function (event) {
      var onEnded = _this.props.onEnded;


      if (onEnded) {
        onEnded({ event: event });
      }
    }, _this.handleFullscreenChange = function (event) {
      var onFullscreenChange = _this.props.onFullscreenChange;

      var fullscreen = !!isFullscreen();
      _this.setState({ fullscreen: fullscreen });

      if (onFullscreenChange) {
        onFullscreenChange({ event: event, fullscreen: fullscreen });
      }
    }, _this.handlePlay = function (event) {
      var onPlay = _this.props.onPlay;


      if (onPlay) {
        onPlay({ event: event });
      }
    }, _this.handlePause = function (event) {
      var onPause = _this.props.onPause;


      if (onPause) {
        onPause({ event: event });
      }
    }, _this.handleProgress = function (event) {
      var onLoadedChange = _this.props.onLoadedChange;

      var _ref2 = _this.video || {},
          buffered = _ref2.buffered;

      var loaded = buffered && buffered.length > 0 ? buffered.end(buffered.length - 1) : 0;

      if (onLoadedChange) {
        onLoadedChange({ event: event, loaded: loaded });
      }
    }, _this.handleSeek = function (event) {
      var onSeek = _this.props.onSeek;


      if (onSeek) {
        onSeek({ event: event });
      }
    }, _this.handleTimeUpdate = function (event) {
      var onTimeChange = _this.props.onTimeChange;

      var currentTime = _this.video && _this.video.currentTime || 0;
      _this.setState({ currentTime: currentTime });

      if (onTimeChange) {
        onTimeChange({ event: event, time: currentTime });
      }
    }, _this.handleVolumeChange = function (event) {
      var onVolumeChange = _this.props.onVolumeChange;

      var muted = _this.video && _this.video.muted || false;

      if (onVolumeChange) {
        onVolumeChange({ event: event, volume: muted ? 1 : 0 });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(Video, [{
    key: 'componentDidMount',


    /**
     * React lifecycle hooks pertinent to Video
     */

    value: function componentDidMount() {
      var _props = this.props,
          playbackRate = _props.playbackRate,
          playing = _props.playing,
          volume = _props.volume;
      // Set up event listeners to catch backdoors in fullscreen
      // changes such as using the ESC key to exit

      if (typeof document !== 'undefined') {
        addFullscreenEventListener(this.handleFullscreenChange);
      }
      // Load the video to hydrate the DOM after a server render
      this.load();
      // Set the initial volume
      this.setVolume(volume);
      // Set the initial playback rate
      this.setPlaybackRate(playbackRate);
      // Simulate an autoplay effect if the component
      if (playing) {
        this.play();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      // If the video source changed, reload the video
      if (isNewSource(prevProps.src, this.props.src)) {
        this.load();
      }
      // If the volume changed, set the new volume
      if (prevProps.volume !== this.props.volume) {
        this.setVolume(this.props.volume);
      }
      // If the playback rate changed, set the new rate
      if (prevProps.playbackRate !== this.props.playbackRate) {
        this.setPlaybackRate(this.props.playbackRate);
      }
      // If the playback changed, play or pause the video
      if (prevProps.playing !== this.props.playing) {
        if (this.props.playing) {
          this.play();
        } else {
          this.pause();
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      removeFullscreenEventListener(this.handleFullscreenChange);
    }

    /**
     * DOM reference housekeeping that is needed for functionality
     */

    // The player element encapsulates the actual video DOM
    // element as well as the controls to bring both fullscreen


    // The actual reference to the video HTML DOM element


    /**
     * Functions that directly interact with the HTML video element
     */

    // Set the video to the desired playback rate: 1 (normal)


    // Set the video to the desired volume: 0 (muted) -> 1 (max)


    // Change the video source and re-load the video


    // Pause the video


    // Play the video


    // Seek the video to the desired time


    // Enter/exit fullscreen video player mode


    /**
     * Handlers for various media events on the video
     */

    // Sent when enough data is available that the media can be played


    // The metadata has loaded or changed, indicating a change in
    // duration of the media


    // Sent when playback completes.


    // Sent when the video is switched to/out-of fullscreen mode


    // Sent when playback of the media starts after having been paused.


    // Sent when playback is paused.


    // Sent periodically to inform interested parties of progress downloading the media


    // Sent when a seek operation completes.


    // The time indicated by the element's currentTime attribute has changed


    // Sent when the audio volume changes

  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          aspectRatio = _props2.aspectRatio,
          captions = _props2.captions,
          loop = _props2.loop,
          playing = _props2.playing,
          playsInline = _props2.playsInline,
          poster = _props2.poster,
          preload = _props2.preload,
          src = _props2.src,
          volume = _props2.volume;
      var _state = this.state,
          currentTime = _state.currentTime,
          duration = _state.duration,
          fullscreen = _state.fullscreen;


      var paddingBottom = fullscreen && '0' || 1 / aspectRatio * 100 + '%';

      return React.createElement(
        'div',
        {
          ref: this.setPlayerRef,
          className: styles$30.player,
          style: { paddingBottom: paddingBottom, height: fullscreen ? '100%' : 0 }
        },
        React.createElement(
          'video',
          {
            autoPlay: playing,
            loop: loop,
            muted: volume === 0,
            playsInline: playsInline,
            poster: poster,
            preload: preload,
            src: typeof src === 'string' ? src : undefined,
            ref: this.setVideoRef,
            className: styles$30.video,
            onCanPlay: this.handleCanPlay,
            onDurationChange: this.handleDurationChange,
            onEnded: this.handleEnded,
            onSeeked: this.handleSeek,
            onTimeUpdate: this.handleTimeUpdate,
            onProgress: this.handleProgress
          },
          Array.isArray(src) && src.map(function (source) {
            return React.createElement('source', { key: source.src, src: source.src, type: source.type });
          }),
          React.createElement('track', { kind: 'captions', src: captions })
        ),
        this.props.controls && React.createElement(VideoControls, {
          accessibilityMaximizeLabel: this.props.accessibilityMaximizeLabel,
          accessibilityMinimizeLabel: this.props.accessibilityMinimizeLabel,
          accessibilityMuteLabel: this.props.accessibilityMuteLabel,
          accessibilityPauseLabel: this.props.accessibilityPauseLabel,
          accessibilityPlayLabel: this.props.accessibilityPlayLabel,
          accessibilityUnmuteLabel: this.props.accessibilityUnmuteLabel,
          currentTime: currentTime,
          duration: duration,
          fullscreen: fullscreen,
          onPlay: this.handlePlay,
          onPause: this.handlePause,
          onFullscreenChange: this.toggleFullscreen,
          onVolumeChange: this.handleVolumeChange,
          playing: playing,
          seek: this.seek,
          volume: volume
        })
      );
    }
  }]);
  return Video;
}(React.PureComponent);

Video.propTypes = {
  accessibilityMaximizeLabel: PropTypes.string,
  accessibilityMinimizeLabel: PropTypes.string,
  accessibilityMuteLabel: PropTypes.string,
  accessibilityPauseLabel: PropTypes.string,
  accessibilityPlayLabel: PropTypes.string,
  accessibilityUnmuteLabel: PropTypes.string,
  aspectRatio: PropTypes.number.isRequired,
  captions: PropTypes.string.isRequired,
  controls: PropTypes.bool,
  loop: PropTypes.bool,
  onDurationChange: PropTypes.func,
  onEnded: PropTypes.func,
  onFullscreenChange: PropTypes.func,
  onLoadedChange: PropTypes.func,
  onPlay: PropTypes.func,
  onPause: PropTypes.func,
  onReady: PropTypes.func,
  onSeek: PropTypes.func,
  onTimeChange: PropTypes.func,
  onVolumeChange: PropTypes.func,
  playbackRate: PropTypes.number,
  playing: PropTypes.bool,
  playsInline: PropTypes.bool,
  poster: PropTypes.string,
  preload: PropTypes.oneOf(['auto', 'metadata', 'none']),
  src: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.shape({
    type: PropTypes.oneOf(['video/m3u8', 'video/mp4', 'video/ogg']).isRequired,
    src: PropTypes.string.isRequired
  }))]).isRequired,
  volume: PropTypes.number
};
Video.defaultProps = {
  playbackRate: 1,
  playing: false,
  preload: 'auto',
  volume: 1
};

exports.Avatar = Avatar;
exports.Box = Box;
exports.Button = Button;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.Collage = Collage;
exports.Collection = Collection;
exports.Column = Column;
exports.Container = Container;
exports.Divider = Divider;
exports.Flyout = Flyout;
exports.GroupAvatar = GroupAvatar;
exports.Heading = Heading;
exports.Icon = Icon;
exports.IconButton = IconButton;
exports.Image = Image;
exports.Label = Label;
exports.Layer = Layer;
exports.Letterbox = Letterbox;
exports.Link = Link;
exports.Mask = Mask;
exports.Masonry = MasonryInfinite;
exports.MasonryBeta = Masonry;
exports.MasonryDefaultLayout = MasonryLayout;
exports.MasonryUniformRowLayout = UniformRowLayout;
exports.Modal = Modal;
exports.Pog = Pog;
exports.Pulsar = Pulsar;
exports.RadioButton = RadioButton;
exports.ScrollFetch = ScrollFetch;
exports.SearchField = SearchField;
exports.SegmentedControl = SegmentedControl;
exports.SelectList = SelectList;
exports.Spinner = Spinner;
exports.Sticky = Sticky;
exports.Switch = Switch;
exports.Tabs = Tabs;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextField = TextField;
exports.Toast = Toast;
exports.Tooltip = Tooltip;
exports.Touchable = Touchable;
exports.Video = Video;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdGFsdC5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3N0eWxlLmpzIiwiLi4vc3JjL3RyYW5zZm9ybXMuanMiLCIuLi9zcmMvQm94LmpzIiwiLi4vc3JjL2ljb25zL2luZGV4LmpzIiwiLi4vc3JjL0ljb24uanMiLCIuLi9zcmMvSW1hZ2UuanMiLCIuLi9zcmMvTWFzay5qcyIsIi4uL3NyYy9BdmF0YXIuanMiLCIuLi9zcmMvVGV4dC5qcyIsIi4uL3NyYy9CdXR0b24uanMiLCIuLi9zcmMvQ2FyZC5qcyIsIi4uL3NyYy9DaGVja2JveC5qcyIsIi4uL3NyYy9Db2xsZWN0aW9uLmpzIiwiLi4vc3JjL0NvbGxhZ2UuanMiLCIuLi9zcmMvQ29sdW1uLmpzIiwiLi4vc3JjL0NvbnRhaW5lci5qcyIsIi4uL3NyYy9EaXZpZGVyLmpzIiwiLi4vc3JjL0NhcmV0LmpzIiwiLi4vc3JjL0NvbnRlbnRzLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyIsIi4uL3NyYy9Db250cm9sbGVyLmpzIiwiLi4vc3JjL0ZseW91dC5qcyIsIi4uL3NyYy9Hcm91cEF2YXRhci5qcyIsIi4uL3NyYy9IZWFkaW5nLmpzIiwiLi4vc3JjL1BvZy5qcyIsIi4uL3NyYy9JY29uQnV0dG9uLmpzIiwiLi4vc3JjL0xhYmVsLmpzIiwiLi4vc3JjL0xheWVyLmpzIiwiLi4vc3JjL0xldHRlcmJveC5qcyIsIi4uL3NyYy9MaW5rLmpzIiwiLi4vc3JjL0ZldGNoSXRlbXMuanMiLCIuLi9zcmMvTWVhc3VyZW1lbnRTdG9yZS5qcyIsIi4uL3NyYy9kZWJvdW5jZS5qcyIsIi4uL3NyYy9TY3JvbGxDb250YWluZXIuanMiLCIuLi9zcmMvdGhyb3R0bGUuanMiLCIuLi9zcmMvc2Nyb2xsVXRpbHMuanMiLCIuLi9zcmMvbGVnYWN5TGF5b3V0U3ltYm9scy5qcyIsIi4uL3NyYy9kZWZhdWx0TGF5b3V0LmpzIiwiLi4vc3JjL3VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvZnVsbFdpZHRoTGF5b3V0LmpzIiwiLi4vc3JjL2xheW91dHMvTWFzb25yeUxheW91dC5qcyIsIi4uL3NyYy9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvTWFzb25yeS5qcyIsIi4uL3NyYy9NYXNvbnJ5SW5maW5pdGUuanMiLCIuLi9zcmMvYmVoYXZpb3JzL1N0b3BTY3JvbGxCZWhhdmlvci5qcyIsIi4uL3NyYy9iZWhhdmlvcnMvVHJhcEZvY3VzQmVoYXZpb3IuanMiLCIuLi9zcmMvTW9kYWwuanMiLCIuLi9zcmMvUHVsc2FyLmpzIiwiLi4vc3JjL1JhZGlvQnV0dG9uLmpzIiwiLi4vc3JjL1Njcm9sbEZldGNoLmpzIiwiLi4vc3JjL1NlYXJjaEZpZWxkLmpzIiwiLi4vc3JjL1NlZ21lbnRlZENvbnRyb2wuanMiLCIuLi9zcmMvU2VsZWN0TGlzdC5qcyIsIi4uL3NyYy9TcGlubmVyLmpzIiwiLi4vc3JjL1N0aWNreS5qcyIsIi4uL3NyYy9Td2l0Y2guanMiLCIuLi9zcmMvVGFicy5qcyIsIi4uL3NyYy9UZXh0QXJlYS5qcyIsIi4uL3NyYy9UZXh0RmllbGQuanMiLCIuLi9zcmMvVG9hc3QuanMiLCIuLi9zcmMvVG9vbHRpcC5qcyIsIi4uL3NyYy9Ub3VjaGFibGUuanMiLCIuLi9zcmMvVmlkZW9QbGF5aGVhZC5qcyIsIi4uL3NyYy9WaWRlb0NvbnRyb2xzLmpzIiwiLi4vc3JjL1ZpZGVvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbi8qXG5cblN0eWxlIGlzIGEgbW9ub2lkIHRoYXQgY2FwdHVyZSB0aGUgXCJ0by1iZS1hcHBsaWVkXCIgc3R5bGVzIChpbmxpbmUgYW5kIGNsYXNzZXMpXG5mb3IgYSBCb3guIEl0J3MgYmFzaWNhbGx5IHNldCB0aGF0IGlzIGNsb3NlZCB1bmRlciBhbiBhc3NvY2lhdGl2ZSBiaW5hcnlcbm9wZXJhdGlvbiBhbmQgaGFzIGFuIGlkZW50aXR5IGVsZW1lbnQgc3VjaCB0aGF0IGZvciBhbGwgSEEgSEEgSEEuIFllcywgaXQncyBhXG5tb25vaWQsIHdoaWNoIHNvdW5kcyBzY2FyeSBidXQgaXQncyBub3QgcmVhbGx5IGFuZCBhY3R1YWxseSBzdXBlciB1c2VmdWwuIEFsbFxudGhhdCBtZWFucyBpcyB0aGF0IGJhc2ljYWxseSB5b3UgY2FuIGRvIHR3byB0aGluZ3Mgd2l0aCBpdDpcblxuICAgIDEuIGNvbmNhdChjb25jYXQoYSwgYiksIGMpID09PSBjb25jYXQoYSwgY29uY2F0KGIsIGMpKTtcbiAgICAyLiBjb25jYXQoaWRlbnRpdHkoKSwgYSkgPT09IGNvbmNhdChhLCBpZGVudGl0eSgpKSA9PT0gYTtcblxuV2hhdCB0aGF0IG1lYW5zIGlzIHRoYXQgaXQncyByZWFsbHkgZWFzeSB0byBjb21wb3NlIHN0eWxlcyB0b2dldGhlciBhbmQgdGhlXG5vcmRlciBpbiB3aGljaCB5b3UgZG8gc28gZG9lc24ndCByZWFsbHkgbWF0dGVyLlxuXG4qL1xuXG50eXBlIElubGluZVN0eWxlID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCB2b2lkIH07XG5cbi8vIFRPRE86IFRoaXMgdHlwZSBzaG91bGQgYmUgb3BhcXVlLCBob3dldmVyIHRoZSBCYWJlbCBwYXJzZXIgZG9lc24ndCBzdXBwb3J0XG4vLyAgICAgICB0aGUgb3BhcXVlIHN5bnRheCB5ZXQuXG5leHBvcnQgdHlwZSBTdHlsZSA9IHt8XG4gIGNsYXNzTmFtZTogU2V0PHN0cmluZz4sXG4gIGlubGluZVN0eWxlOiBJbmxpbmVTdHlsZSxcbnx9O1xuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoKTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KCksXG4gIGlubGluZVN0eWxlOiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZnJvbUNsYXNzTmFtZSA9ICguLi5jbGFzc05hbWVzOiBBcnJheTxzdHJpbmc+KTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KGNsYXNzTmFtZXMpLFxuICBpbmxpbmVTdHlsZToge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IGZyb21JbmxpbmVTdHlsZSA9IChpbmxpbmVTdHlsZTogSW5saW5lU3R5bGUpOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoKSxcbiAgaW5saW5lU3R5bGUsXG59KTtcblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IChzdHlsZXM6IEFycmF5PFN0eWxlPik6IFN0eWxlID0+XG4gIHN0eWxlcy5yZWR1Y2UoXG4gICAgKFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUEsIGlubGluZVN0eWxlOiBpbmxpbmVTdHlsZUEgfSxcbiAgICAgIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVCLCBpbmxpbmVTdHlsZTogaW5saW5lU3R5bGVCIH1cbiAgICApID0+ICh7XG4gICAgICBjbGFzc05hbWU6IG5ldyBTZXQoWy4uLmNsYXNzTmFtZUEsIC4uLmNsYXNzTmFtZUJdKSxcbiAgICAgIGlubGluZVN0eWxlOiB7IC4uLmlubGluZVN0eWxlQSwgLi4uaW5saW5lU3R5bGVCIH0sXG4gICAgfSksXG4gICAgaWRlbnRpdHkoKVxuICApO1xuXG5leHBvcnQgY29uc3QgbWFwQ2xhc3NOYW1lID0gKGZuOiAoeDogc3RyaW5nKSA9PiBzdHJpbmcpID0+ICh7XG4gIGNsYXNzTmFtZSxcbiAgaW5saW5lU3R5bGUsXG59OiBTdHlsZSk6IFN0eWxlID0+ICh7XG4gIGNsYXNzTmFtZTogbmV3IFNldChBcnJheS5mcm9tKGNsYXNzTmFtZSkubWFwKGZuKSksXG4gIGlubGluZVN0eWxlLFxufSk7XG5cbmV4cG9ydCBjb25zdCB0b1Byb3BzID0gKHtcbiAgY2xhc3NOYW1lLFxuICBpbmxpbmVTdHlsZSxcbn06IFN0eWxlKTogeyBjbGFzc05hbWU6IHN0cmluZywgc3R5bGU6IElubGluZVN0eWxlIH0gPT4ge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuXG4gIGlmIChjbGFzc05hbWUuc2l6ZSA+IDApIHtcbiAgICAvLyBTb3J0aW5nIGhlcmUgZW5zdXJlcyB0aGF0IGNsYXNzTmFtZXMgYXJlIGFsd2F5cyBzdGFibGUsIHJlZHVjaW5nIGRpZmZcbiAgICAvLyBjaHVybi4gQm94IHVzdWFsbHkgaGFzIGEgc21hbGwgbnVtYmVyIG9mIHByb3BlcnRpZXMgc28gaXQncyBub3QgYSBwZXJmXG4gICAgLy8gY29uY2Vybi5cbiAgICBwcm9wcy5jbGFzc05hbWUgPSBBcnJheS5mcm9tKGNsYXNzTmFtZSlcbiAgICAgIC5zb3J0KClcbiAgICAgIC5qb2luKCcgJyk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoaW5saW5lU3R5bGUpLmxlbmd0aCA+IDApIHtcbiAgICBwcm9wcy5zdHlsZSA9IGlubGluZVN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIGNvbmNhdCxcbiAgZnJvbUNsYXNzTmFtZSxcbiAgaWRlbnRpdHksXG4gIG1hcENsYXNzTmFtZSxcbiAgdHlwZSBTdHlsZSxcbn0gZnJvbSAnLi9zdHlsZS5qcyc7XG5cbi8qXG5cblRyYW5zZm9ybXNcblxuVGhlc2UgYXJlIGEgY29sbGVjdGlvbiBvZiBhIGZldyBmdW5jdG9ycyB0aGF0IHRha2UgdmFsdWVzIGFuZCByZXR1cm5zIFN0eWxlJ3MuIE9NRywgSSB1c2VkIHRoZSB3b3JkIGZ1bmN0b3IgLSBpdCdzIHJlYWxseSBqdXN0IGEgZmFuY3kgd29yZCBmb3IgZnVuY3Rpb24uXG5cbiovXG5cbnR5cGUgRnVuY3RvciA9IChuOiBudW1iZXIpID0+IFN0eWxlO1xuXG4vLyBBZGRzIGEgY2xhc3NuYW1lIHdoZW4gYSBwcm9wZXJ0eSBpcyBwcmVzZW50LlxuLy9cbi8vICAgICA8Qm94IHRvcCAvPlxuLy9cbmV4cG9ydCBjb25zdCB0b2dnbGUgPSAoLi4uY2xhc3NOYW1lczogQXJyYXk8c3RyaW5nPikgPT4gKHZhbD86IGJvb2xlYW4pID0+XG4gIHZhbCA/IGZyb21DbGFzc05hbWUoLi4uY2xhc3NOYW1lcykgOiBpZGVudGl0eSgpO1xuXG4vLyBNYXBzIHN0cmluZyB2YWx1ZXMgdG8gY2xhc3Nlc1xuLy9cbi8vICAgICA8Qm94IGFsaWduSXRlbXM9XCJjZW50ZXJcIiAvPlxuLy9cbmV4cG9ydCBjb25zdCBtYXBwaW5nID0gKG1hcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4gKHZhbDogc3RyaW5nKSA9PlxuICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCB2YWwpXG4gICAgPyBmcm9tQ2xhc3NOYW1lKG1hcFt2YWxdKVxuICAgIDogaWRlbnRpdHkoKTtcblxuLy8gTWFwcyBhIHJhbmdlIG9mIGludGVnZXJzIHRvIGEgcmFuZ2Ugb2YgY2xhc3NuYW1lc1xuLy9cbi8vICAgICA8Qm94IHBhZGRpbmc9ezF9IC8+XG4vL1xuZXhwb3J0IGNvbnN0IHJhbmdlID0gKHNjYWxlOiBzdHJpbmcpID0+IChuOiBudW1iZXIpID0+XG4gIGZyb21DbGFzc05hbWUoYCR7c2NhbGV9JHtuIDwgMCA/IGBOJHtNYXRoLmFicyhuKX1gIDogbn1gKTtcblxuLy8gTGlrZSBgcmFuZ2VgLCBtYXBzIGEgcmFuZ2Ugb2YgaW50ZWdlcnMgdG8gYSByYW5nZSBvZiBjbGFzc25hbWVzLCBleGNsdWRpbmdcbi8vIHplcm8gdmFsdWVzLlxuLy9cbi8vICAgICA8Qm94IHBhZGRpbmc9ezB9IC8+XG5leHBvcnQgY29uc3QgcmFuZ2VXaXRob3V0WmVybyA9IChzY2FsZTogc3RyaW5nKSA9PiAobjogbnVtYmVyKSA9PlxuICBuID09PSAwID8gaWRlbnRpdHkoKSA6IHJhbmdlKHNjYWxlKShuKTtcblxuLy8gQmluZHMgYSBzdHJpbmcgY2xhc3NuYW1lIHRvIHRoZSB2YWx1ZSBpbiBhbiBvYmplY3QuIFVzZWZ1bCB3aGVuIGludGVyYWN0aW5nXG4vLyB3aXRoIHJhbmdlcyB0aGF0IG5lZWQgdG8gY29tZSBkeW5hbWljYWxseSBmcm9tIGEgc3R5bGUgb2JqZWN0LiBUaGlzIGlzXG4vLyBzaW1pbGFyIHRvIHRoZSBOUE0gcGFja2FnZSAnY2xhc3NuYW1lcy9iaW5kJy5cbmV4cG9ydCBjb25zdCBiaW5kID0gKGZuOiBGdW5jdG9yLCBzY29wZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4gKFxuICB2YWw6IG51bWJlclxuKSA9PiBtYXBDbGFzc05hbWUobmFtZSA9PiBzY29wZVtuYW1lXSkoZm4odmFsKSk7XG5cbi8vIFRoaXMgdGFrZXMgYSBzZXJpZXMgb2YgdGhlIHByZXZpb3VzbHkgZGVmaW5lZCBmdW5jdG9ycywgcnVucyB0aGVtIGFsbFxuLy8gYWdhaW5zdCBhIHZhbHVlIGFuZCByZXR1cm5zIHRoZSBzZXQgb2YgdGhlaXIgY2xhc3NuYW1lcy5cbmV4cG9ydCBjb25zdCB1bmlvbiA9ICguLi5mbnM6IEFycmF5PEZ1bmN0b3I+KSA9PiAodmFsOiBudW1iZXIpID0+XG4gIGNvbmNhdChmbnMubWFwKGZuID0+IGZuKHZhbCkpKTtcbiIsIi8vIEBmbG93XG5cbi8qXG5cbiMgV2VsY29tZSB0byBCb3ghXG5cblRoaXMgZ3VpZGUgd2lsbCBoZWxwIHlvdSBuYXZpZ2F0ZSBhbmQgdW5kZXJzdGFuZCBpdHMgZGVzaWduLiBUaGlzIGZpbGUgaXMgcm91Z2hseSBvcmdhbml6ZWQgbGlrZTpcblxuICAxLiBGbG93IFR5cGVzXG4gIDIuIFByb3AgdHJhbnNmb3JtZXJzXG4gIDMuIEJveCBpdHNlbGZcbiAgNC4gUHJvcFR5cGVzXG5cbkknbGwgZXhwbGFpbiBlYWNoIHBhcnQgYXMgd2UgZ28gdGhyb3VnaC4gSnVzdCByZW1lbWJlciwgaWYgeW91IHdhbnQgdG8gbWFrZSB1cGRhdGVzLCBQTEVBU0UgUExFQVNFIFBMRUFTRSB1cGRhdGUgdGhlIEZsb3cgVHlwZXMgJiBQcm9wVHlwZXMgKGV2ZW4gdGhvdWdoIHRoZXkgbG9vayBzY2FyeSkuXG5cbiovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQm94LmNzcyc7XG5pbXBvcnQgYm9yZGVycyBmcm9tICcuL0JvcmRlcnMuY3NzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi9MYXlvdXQuY3NzJztcbmltcG9ydCB3aGl0ZXNwYWNlIGZyb20gJy4vYm94V2hpdGVzcGFjZS5jc3MnO1xuaW1wb3J0IHdoaXRlc3BhY2VMZWdhY3kgZnJvbSAnLi9XaGl0ZXNwYWNlLmNzcyc7XG5pbXBvcnQge1xuICBjb25jYXQsXG4gIGZyb21DbGFzc05hbWUsXG4gIGZyb21JbmxpbmVTdHlsZSxcbiAgaWRlbnRpdHksXG4gIG1hcENsYXNzTmFtZSxcbiAgdG9Qcm9wcyxcbn0gZnJvbSAnLi9zdHlsZS5qcyc7XG5pbXBvcnQge1xuICB1bmlvbixcbiAgYmluZCxcbiAgcmFuZ2UsXG4gIHRvZ2dsZSxcbiAgbWFwcGluZyxcbiAgcmFuZ2VXaXRob3V0WmVybyxcbn0gZnJvbSAnLi90cmFuc2Zvcm1zLmpzJztcblxuLypcblxuIyBQcm9UeXBlc1xuXG5Cb3gncyB0eXBlIGRlZmluaXRpb24gaXMgZXhoYXVzdGl2ZS4gV2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBkYW5nZXJvdXNseVNldElubGluZVN0eWxlYCwgdmFsdWVzIHNob3VsZG4ndCBiZSBhbWJpZ2lvdXMuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvIHR5cGUgb3V0IHRoaW5ncyBsaWtlIGJvaW50cywgYnV0IHRoYXQncyBhbHNvIHdoZXJlIEJveCdzIG1hZ2ljIGxpZXMuIEFsc28sIGJ5IHB1dHRpbmcgaW4gZXh0cmEgZWZmb3J0IGFyb3VuZCB0eXBlIGRlZmluaXRpb25zIGhlcmUsIHdlIGNhbiBza2lwIGV4dHJhIHJ1bnRpbWUgdHlwZWNoZWNrcyBpbiB0aGUgdHJhbnNmb3JtZXJzIGZvciBwZXJmb3JtYW5jZS5cblxuKi9cblxudHlwZSBOYXRCb2ludCA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNjtcbnR5cGUgSW50Qm9pbnQgPSAtNiB8IC01IHwgLTQgfCAtMyB8IC0yIHwgLTEgfCBOYXRCb2ludDtcbnR5cGUgRGlzcGxheSA9ICdub25lJyB8ICdmbGV4JyB8ICdibG9jaycgfCAnaW5saW5lQmxvY2snIHwgJ3Zpc3VhbGx5SGlkZGVuJztcbnR5cGUgRGlyZWN0aW9uID0gJ3JvdycgfCAnY29sdW1uJztcbnR5cGUgQ29sdW1uID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcbnR5cGUgUmVzcG9uc2l2ZVByb3BzID0ge1xuICBjb2x1bW4/OiAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTIsXG4gIGRpc3BsYXk/OiBib29sZWFuIHwgJ2ZsZXgnIHwgJ2ZsZXhDb2x1bW4nIHwgJ2lubGluZUJsb2NrJyxcbn07XG50eXBlIE1hcmdpbiA9XG4gIHwgLTEyXG4gIHwgLTExXG4gIHwgLTEwXG4gIHwgLTlcbiAgfCAtOFxuICB8IC03XG4gIHwgLTZcbiAgfCAtNVxuICB8IC00XG4gIHwgLTNcbiAgfCAtMlxuICB8IC0xXG4gIHwgMFxuICB8IDFcbiAgfCAyXG4gIHwgM1xuICB8IDRcbiAgfCA1XG4gIHwgNlxuICB8IDdcbiAgfCA4XG4gIHwgOVxuICB8IDEwXG4gIHwgMTFcbiAgfCAxMjtcbnR5cGUgUGFkZGluZyA9IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDkgfCAxMCB8IDExIHwgMTI7XG50eXBlIFByb3BUeXBlID0ge1xuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU/OiB7XG4gICAgX19zdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCB2b2lkIH0sXG4gIH0sXG5cbiAgeHM/OiBSZXNwb25zaXZlUHJvcHMsXG4gIHNtPzogUmVzcG9uc2l2ZVByb3BzLFxuICBtZD86IFJlc3BvbnNpdmVQcm9wcyxcbiAgbGc/OiBSZXNwb25zaXZlUHJvcHMsXG4gIGRlcHJlY2F0ZWRQYWRkaW5nPzogTmF0Qm9pbnQgfCB7IHg/OiBOYXRCb2ludCwgeT86IE5hdEJvaW50IH0sXG4gIGRlcHJlY2F0ZWRNYXJnaW4/OlxuICAgIHwgSW50Qm9pbnRcbiAgICB8IHtcbiAgICAgICAgdG9wPzogSW50Qm9pbnQsXG4gICAgICAgIHJpZ2h0PzogSW50Qm9pbnQgfCAnYXV0bycsXG4gICAgICAgIGJvdHRvbT86IEludEJvaW50LFxuICAgICAgICBsZWZ0PzogSW50Qm9pbnQgfCAnYXV0bycsXG4gICAgICB9LFxuXG4gIGRpc3BsYXk/OiBEaXNwbGF5LFxuICBjb2x1bW4/OiBDb2x1bW4sXG4gIGRpcmVjdGlvbj86IERpcmVjdGlvbixcbiAgc21EaXNwbGF5PzogRGlzcGxheSxcbiAgc21Db2x1bW4/OiBDb2x1bW4sXG4gIHNtRGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuICBtZERpc3BsYXk/OiBEaXNwbGF5LFxuICBtZENvbHVtbj86IENvbHVtbixcbiAgbWREaXJlY3Rpb24/OiBEaXJlY3Rpb24sXG4gIGxnRGlzcGxheT86IERpc3BsYXksXG4gIGxnQ29sdW1uPzogQ29sdW1uLFxuICBsZ0RpcmVjdGlvbj86IERpcmVjdGlvbixcblxuICBhbGlnbkNvbnRlbnQ/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiZXR3ZWVuJyB8ICdhcm91bmQnIHwgJ3N0cmV0Y2gnLFxuICBhbGlnbkl0ZW1zPzogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicgfCAnYmFzZWxpbmUnIHwgJ3N0cmV0Y2gnLFxuICBhbGlnblNlbGY/OiAnYXV0bycgfCAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiYXNlbGluZScgfCAnc3RyZXRjaCcsXG4gIGJvdHRvbT86IGJvb2xlYW4sXG4gIGNvbG9yPzpcbiAgICB8ICdibHVlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2RhcmtXYXNoJ1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnZ3JlZW4nXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ2xpZ2h0V2FzaCdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ3JlZCdcbiAgICB8ICd0cmFuc3BhcmVudCdcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ3doaXRlJyxcbiAgZml0PzogYm9vbGVhbixcbiAgZmxleD86ICdncm93JyB8ICdzaHJpbmsnIHwgJ25vbmUnLFxuICBoZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmcsXG4gIGp1c3RpZnlDb250ZW50PzogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicgfCAnYmV0d2VlbicgfCAnYXJvdW5kJyxcbiAgbGVmdD86IGJvb2xlYW4sXG5cbiAgbWFyZ2luU3RhcnQ/OiBNYXJnaW4sXG4gIG1hcmdpbkVuZD86IE1hcmdpbixcblxuICBtYXJnaW4/OiBNYXJnaW4sXG4gIG1hcmdpblRvcD86IE1hcmdpbixcbiAgbWFyZ2luUmlnaHQ/OiBNYXJnaW4sXG4gIG1hcmdpbkJvdHRvbT86IE1hcmdpbixcbiAgbWFyZ2luTGVmdD86IE1hcmdpbixcblxuICBzbU1hcmdpbj86IE1hcmdpbixcbiAgc21NYXJnaW5Ub3A/OiBNYXJnaW4sXG4gIHNtTWFyZ2luUmlnaHQ/OiBNYXJnaW4sXG4gIHNtTWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBzbU1hcmdpbkxlZnQ/OiBNYXJnaW4sXG5cbiAgbWRNYXJnaW4/OiBNYXJnaW4sXG4gIG1kTWFyZ2luVG9wPzogTWFyZ2luLFxuICBtZE1hcmdpblJpZ2h0PzogTWFyZ2luLFxuICBtZE1hcmdpbkJvdHRvbT86IE1hcmdpbixcbiAgbWRNYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIGxnTWFyZ2luPzogTWFyZ2luLFxuICBsZ01hcmdpblRvcD86IE1hcmdpbixcbiAgbGdNYXJnaW5SaWdodD86IE1hcmdpbixcbiAgbGdNYXJnaW5Cb3R0b20/OiBNYXJnaW4sXG4gIGxnTWFyZ2luTGVmdD86IE1hcmdpbixcblxuICBtYXhIZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmcsXG4gIG1heFdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICBtaW5IZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmcsXG4gIG1pbldpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuXG4gIG92ZXJmbG93PzogJ3Zpc2libGUnIHwgJ2hpZGRlbicgfCAnc2Nyb2xsJyB8ICdzY3JvbGxYJyB8ICdzY3JvbGxZJyB8ICdhdXRvJyxcblxuICBwYWRkaW5nPzogUGFkZGluZyxcbiAgc21QYWRkaW5nPzogUGFkZGluZyxcbiAgbWRQYWRkaW5nPzogUGFkZGluZyxcbiAgbGdQYWRkaW5nPzogUGFkZGluZyxcblxuICBwYWRkaW5nWD86IFBhZGRpbmcsXG4gIHNtUGFkZGluZ1g/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmdYPzogUGFkZGluZyxcbiAgbGdQYWRkaW5nWD86IFBhZGRpbmcsXG5cbiAgcGFkZGluZ1k/OiBQYWRkaW5nLFxuICBzbVBhZGRpbmdZPzogUGFkZGluZyxcbiAgbWRQYWRkaW5nWT86IFBhZGRpbmcsXG4gIGxnUGFkZGluZ1k/OiBQYWRkaW5nLFxuXG4gIHBvc2l0aW9uPzogJ3N0YXRpYycgfCAnYWJzb2x1dGUnIHwgJ3JlbGF0aXZlJyB8ICdmaXhlZCcsXG4gIHJpZ2h0PzogYm9vbGVhbixcbiAgc2hhcGU/OlxuICAgIHwgJ3NxdWFyZSdcbiAgICB8ICdyb3VuZGVkJ1xuICAgIHwgJ3BpbGwnXG4gICAgfCAnY2lyY2xlJ1xuICAgIHwgJ3JvdW5kZWRUb3AnXG4gICAgfCAncm91bmRlZEJvdHRvbSdcbiAgICB8ICdyb3VuZGVkTGVmdCdcbiAgICB8ICdyb3VuZGVkUmlnaHQnLFxuICBzaHJpbms/OiBib29sZWFuLFxuICB0b3A/OiBib29sZWFuLFxuICB3aWR0aD86IG51bWJlciB8IHN0cmluZyxcbiAgd3JhcD86IGJvb2xlYW4sXG59O1xuXG4vLyAtLVxuXG4vKlxuXG4jIFRyYW5zZm9ybWVyc1xuXG5UaGlzIGlzIHdoZXJlIHRoZSBtZWF0IGFuZCB0aGUgYm9uZXMgb2YgQm94J3MgdHJhbnNmb3JtcyBhcmUuIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoZSBEU0wgaW4gYC4vdHJhbnNmb3Jtcy5qc2AsIGJ1dCBiYXNpY2FsbHkgdGhleSBhcmUgYSBzbWFsbCBkZWNsYXJhdGl2ZSB3YXkgb2Ygc3BlY2lmeWluZyBob3cgYSBwcm9wZXJ0eSAoaS5lLiBgbWFyZ2luVG9wPXs0fWApIGdldHMgdHVybmVkIGludG8gYSBDU1MgY2xhc3MgKGBtYXJnaW5Ub3A0YCkuXG5cblRoZXJlJ3MgYSBsaXR0bGUgcHJlYW1ibGUgaGVyZSwgYnV0IGl0IGN1bG1pbmF0ZXMgaW4gYSBiaWcgb2JqZWN0IG1hcHBpbmcgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgdHJhbnNmb3JtZXIgdmFsdWVzLlxuXG4qL1xuXG5jb25zdCBtYXJnaW5TdGFydCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luU3RhcnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5FbmQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkVuZCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpblRvcCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luVG9wJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luUmlnaHQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpblJpZ2h0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luQm90dG9tID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5Cb3R0b20nKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5MZWZ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5MZWZ0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luID0gdW5pb24obWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0KTtcblxuY29uc3Qgc21NYXJnaW5Ub3AgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtTWFyZ2luVG9wJyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21NYXJnaW5SaWdodCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IHNtTWFyZ2luQm90dG9tID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IHNtTWFyZ2luTGVmdCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21NYXJnaW5MZWZ0JyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW4gPSB1bmlvbihcbiAgc21NYXJnaW5Ub3AsXG4gIHNtTWFyZ2luQm90dG9tLFxuICBzbU1hcmdpbkxlZnQsXG4gIHNtTWFyZ2luUmlnaHRcbik7XG5cbmNvbnN0IG1kTWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtZE1hcmdpblRvcCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luUmlnaHQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kTWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZE1hcmdpbkJvdHRvbSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5Cb3R0b20nKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZE1hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kTWFyZ2luTGVmdCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luID0gdW5pb24oXG4gIG1kTWFyZ2luVG9wLFxuICBtZE1hcmdpbkJvdHRvbSxcbiAgbWRNYXJnaW5MZWZ0LFxuICBtZE1hcmdpblJpZ2h0XG4pO1xuXG5jb25zdCBsZ01hcmdpblRvcCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdNYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpblJpZ2h0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ01hcmdpblJpZ2h0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbGdNYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luQm90dG9tJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbGdNYXJnaW5MZWZ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ01hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbiA9IHVuaW9uKFxuICBsZ01hcmdpblRvcCxcbiAgbGdNYXJnaW5Cb3R0b20sXG4gIGxnTWFyZ2luTGVmdCxcbiAgbGdNYXJnaW5SaWdodFxuKTtcblxuY29uc3QgcGFkZGluZ1ggPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3BhZGRpbmdYJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgcGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3BhZGRpbmdZJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgcGFkZGluZyA9IHVuaW9uKHBhZGRpbmdYLCBwYWRkaW5nWSk7XG5cbmNvbnN0IHNtUGFkZGluZ1ggPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtUGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbVBhZGRpbmdZID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbVBhZGRpbmdZJyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21QYWRkaW5nID0gdW5pb24oc21QYWRkaW5nWCwgc21QYWRkaW5nWSk7XG5cbmNvbnN0IG1kUGFkZGluZ1ggPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kUGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZFBhZGRpbmdZID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtZFBhZGRpbmdZJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRQYWRkaW5nID0gdW5pb24obWRQYWRkaW5nWCwgbWRQYWRkaW5nWSk7XG5cbmNvbnN0IGxnUGFkZGluZ1ggPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnUGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ1BhZGRpbmdZID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ1BhZGRpbmdZJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbGdQYWRkaW5nID0gdW5pb24obGdQYWRkaW5nWCwgbGdQYWRkaW5nWSk7XG5cbi8qXG5cblRoZXNlIGZ1bmN0aW9ucyBhcmUgbGVnYWN5LiBJJ2QgbGlrZSB0byBnZXQgcmlkIG9mIG1vc3Qgb2YgdGhpcyBmaWxlJ3MgZGVwZW5kZW5jeSBvbiBpbXBvcnRpbmcgYC4vc3R5bGUuanNgIGRpcmVjdGx5IG9uY2UgdGhlc2UgYXJlIHJlbW92ZWQuXG5cbiovXG5cbmNvbnN0IHByZWZpeCA9IChwcmU6IHN0cmluZykgPT4gbWFwQ2xhc3NOYW1lKG5hbWUgPT4gYCR7cHJlfSR7bmFtZX1gKTtcbmNvbnN0IGRpc3BsYXkgPSB2YWx1ZSA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlICdmbGV4JzpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5RmxleCcsICdEaXJlY3Rpb25Sb3cnKTtcbiAgICBjYXNlICdmbGV4Q29sdW1uJzpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5RmxleCcsICdEaXJlY3Rpb25Db2x1bW4nKTtcbiAgICBjYXNlICdpbmxpbmVCbG9jayc6XG4gICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSgnRGlzcGxheUlubGluZUJsb2NrJyk7XG4gICAgY2FzZSAndmlzdWFsbHlIaWRkZW4nOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlWaXN1YWxseUhpZGRlbicpO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSgnRGlzcGxheU5vbmUnKTtcbiAgICBkZWZhdWx0OlxuICAgICAgLyogYmxvY2sgKi9cbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5QmxvY2snKTtcbiAgfVxufTtcbmNvbnN0IGNvbHVtbiA9IHJhbmdlKCdDb2wnKTtcblxuY29uc3QgZm9ybWF0SW50Qm9pbnQgPSB4ID0+ICh4IDwgMCA/IGBuJHtNYXRoLmFicyh4KX1gIDogeC50b1N0cmluZygpKTtcblxuLypcblxuSXQncyBwcmVmZXJhYmxlIHRvIHB1dCBuZXcgcHJvcGVydGllcyBpbnRvIHRoYXQgb2JqZWN0IGRpcmVjdGx5IGp1c3Qgc28gaXQncyBlYXNpZXIgdG8gcmVhZC5cblxuKi9cblxuY29uc3QgcHJvcFRvRm4gPSB7XG4gIHhzOiB2YWx1ZSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBDbGFzc05hbWUoYyA9PiBzdHlsZXNbY10pKFxuICAgICAgcHJlZml4KCd4cycpKFxuICAgICAgICBjb25jYXQoW1xuICAgICAgICAgIHZhbHVlLmNvbHVtbiA/IGNvbHVtbih2YWx1ZS5jb2x1bW4pIDogaWRlbnRpdHkoKSxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUuZGlzcGxheSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZGlzcGxheSh2YWx1ZS5kaXNwbGF5KVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIHNtOiB2YWx1ZSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBDbGFzc05hbWUoYyA9PiBzdHlsZXNbY10pKFxuICAgICAgcHJlZml4KCdzbScpKFxuICAgICAgICBjb25jYXQoW1xuICAgICAgICAgIHZhbHVlLmNvbHVtbiA/IGNvbHVtbih2YWx1ZS5jb2x1bW4pIDogaWRlbnRpdHkoKSxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUuZGlzcGxheSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZGlzcGxheSh2YWx1ZS5kaXNwbGF5KVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIG1kOiB2YWx1ZSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBDbGFzc05hbWUoYyA9PiBzdHlsZXNbY10pKFxuICAgICAgcHJlZml4KCdtZCcpKFxuICAgICAgICBjb25jYXQoW1xuICAgICAgICAgIHZhbHVlLmNvbHVtbiA/IGNvbHVtbih2YWx1ZS5jb2x1bW4pIDogaWRlbnRpdHkoKSxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUuZGlzcGxheSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZGlzcGxheSh2YWx1ZS5kaXNwbGF5KVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIGxnOiB2YWx1ZSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBDbGFzc05hbWUoYyA9PiBzdHlsZXNbY10pKFxuICAgICAgcHJlZml4KCdsZycpKFxuICAgICAgICBjb25jYXQoW1xuICAgICAgICAgIHZhbHVlLmNvbHVtbiA/IGNvbHVtbih2YWx1ZS5jb2x1bW4pIDogaWRlbnRpdHkoKSxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUuZGlzcGxheSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZGlzcGxheSh2YWx1ZS5kaXNwbGF5KVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG5cbiAgZGlzcGxheTogbWFwcGluZyh7XG4gICAgbm9uZTogc3R5bGVzLnhzRGlzcGxheU5vbmUsXG4gICAgZmxleDogc3R5bGVzLnhzRGlzcGxheUZsZXgsXG4gICAgYmxvY2s6IHN0eWxlcy54c0Rpc3BsYXlCbG9jayxcbiAgICBpbmxpbmVCbG9jazogc3R5bGVzLnhzRGlzcGxheUlubGluZUJsb2NrLFxuICAgIHZpc3VhbGx5SGlkZGVuOiBzdHlsZXMueHNEaXNwbGF5VmlzdWFsbHlIaWRkZW4sXG4gIH0pLFxuICBjb2x1bW46IGJpbmQocmFuZ2UoJ3hzQ29sJyksIHN0eWxlcyksXG4gIGRpcmVjdGlvbjogbWFwcGluZyh7XG4gICAgcm93OiBzdHlsZXMueHNEaXJlY3Rpb25Sb3csXG4gICAgY29sdW1uOiBzdHlsZXMueHNEaXJlY3Rpb25Db2x1bW4sXG4gIH0pLFxuXG4gIHNtRGlzcGxheTogbWFwcGluZyh7XG4gICAgbm9uZTogc3R5bGVzLnNtRGlzcGxheU5vbmUsXG4gICAgZmxleDogc3R5bGVzLnNtRGlzcGxheUZsZXgsXG4gICAgYmxvY2s6IHN0eWxlcy5zbURpc3BsYXlCbG9jayxcbiAgICBpbmxpbmVCbG9jazogc3R5bGVzLnNtRGlzcGxheUlubGluZUJsb2NrLFxuICAgIHZpc3VhbGx5SGlkZGVuOiBzdHlsZXMuc21EaXNwbGF5VmlzdWFsbHlIaWRkZW4sXG4gIH0pLFxuICBzbUNvbHVtbjogYmluZChyYW5nZSgnc21Db2wnKSwgc3R5bGVzKSxcbiAgc21EaXJlY3Rpb246IG1hcHBpbmcoe1xuICAgIHJvdzogc3R5bGVzLnNtRGlyZWN0aW9uUm93LFxuICAgIGNvbHVtbjogc3R5bGVzLnNtRGlyZWN0aW9uQ29sdW1uLFxuICB9KSxcblxuICBtZERpc3BsYXk6IG1hcHBpbmcoe1xuICAgIG5vbmU6IHN0eWxlcy5tZERpc3BsYXlOb25lLFxuICAgIGZsZXg6IHN0eWxlcy5tZERpc3BsYXlGbGV4LFxuICAgIGJsb2NrOiBzdHlsZXMubWREaXNwbGF5QmxvY2ssXG4gICAgaW5saW5lQmxvY2s6IHN0eWxlcy5tZERpc3BsYXlJbmxpbmVCbG9jayxcbiAgICB2aXN1YWxseUhpZGRlbjogc3R5bGVzLm1kRGlzcGxheVZpc3VhbGx5SGlkZGVuLFxuICB9KSxcbiAgbWRDb2x1bW46IGJpbmQocmFuZ2UoJ21kQ29sJyksIHN0eWxlcyksXG4gIG1kRGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy5tZERpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy5tZERpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgbGdEaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMubGdEaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMubGdEaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLmxnRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMubGdEaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy5sZ0Rpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIGxnQ29sdW1uOiBiaW5kKHJhbmdlKCdsZ0NvbCcpLCBzdHlsZXMpLFxuICBsZ0RpcmVjdGlvbjogbWFwcGluZyh7XG4gICAgcm93OiBzdHlsZXMubGdEaXJlY3Rpb25Sb3csXG4gICAgY29sdW1uOiBzdHlsZXMubGdEaXJlY3Rpb25Db2x1bW4sXG4gIH0pLFxuXG4gIGFsaWduQ29udGVudDogbWFwcGluZyh7XG4gICAgc3RhcnQ6IGxheW91dC5jb250ZW50U3RhcnQsXG4gICAgZW5kOiBsYXlvdXQuY29udGVudEVuZCxcbiAgICBjZW50ZXI6IGxheW91dC5jb250ZW50Q2VudGVyLFxuICAgIGJldHdlZW46IGxheW91dC5jb250ZW50QmV0d2VlbixcbiAgICBhcm91bmQ6IGxheW91dC5jb250ZW50QXJvdW5kLFxuICAgIC8vIGRlZmF1bHQ6IHN0cmV0Y2hcbiAgfSksXG4gIGFsaWduSXRlbXM6IG1hcHBpbmcoe1xuICAgIHN0YXJ0OiBsYXlvdXQuaXRlbXNTdGFydCxcbiAgICBlbmQ6IGxheW91dC5pdGVtc0VuZCxcbiAgICBjZW50ZXI6IGxheW91dC5pdGVtc0NlbnRlcixcbiAgICBiYXNlbGluZTogbGF5b3V0Lml0ZW1zQmFzZWxpbmUsXG4gICAgLy8gZGVmYXVsdDogc3RyZXRjaFxuICB9KSxcbiAgYWxpZ25TZWxmOiBtYXBwaW5nKHtcbiAgICBzdGFydDogbGF5b3V0LnNlbGZTdGFydCxcbiAgICBlbmQ6IGxheW91dC5zZWxmRW5kLFxuICAgIGNlbnRlcjogbGF5b3V0LnNlbGZDZW50ZXIsXG4gICAgYmFzZWxpbmU6IGxheW91dC5zZWxmQmFzZWxpbmUsXG4gICAgc3RyZXRjaDogbGF5b3V0LnNlbGZTdHJldGNoLFxuICAgIC8vIGRlZmF1bHQ6IGF1dG9cbiAgfSksXG4gIGJvdHRvbTogdG9nZ2xlKGxheW91dC5ib3R0b20wKSxcbiAgY29sb3I6IG1hcHBpbmcoe1xuICAgIGJsdWU6IGNvbG9ycy5ibHVlQmcsXG4gICAgZGFya0dyYXk6IGNvbG9ycy5kYXJrR3JheUJnLFxuICAgIHBpbmU6IGNvbG9ycy5waW5lQmcsXG4gICAgZ3JheTogY29sb3JzLmdyYXlCZyxcbiAgICByZWQ6IGNvbG9ycy5yZWRCZyxcbiAgICBvbGl2ZTogY29sb3JzLm9saXZlQmcsXG4gICAgbGlnaHRHcmF5OiBjb2xvcnMubGlnaHRHcmF5QmcsXG4gICAgd2hpdGU6IGNvbG9ycy53aGl0ZUJnLFxuICAgIG9yYW5nZTogY29sb3JzLm9yYW5nZUJnLFxuICAgIGdyZWVuOiBjb2xvcnMuZ3JlZW5CZyxcbiAgICBuYXZ5OiBjb2xvcnMubmF2eUJnLFxuICAgIG1pZG5pZ2h0OiBjb2xvcnMubWlkbmlnaHRCZyxcbiAgICBwdXJwbGU6IGNvbG9ycy5wdXJwbGVCZyxcbiAgICBvcmNoaWQ6IGNvbG9ycy5vcmNoaWRCZyxcbiAgICBlZ2dwbGFudDogY29sb3JzLmVnZ3BsYW50QmcsXG4gICAgbWFyb29uOiBjb2xvcnMubWFyb29uQmcsXG4gICAgd2F0ZXJtZWxvbjogY29sb3JzLndhdGVybWVsb25CZyxcbiAgICBsaWdodFdhc2g6IGNvbG9ycy5saWdodFdhc2hCZyxcbiAgICBkYXJrV2FzaDogY29sb3JzLmRhcmtXYXNoQmcsXG4gICAgLy8gZGVmYXVsdDogdHJhbnNwYXJlbnRcbiAgfSksXG4gIGZpdDogdG9nZ2xlKGxheW91dC5maXQpLFxuICBmbGV4OiBtYXBwaW5nKHtcbiAgICBncm93OiBsYXlvdXQuZmxleEdyb3csXG4gICAgbm9uZTogbGF5b3V0LmZsZXhOb25lLFxuICAgIC8vIGRlZmF1bHQ6IHNocmlua1xuICB9KSxcbiAgaGVpZ2h0OiBoZWlnaHQgPT4gZnJvbUlubGluZVN0eWxlKHsgaGVpZ2h0IH0pLFxuICBqdXN0aWZ5Q29udGVudDogbWFwcGluZyh7XG4gICAgZW5kOiBsYXlvdXQuanVzdGlmeUVuZCxcbiAgICBjZW50ZXI6IGxheW91dC5qdXN0aWZ5Q2VudGVyLFxuICAgIGJldHdlZW46IGxheW91dC5qdXN0aWZ5QmV0d2VlbixcbiAgICBhcm91bmQ6IGxheW91dC5qdXN0aWZ5QXJvdW5kLFxuICAgIC8vIGRlZmF1bHQ6IHN0YXJ0XG4gIH0pLFxuICBsZWZ0OiB0b2dnbGUobGF5b3V0LmxlZnQwKSxcbiAgZGVwcmVjYXRlZE1hcmdpbjogdmFsdWUgPT4ge1xuICAgIGxldCBtdCA9IGlkZW50aXR5KCk7XG4gICAgbGV0IG1iID0gaWRlbnRpdHkoKTtcbiAgICBsZXQgbWwgPSBpZGVudGl0eSgpO1xuICAgIGxldCBtciA9IGlkZW50aXR5KCk7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKHdoaXRlc3BhY2VMZWdhY3lbYG0ke2Zvcm1hdEludEJvaW50KHZhbHVlKX1gXSk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsdWUudG9wKSB7XG4gICAgICAgICAgbXQgPSBmcm9tQ2xhc3NOYW1lKFxuICAgICAgICAgICAgd2hpdGVzcGFjZUxlZ2FjeVtgbXQke2Zvcm1hdEludEJvaW50KHZhbHVlLnRvcCl9YF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmJvdHRvbSkge1xuICAgICAgICAgIG1iID0gZnJvbUNsYXNzTmFtZShcbiAgICAgICAgICAgIHdoaXRlc3BhY2VMZWdhY3lbYG1iJHtmb3JtYXRJbnRCb2ludCh2YWx1ZS5ib3R0b20pfWBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZWZ0KSB7XG4gICAgICAgICAgbWwgPSBmcm9tQ2xhc3NOYW1lKFxuICAgICAgICAgICAgdmFsdWUubGVmdCA9PT0gJ2F1dG8nXG4gICAgICAgICAgICAgID8gd2hpdGVzcGFjZUxlZ2FjeS5tbEF1dG9cbiAgICAgICAgICAgICAgOiB3aGl0ZXNwYWNlTGVnYWN5W2BtbCR7Zm9ybWF0SW50Qm9pbnQodmFsdWUubGVmdCl9YF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLnJpZ2h0KSB7XG4gICAgICAgICAgbXIgPSBmcm9tQ2xhc3NOYW1lKFxuICAgICAgICAgICAgdmFsdWUucmlnaHQgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICA/IHdoaXRlc3BhY2VMZWdhY3kubXJBdXRvXG4gICAgICAgICAgICAgIDogd2hpdGVzcGFjZUxlZ2FjeVtgbXIke2Zvcm1hdEludEJvaW50KHZhbHVlLnJpZ2h0KX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbbXQsIG1iLCBtbCwgbXJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBpZGVudGl0eSgpO1xuICAgIH1cbiAgfSxcbiAgbWFyZ2luU3RhcnQsXG4gIG1hcmdpbkVuZCxcbiAgbWFyZ2luLFxuICBtYXJnaW5Ub3AsXG4gIG1hcmdpblJpZ2h0LFxuICBtYXJnaW5Cb3R0b20sXG4gIG1hcmdpbkxlZnQsXG4gIHNtTWFyZ2luLFxuICBzbU1hcmdpblRvcCxcbiAgc21NYXJnaW5SaWdodCxcbiAgc21NYXJnaW5Cb3R0b20sXG4gIHNtTWFyZ2luTGVmdCxcbiAgbWRNYXJnaW4sXG4gIG1kTWFyZ2luVG9wLFxuICBtZE1hcmdpblJpZ2h0LFxuICBtZE1hcmdpbkJvdHRvbSxcbiAgbWRNYXJnaW5MZWZ0LFxuICBsZ01hcmdpbixcbiAgbGdNYXJnaW5Ub3AsXG4gIGxnTWFyZ2luUmlnaHQsXG4gIGxnTWFyZ2luQm90dG9tLFxuICBsZ01hcmdpbkxlZnQsXG4gIG1heEhlaWdodDogbWF4SGVpZ2h0ID0+IGZyb21JbmxpbmVTdHlsZSh7IG1heEhlaWdodCB9KSxcbiAgbWF4V2lkdGg6IG1heFdpZHRoID0+IGZyb21JbmxpbmVTdHlsZSh7IG1heFdpZHRoIH0pLFxuICBtaW5IZWlnaHQ6IG1pbkhlaWdodCA9PiBmcm9tSW5saW5lU3R5bGUoeyBtaW5IZWlnaHQgfSksXG4gIG1pbldpZHRoOiBtaW5XaWR0aCA9PiBmcm9tSW5saW5lU3R5bGUoeyBtaW5XaWR0aCB9KSxcbiAgb3ZlcmZsb3c6IG1hcHBpbmcoe1xuICAgIGhpZGRlbjogbGF5b3V0Lm92ZXJmbG93SGlkZGVuLFxuICAgIHNjcm9sbDogbGF5b3V0Lm92ZXJmbG93U2Nyb2xsLFxuICAgIGF1dG86IGxheW91dC5vdmVyZmxvd0F1dG8sXG4gICAgc2Nyb2xsWDogbGF5b3V0Lm92ZXJmbG93U2Nyb2xsWCxcbiAgICBzY3JvbGxZOiBsYXlvdXQub3ZlcmZsb3dTY3JvbGxZLFxuICAgIC8vIGRlZmF1bHQ6IHZpc2libGVcbiAgfSksXG4gIGRlcHJlY2F0ZWRQYWRkaW5nOiB2YWx1ZSA9PiB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKHdoaXRlc3BhY2VMZWdhY3lbYHAke3ZhbHVlfWBdKTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgIHZhbHVlLnhcbiAgICAgICAgICAgID8gZnJvbUNsYXNzTmFtZSh3aGl0ZXNwYWNlTGVnYWN5W2BweCR7dmFsdWUueH1gXSlcbiAgICAgICAgICAgIDogaWRlbnRpdHkoKSxcbiAgICAgICAgICB2YWx1ZS55XG4gICAgICAgICAgICA/IGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgcHkke3ZhbHVlLnl9YF0pXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICB9LFxuICBwYWRkaW5nLFxuICBwYWRkaW5nWCxcbiAgcGFkZGluZ1ksXG4gIHNtUGFkZGluZyxcbiAgc21QYWRkaW5nWCxcbiAgc21QYWRkaW5nWSxcbiAgbWRQYWRkaW5nLFxuICBtZFBhZGRpbmdYLFxuICBtZFBhZGRpbmdZLFxuICBsZ1BhZGRpbmcsXG4gIGxnUGFkZGluZ1gsXG4gIGxnUGFkZGluZ1ksXG4gIHBvc2l0aW9uOiBtYXBwaW5nKHtcbiAgICBhYnNvbHV0ZTogbGF5b3V0LmFic29sdXRlLFxuICAgIHJlbGF0aXZlOiBsYXlvdXQucmVsYXRpdmUsXG4gICAgZml4ZWQ6IGxheW91dC5maXhlZCxcbiAgICAvLyBkZWZhdWx0OiBzdGF0aWNcbiAgfSksXG4gIHJpZ2h0OiB0b2dnbGUobGF5b3V0LnJpZ2h0MCksXG4gIHNoYXBlOiBtYXBwaW5nKHtcbiAgICBjaXJjbGU6IGJvcmRlcnMuY2lyY2xlLFxuICAgIHBpbGw6IGJvcmRlcnMucGlsbCxcbiAgICByb3VuZGVkOiBib3JkZXJzLnJvdW5kZWQsXG4gICAgcm91bmRlZEJvdHRvbTogYm9yZGVycy5yb3VuZGVkQm90dG9tLFxuICAgIHJvdW5kZWRMZWZ0OiBib3JkZXJzLnJvdW5kZWRMZWZ0LFxuICAgIHJvdW5kZWRSaWdodDogYm9yZGVycy5yb3VuZGVkUmlnaHQsXG4gICAgcm91bmRlZFRvcDogYm9yZGVycy5yb3VuZGVkVG9wLFxuICAgIC8vIGRlZmF1bHQ6IHNxdWFyZVxuICB9KSxcbiAgdG9wOiB0b2dnbGUobGF5b3V0LnRvcDApLFxuICB3aWR0aDogd2lkdGggPT4gZnJvbUlubGluZVN0eWxlKHsgd2lkdGggfSksXG4gIHdyYXA6IHRvZ2dsZShsYXlvdXQuZmxleFdyYXApLFxuICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlOiB2YWx1ZSA9PlxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIHZhbHVlICYmIHZhbHVlLl9fc3R5bGUgPyBmcm9tSW5saW5lU3R5bGUodmFsdWUuX19zdHlsZSkgOiBpZGVudGl0eSgpLFxufTtcblxuLypcblxuIyBUaGUgQ29tcG9uZW50XG5cbiovXG5cbmNvbnN0IGNvbnRhaW5zID0gKGtleSwgYXJyKSA9PiBhcnIuaW5kZXhPZihrZXkpID49IDA7XG5jb25zdCBvbWl0ID0gKGtleXMsIG9iaikgPT5cbiAgT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKGFjYywgaykgPT4ge1xuICAgIGlmIChjb250YWlucyhrLCBrZXlzKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtrXTogb2JqW2tdLFxuICAgIH07XG4gIH0sIHt9KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQm94KHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IFByb3BUeXBlKSB7XG4gIC8vIEZsb3cgY2FuJ3QgcmVhc29uIGFib3V0IHRoZSBjb25zdGFudCBuYXR1cmUgb2YgT2JqZWN0LmtleXMgc28gd2UgY2FuJ3QgdXNlXG4gIC8vIGEgZnVuY3Rpb25hbCAocmVkdWNlKSBzdHlsZSBoZXJlLlxuXG4gIC8vIEJveCBpcyBhIFwicGFzcy10aHJvdWdoXCIgY29tcG9uZW50LCBtZWFuaW5nIHRoYXQgaWYgeW91IHBhc3MgcHJvcGVydGllcyB0b1xuICAvLyBpdCB0aGF0IGl0IGRvZXNuJ3Qga25vdyBhYm91dCAoYGFyaWEtbGFiZWxgIGZvciBpbnN0YW5jZSkgaXQgcGFzc2VzXG4gIC8vIGRpcmVjdGx5IGJhY2sgdG8gdGhlIHVuZGVybHlpbmcgYDxkaXYvPmAuIFRoYXQncyBnZW5lcmFsbHkgdXNlZnVsLCBidXRcbiAgLy8gd2UnZCBhbHNvIGxpa2UgdG8gc3RyaXAgb3V0IGEgZmV3IG5hdWdodHkgcHJvcGVydGllcyB0aGF0IGJyZWFrIHN0eWxlXG4gIC8vIGVuY2Fwc3VsYXRpb24gKGNsYXNzTmFtZSwgc3R5bGUpIG9yIGFjY2Vzc2liaWxpdHkgKG9uQ2xpY2spLlxuICBsZXQgYmxhY2tsaXN0ID0gWydvbkNsaWNrJywgJ2NsYXNzTmFtZScsICdzdHlsZSddO1xuXG4gIC8vIEFsbCBCb3gncyBhcmUgYm94LXNpemVkIGJ5IGRlZmF1bHQsIHNvIHdlIHN0YXJ0IG9mZiBidWlsZGluZyB1cCB0aGUgc3R5bGVzXG4gIC8vIHRvIGJlIGFwcGxpZWQgd2l0aCBhIEJveCBiYXNlIGNsYXNzLlxuICBsZXQgcyA9IGZyb21DbGFzc05hbWUoc3R5bGVzLmJveCk7XG5cbiAgLy8gVGhpcyBsb29wcyB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGlmIGl0IGV4aXN0cyBpbiB0aGUgcHJldmlvdXNseVxuICAvLyBkZWZpbmVkIHRyYW5zZm9ybSBtYXAsIGNvbmNhdGVudGVzIHRoZSByZXN1bHRpbmcgc3R5bGVzIHRvIHRoZSBiYXNlXG4gIC8vIHN0eWxlcy4gSWYgdGhlcmUncyBhIG1hdGNoLCB3ZSBhbHNvIGRvbid0IHBhc3MgdGhyb3VnaCB0aGF0IHByb3BlcnR5LiBUaGlzXG4gIC8vIG1lYW5zIEJveCdzIHJ1bnRpbWUgaXMgb25seSBkZXBlbmRlbnQgb24gdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHBhc3NlZFxuICAvLyB0byBpdCAod2hpY2ggaXMgdHlwaWNhbGx5IHNtYWxsKSBpbnN0ZWFkIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgcG9zc2libGVcbiAgLy8gcHJvcGVydGllcyAofjMwIG9yIHNvKS4gV2hpbGUgaXQgbWF5IH5mZWVsfiBsaWtlIEJveCBpcyBpbm5lZmZpY2llbnQsIGl0c1xuICAvLyBiaWdnZXN0IHBlcmZvcm1hbmNlIGltcGFjdCBpcyBvbiBzdGFydHVwIHRpbWUgYmVjYXVzZSB0aGVyZSdzIHNvIG11Y2ggY29kZVxuICAvLyBoZXJlLlxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BUb0ZuLCBwcm9wKSkge1xuICAgICAgY29uc3QgZm4gPSBwcm9wVG9Gbltwcm9wXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICBibGFja2xpc3QgPSBibGFja2xpc3QuY29uY2F0KHByb3ApO1xuICAgICAgcyA9IGNvbmNhdChbcywgZm4odmFsdWUpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5kLi4uIG1hZ2ljIVxuICByZXR1cm4gKFxuICAgIDxkaXYgey4uLm9taXQoYmxhY2tsaXN0LCBwcm9wcyl9IHsuLi50b1Byb3BzKHMpfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuLypcblxuIyBQcm9wVHlwZXNcblxuQW5kIHdlJ3JlIGRvbmUgaGVyZSA6KVxuXG4qL1xuXG5jb25zdCBDb2x1bW5Qcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuY29uc3QgTWFyZ2luUHJvcFR5cGUgPSBQcm9wVHlwZXMub25lT2YoW1xuICAtMTIsXG4gIC0xMSxcbiAgLTEwLFxuICAtOSxcbiAgLTgsXG4gIC03LFxuICAtNixcbiAgLTUsXG4gIC00LFxuICAtMyxcbiAgLTIsXG4gIC0xLFxuICAwLFxuICAxLFxuICAyLFxuICAzLFxuICA0LFxuICA1LFxuICA2LFxuICA3LFxuICA4LFxuICA5LFxuICAxMCxcbiAgMTEsXG4gIDEyLFxuXSk7XG5cbmNvbnN0IFBhZGRpbmdQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuQm94LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIF9fc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIH0pLFxuXG4gIHhzOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgc206IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBtZDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFsnZmxleCcsICdmbGV4Q29sdW1uJywgJ2lubGluZUJsb2NrJ10pLFxuICAgIF0pLFxuICAgIGNvbHVtbjogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIGxnOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgZGVwcmVjYXRlZE1hcmdpbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgbGVmdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKV0pLFxuICAgICAgcmlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSldKSxcbiAgICB9KSxcbiAgXSksXG4gIGRlcHJlY2F0ZWRQYWRkaW5nOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICB4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgeTogUHJvcFR5cGVzLm51bWJlcixcbiAgICB9KSxcbiAgXSksXG5cbiAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBjb2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIHNtRGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgc21EaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIHNtQ29sdW1uOiBDb2x1bW5Qcm9wVHlwZSxcblxuICBtZERpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ25vbmUnLFxuICAgICdmbGV4JyxcbiAgICAnYmxvY2snLFxuICAgICdpbmxpbmVCbG9jaycsXG4gICAgJ3Zpc3VhbGx5SGlkZGVuJyxcbiAgXSksXG4gIG1kRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBtZENvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgbGdEaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBsZ0RpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncm93JywgJ2NvbHVtbiddKSxcbiAgbGdDb2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIGFsaWduQ29udGVudDogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3RhcnQnLFxuICAgICdlbmQnLFxuICAgICdjZW50ZXInLFxuICAgICdiZXR3ZWVuJyxcbiAgICAnYXJvdW5kJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBhbGlnbkl0ZW1zOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2Jhc2VsaW5lJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBhbGlnblNlbGY6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ2F1dG8nLFxuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2Jhc2VsaW5lJyxcbiAgICAnc3RyZXRjaCcsXG4gIF0pLFxuICBib3R0b206IFByb3BUeXBlcy5ib29sLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZGFya1dhc2gnLFxuICAgICdlZ2dwbGFudCcsXG4gICAgJ2dyYXknLFxuICAgICdncmVlbicsXG4gICAgJ2xpZ2h0R3JheScsXG4gICAgJ2xpZ2h0V2FzaCcsXG4gICAgJ21hcm9vbicsXG4gICAgJ21pZG5pZ2h0JyxcbiAgICAnbmF2eScsXG4gICAgJ29saXZlJyxcbiAgICAnb3JhbmdlJyxcbiAgICAnb3JjaGlkJyxcbiAgICAncGluZScsXG4gICAgJ3B1cnBsZScsXG4gICAgJ3JlZCcsXG4gICAgJ3RyYW5zcGFyZW50JyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGZpdDogUHJvcFR5cGVzLmJvb2wsXG4gIGZsZXg6IFByb3BUeXBlcy5vbmVPZihbJ2dyb3cnLCAnc2hyaW5rJywgJ25vbmUnXSksXG4gIGdyb3c6IFByb3BUeXBlcy5ib29sLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAganVzdGlmeUNvbnRlbnQ6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmV0d2VlbicsXG4gICAgJ2Fyb3VuZCcsXG4gIF0pLFxuICBsZWZ0OiBQcm9wVHlwZXMuYm9vbCxcblxuICBtYXJnaW5TdGFydDogTWFyZ2luUHJvcFR5cGUsXG4gIG1hcmdpbkVuZDogTWFyZ2luUHJvcFR5cGUsXG5cbiAgbWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luUmlnaHQ6IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBzbU1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIHNtTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtZE1hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIG1kTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBsZ01hcmdpbjogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luVG9wOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIGxnTWFyZ2luQm90dG9tOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5MZWZ0OiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtYXhIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWF4V2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWluSGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIG1pbldpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3Zpc2libGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdzY3JvbGwnLFxuICAgICdzY3JvbGxYJyxcbiAgICAnc2Nyb2xsWScsXG4gICAgJ2F1dG8nLFxuICBdKSxcblxuICBwYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHBhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgc21QYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIHNtUGFkZGluZ1g6IFBhZGRpbmdQcm9wVHlwZSxcbiAgc21QYWRkaW5nWTogUGFkZGluZ1Byb3BUeXBlLFxuXG4gIG1kUGFkZGluZzogUGFkZGluZ1Byb3BUeXBlLFxuICBtZFBhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIG1kUGFkZGluZ1k6IFBhZGRpbmdQcm9wVHlwZSxcblxuICBsZ1BhZGRpbmc6IFBhZGRpbmdQcm9wVHlwZSxcbiAgbGdQYWRkaW5nWDogUGFkZGluZ1Byb3BUeXBlLFxuICBsZ1BhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbJ3N0YXRpYycsICdhYnNvbHV0ZScsICdyZWxhdGl2ZScsICdmaXhlZCddKSxcbiAgcmlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3F1YXJlJyxcbiAgICAncm91bmRlZCcsXG4gICAgJ3BpbGwnLFxuICAgICdjaXJjbGUnLFxuICAgICdyb3VuZGVkVG9wJyxcbiAgICAncm91bmRlZEJvdHRvbScsXG4gICAgJ3JvdW5kZWRMZWZ0JyxcbiAgICAncm91bmRlZFJpZ2h0JyxcbiAgXSksXG4gIHRvcDogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHdyYXA6IFByb3BUeXBlcy5ib29sLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgYWRkIGZyb20gJy4vYWRkLnN2Zyc7XG5pbXBvcnQgYWRkQ2lyY2xlIGZyb20gJy4vYWRkLWNpcmNsZS5zdmcnO1xuaW1wb3J0IGFkZFBpbiBmcm9tICcuL2FkZC1waW4uc3ZnJztcbmltcG9ydCBhbmdsZWRQaW4gZnJvbSAnLi9hbmdsZWQtcGluLnN2Zyc7XG5pbXBvcnQgYXJyb3dCYWNrIGZyb20gJy4vYXJyb3ctYmFjay5zdmcnO1xuaW1wb3J0IGFycm93Q2lyY2xlRm9yd2FyZCBmcm9tICcuL2Fycm93LWNpcmNsZS1mb3J3YXJkLnN2Zyc7XG5pbXBvcnQgYXJyb3dDaXJjbGVEb3duIGZyb20gJy4vYXJyb3ctY2lyY2xlLWRvd24uc3ZnJztcbmltcG9ydCBhcnJvd0Rvd24gZnJvbSAnLi9hcnJvdy1kb3duLnN2Zyc7XG5pbXBvcnQgYXJyb3dGb3J3YXJkIGZyb20gJy4vYXJyb3ctZm9yd2FyZC5zdmcnO1xuaW1wb3J0IGFycm93VXAgZnJvbSAnLi9hcnJvdy11cC5zdmcnO1xuaW1wb3J0IGFycm93VXBSaWdodCBmcm9tICcuL2Fycm93LXVwLXJpZ2h0LnN2Zyc7XG5pbXBvcnQgYmVsbCBmcm9tICcuL2JlbGwuc3ZnJztcbmltcG9ydCBjYW1lcmEgZnJvbSAnLi9jYW1lcmEuc3ZnJztcbmltcG9ydCBjYW5jZWwgZnJvbSAnLi9jYW5jZWwuc3ZnJztcbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrLnN2Zyc7XG5pbXBvcnQgY2hlY2tDaXJjbGUgZnJvbSAnLi9jaGVjay1jaXJjbGUuc3ZnJztcbmltcG9ydCBjaXJjbGVPdXRsaW5lIGZyb20gJy4vY2lyY2xlLW91dGxpbmUuc3ZnJztcbmltcG9ydCBjbGVhciBmcm9tICcuL2NsZWFyLnN2Zyc7XG5pbXBvcnQgY2xvY2sgZnJvbSAnLi9jbG9jay5zdmcnO1xuaW1wb3J0IGNvZyBmcm9tICcuL2NvZy5zdmcnO1xuaW1wb3J0IGNvbXBhc3MgZnJvbSAnLi9jb21wYXNzLnN2Zyc7XG5pbXBvcnQgZGFzaCBmcm9tICcuL2Rhc2guc3ZnJztcbmltcG9ydCBlZGl0IGZyb20gJy4vZWRpdC5zdmcnO1xuaW1wb3J0IGVsbGlwc2lzIGZyb20gJy4vZWxsaXBzaXMuc3ZnJztcbmltcG9ydCBlbGxpcHNpc0NpcmNsZU91dGxpbmUgZnJvbSAnLi9lbGxpcHNpcy1jaXJjbGUtb3V0bGluZS5zdmcnO1xuaW1wb3J0IGVudmVsb3BlIGZyb20gJy4vZW52ZWxvcGUuc3ZnJztcbmltcG9ydCBleWUgZnJvbSAnLi9leWUuc3ZnJztcbmltcG9ydCBmYWNlYm9vayBmcm9tICcuL2ZhY2Vib29rLnN2Zyc7XG5pbXBvcnQgZmFjZUhhcHB5IGZyb20gJy4vZmFjZS1oYXBweS5zdmcnO1xuaW1wb3J0IGZhY2VTYWQgZnJvbSAnLi9mYWNlLXNhZC5zdmcnO1xuaW1wb3J0IGZhY2VTbWlsZXkgZnJvbSAnLi9mYWNlLXNtaWxleS5zdmcnO1xuaW1wb3J0IGZpbHRlciBmcm9tICcuL2ZpbHRlci5zdmcnO1xuaW1wb3J0IGZsYWcgZnJvbSAnLi9mbGFnLnN2Zyc7XG5pbXBvcnQgZmxhc2hsaWdodCBmcm9tICcuL2ZsYXNobGlnaHQuc3ZnJztcbmltcG9ydCBnaWYgZnJvbSAnLi9naWYuc3ZnJztcbmltcG9ydCBnbG9iZSBmcm9tICcuL2dsb2JlLnN2Zyc7XG5pbXBvcnQgZ2xvYmVDaGVja2VkIGZyb20gJy4vZ2xvYmUtY2hlY2tlZC5zdmcnO1xuaW1wb3J0IGdtYWlsIGZyb20gJy4vZ21haWwuc3ZnJztcbmltcG9ydCBnb29nbGVQbHVzIGZyb20gJy4vZ29vZ2xlLXBsdXMuc3ZnJztcbmltcG9ydCBncmFwaEJhciBmcm9tICcuL2dyYXBoLWJhci5zdmcnO1xuaW1wb3J0IGtub29wIGZyb20gJy4va25vb3Auc3ZnJztcbmltcG9ydCBsaWdodGJ1bGIgZnJvbSAnLi9saWdodGJ1bGIuc3ZnJztcbmltcG9ydCBoYW5kbGUgZnJvbSAnLi9oYW5kbGUuc3ZnJztcbmltcG9ydCBoYW5kUG9pbnRpbmcgZnJvbSAnLi9oYW5kLXBvaW50aW5nLnN2Zyc7XG5pbXBvcnQgaGVhcnQgZnJvbSAnLi9oZWFydC5zdmcnO1xuaW1wb3J0IGhlYXJ0QnJva2VuIGZyb20gJy4vaGVhcnQtYnJva2VuLnN2Zyc7XG5pbXBvcnQgbGluayBmcm9tICcuL2xpbmsuc3ZnJztcbmltcG9ydCBsb2NhdGlvbiBmcm9tICcuL2xvY2F0aW9uLnN2Zyc7XG5pbXBvcnQgbG9jayBmcm9tICcuL2xvY2suc3ZnJztcbmltcG9ydCBtYXhpbWl6ZSBmcm9tICcuL21heGltaXplLnN2Zyc7XG5pbXBvcnQgbWVnYXBob25lIGZyb20gJy4vbWVnYXBob25lLnN2Zyc7XG5pbXBvcnQgbWVudSBmcm9tICcuL21lbnUuc3ZnJztcbmltcG9ydCBtaW5pbWl6ZSBmcm9tICcuL21pbmltaXplLnN2Zyc7XG5pbXBvcnQgbW92ZSBmcm9tICcuL21vdmUuc3ZnJztcbmltcG9ydCBtdXRlIGZyb20gJy4vbXV0ZS5zdmcnO1xuaW1wb3J0IHBhdXNlIGZyb20gJy4vcGF1c2Uuc3ZnJztcbmltcG9ydCBwZW9wbGUgZnJvbSAnLi9wZW9wbGUuc3ZnJztcbmltcG9ydCBwZXJzb24gZnJvbSAnLi9wZXJzb24uc3ZnJztcbmltcG9ydCBwZXJzb25BZGQgZnJvbSAnLi9wZXJzb24tYWRkLnN2Zyc7XG5pbXBvcnQgcGluIGZyb20gJy4vcGluLnN2Zyc7XG5pbXBvcnQgcGluSGlkZSBmcm9tICcuL3Bpbi1oaWRlLnN2Zyc7XG5pbXBvcnQgcGludGVyZXN0IGZyb20gJy4vcGludGVyZXN0LnN2Zyc7XG5pbXBvcnQgcGxheSBmcm9tICcuL3BsYXkuc3ZnJztcbmltcG9ydCBxdWVzdGlvbk1hcmsgZnJvbSAnLi9xdWVzdGlvbi1tYXJrLnN2Zyc7XG5pbXBvcnQgcmVtb3ZlIGZyb20gJy4vcmVtb3ZlLnN2Zyc7XG5pbXBvcnQgcmVwb3J0IGZyb20gJy4vcmVwb3J0LnN2Zyc7XG5pbXBvcnQgc2VhcmNoIGZyb20gJy4vc2VhcmNoLnN2Zyc7XG5pbXBvcnQgc2VuZCBmcm9tICcuL3NlbmQuc3ZnJztcbmltcG9ydCBzaGFyZSBmcm9tICcuL3NoYXJlLnN2Zyc7XG5pbXBvcnQgc2hvcHBpbmdCYWcgZnJvbSAnLi9zaG9wcGluZy1iYWcuc3ZnJztcbmltcG9ydCBzbWlsZXkgZnJvbSAnLi9zbWlsZXkuc3ZnJztcbmltcG9ydCBzbWlsZXlPdXRsaW5lIGZyb20gJy4vc21pbGV5LW91dGxpbmUuc3ZnJztcbmltcG9ydCBzb3VuZCBmcm9tICcuL3NvdW5kLnN2Zyc7XG5pbXBvcnQgc3BlZWNoIGZyb20gJy4vc3BlZWNoLnN2Zyc7XG5pbXBvcnQgc3BlZWNoRWxsaXBzaXMgZnJvbSAnLi9zcGVlY2gtZWxsaXBzaXMuc3ZnJztcbmltcG9ydCB0YWcgZnJvbSAnLi90YWcuc3ZnJztcbmltcG9ydCB0d2l0dGVyIGZyb20gJy4vdHdpdHRlci5zdmcnO1xuaW1wb3J0IHZpZXdUeXBlRGVmYXVsdCBmcm9tICcuL3ZpZXctdHlwZS1kZWZhdWx0LnN2Zyc7XG5pbXBvcnQgdmlld1R5cGVEZW5zZSBmcm9tICcuL3ZpZXctdHlwZS1kZW5zZS5zdmcnO1xuaW1wb3J0IHZpZXdUeXBlTGlzdCBmcm9tICcuL3ZpZXctdHlwZS1saXN0LnN2Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYWRkLFxuICAnYWRkLWNpcmNsZSc6IGFkZENpcmNsZSxcbiAgJ2FkZC1waW4nOiBhZGRQaW4sXG4gICdhbmdsZWQtcGluJzogYW5nbGVkUGluLFxuICAnYXJyb3ctYmFjayc6IGFycm93QmFjayxcbiAgJ2Fycm93LWNpcmNsZS1kb3duJzogYXJyb3dDaXJjbGVEb3duLFxuICAnYXJyb3ctY2lyY2xlLWZvcndhcmQnOiBhcnJvd0NpcmNsZUZvcndhcmQsXG4gICdhcnJvdy1kb3duJzogYXJyb3dEb3duLFxuICAnYXJyb3ctZm9yd2FyZCc6IGFycm93Rm9yd2FyZCxcbiAgJ2Fycm93LXVwJzogYXJyb3dVcCxcbiAgJ2Fycm93LXVwLXJpZ2h0JzogYXJyb3dVcFJpZ2h0LFxuICBiZWxsLFxuICBjYW1lcmEsXG4gIGNhbmNlbCxcbiAgY2hlY2ssXG4gICdjaGVjay1jaXJjbGUnOiBjaGVja0NpcmNsZSxcbiAgJ2NpcmNsZS1vdXRsaW5lJzogY2lyY2xlT3V0bGluZSxcbiAgY2xlYXIsXG4gIGNsb2NrLFxuICBjb2csXG4gIGNvbXBhc3MsXG4gIGRhc2gsXG4gIGVkaXQsXG4gIGVsbGlwc2lzLFxuICAnZWxsaXBzaXMtY2lyY2xlLW91dGxpbmUnOiBlbGxpcHNpc0NpcmNsZU91dGxpbmUsXG4gIGVudmVsb3BlLFxuICBleWUsXG4gIGZhY2Vib29rLFxuICAnZmFjZS1oYXBweSc6IGZhY2VIYXBweSxcbiAgJ2ZhY2Utc2FkJzogZmFjZVNhZCxcbiAgJ2ZhY2Utc21pbGV5JzogZmFjZVNtaWxleSxcbiAgZmlsdGVyLFxuICBmbGFnLFxuICBmbGFzaGxpZ2h0LFxuICBnaWYsXG4gIGdsb2JlLFxuICAnZ2xvYmUtY2hlY2tlZCc6IGdsb2JlQ2hlY2tlZCxcbiAgZ21haWwsXG4gICdnb29nbGUtcGx1cyc6IGdvb2dsZVBsdXMsXG4gICdncmFwaC1iYXInOiBncmFwaEJhcixcbiAgaGFuZGxlLFxuICAnaGFuZC1wb2ludGluZyc6IGhhbmRQb2ludGluZyxcbiAgaGVhcnQsXG4gICdoZWFydC1icm9rZW4nOiBoZWFydEJyb2tlbixcbiAga25vb3AsXG4gIGxpZ2h0YnVsYixcbiAgbGluayxcbiAgbG9jYXRpb24sXG4gIGxvY2ssXG4gIG1heGltaXplLFxuICBtZWdhcGhvbmUsXG4gIG1lbnUsXG4gIG1pbmltaXplLFxuICBtb3ZlLFxuICBtdXRlLFxuICBwYXVzZSxcbiAgcGVvcGxlLFxuICBwZXJzb24sXG4gICdwZXJzb24tYWRkJzogcGVyc29uQWRkLFxuICBwaW4sXG4gICdwaW4taGlkZSc6IHBpbkhpZGUsXG4gIHBpbnRlcmVzdCxcbiAgcGxheSxcbiAgJ3F1ZXN0aW9uLW1hcmsnOiBxdWVzdGlvbk1hcmssXG4gIHJlbW92ZSxcbiAgcmVwb3J0LFxuICBzZWFyY2gsXG4gICdzaG9wcGluZy1iYWcnOiBzaG9wcGluZ0JhZyxcbiAgc21pbGV5LFxuICAnc21pbGV5LW91dGxpbmUnOiBzbWlsZXlPdXRsaW5lLFxuICBzZW5kLFxuICBzaGFyZSxcbiAgc291bmQsXG4gIHNwZWVjaCxcbiAgJ3NwZWVjaC1lbGxpcHNpcyc6IHNwZWVjaEVsbGlwc2lzLFxuICB0YWcsXG4gIHR3aXR0ZXIsXG4gICd2aWV3LXR5cGUtZGVmYXVsdCc6IHZpZXdUeXBlRGVmYXVsdCxcbiAgJ3ZpZXctdHlwZS1kZW5zZSc6IHZpZXdUeXBlRGVuc2UsXG4gICd2aWV3LXR5cGUtbGlzdCc6IHZpZXdUeXBlTGlzdCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0ljb24uY3NzJztcbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zL2luZGV4LmpzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcblxudHlwZSBJY29uUHJvcHMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogc3RyaW5nLFxuICBjb2xvcj86XG4gICAgfCAnYmx1ZSdcbiAgICB8ICdkYXJrR3JheSdcbiAgICB8ICdlZ2dwbGFudCdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2dyZWVuJ1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ3JlZCdcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ3doaXRlJyxcbiAgaW5saW5lPzogYm9vbGVhbixcbiAgc2l6ZT86IG51bWJlciB8IHN0cmluZyxcbn07XG5cbnR5cGUgSWNvbk5vUGF0aCA9IHtcbiAgaWNvbjogJEtleXM8dHlwZW9mIGljb25zPixcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoPzogbnVsbCxcbn07XG5cbnR5cGUgUGF0aE5vSWNvbiA9IHtcbiAgaWNvbj86IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0U3ZnUGF0aDogeyBfX3BhdGg6IHN0cmluZyB9LFxufTtcblxudHlwZSBQcm9wcyA9IEljb25Qcm9wcyAmIChQYXRoTm9JY29uIHwgSWNvbk5vUGF0aCk7XG5cbmNvbnN0IEljb25OYW1lcyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSWNvbihwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc2liaWxpdHlMYWJlbCxcbiAgICBjb2xvciA9ICdncmF5JyxcbiAgICBpY29uLFxuICAgIGlubGluZSxcbiAgICBzaXplID0gMTYsXG4gICAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgY3MgPSBjbGFzc25hbWVzKHN0eWxlcy5pY29uLCBjb2xvcnNbY29sb3JdLCB7XG4gICAgW3N0eWxlcy5pY29uQmxvY2tdOiAhaW5saW5lLFxuICB9KTtcblxuICBjb25zdCBwYXRoID1cbiAgICAoaWNvbiAmJiBpY29uc1tpY29uXSkgfHxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbiAgICAoZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoICYmIGRhbmdlcm91c2x5U2V0U3ZnUGF0aC5fX3BhdGgpIHx8XG4gICAgdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGFyaWFIaWRkZW4gPSBhY2Nlc3NpYmlsaXR5TGFiZWwgPT09ICcnID8gdHJ1ZSA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9e2NzfVxuICAgICAgaGVpZ2h0PXtzaXplfVxuICAgICAgd2lkdGg9e3NpemV9XG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgIGFyaWEtaGlkZGVuPXthcmlhSGlkZGVufVxuICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgcm9sZT1cImltZ1wiXG4gICAgPlxuICAgICAgPHRpdGxlPnthY2Nlc3NpYmlsaXR5TGFiZWx9PC90aXRsZT5cbiAgICAgIDxwYXRoIGQ9e3BhdGh9IC8+XG4gICAgPC9zdmc+XG4gICk7XG59XG5cbkljb24uaWNvbnMgPSBJY29uTmFtZXM7XG5cbkljb24ucHJvcFR5cGVzID0ge1xuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ2JsdWUnLFxuICAgICdkYXJrR3JheScsXG4gICAgJ2VnZ3BsYW50JyxcbiAgICAnZ3JheScsXG4gICAgJ2dyZWVuJyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAnbWFyb29uJyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICduYXZ5JyxcbiAgICAnb2xpdmUnLFxuICAgICdvcmFuZ2UnLFxuICAgICdvcmNoaWQnLFxuICAgICdwaW5lJyxcbiAgICAncHVycGxlJyxcbiAgICAncmVkJyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGRhbmdlcm91c2x5U2V0U3ZnUGF0aDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBfX3BhdGg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH0pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoSWNvbk5hbWVzKSxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSW1hZ2UuY3NzJztcblxuY29uc3Qgc2hvdWxkU2NhbGVJbWFnZSA9IGZpdCA9PiBmaXQgPT09ICdjb3ZlcicgfHwgZml0ID09PSAnY29udGFpbic7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhbHQ6IHN0cmluZyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBjb2xvcjogc3RyaW5nLFxuICBmaXQ6ICdjb250YWluJyB8ICdjb3ZlcicgfCAnbm9uZScsXG4gIG5hdHVyYWxIZWlnaHQ6IG51bWJlcixcbiAgbmF0dXJhbFdpZHRoOiBudW1iZXIsXG4gIG9uRXJyb3I/OiAoKSA9PiB2b2lkLFxuICBvbkxvYWQ/OiAoKSA9PiB2b2lkLFxuICBzaXplcz86IHN0cmluZyxcbiAgc3JjOiBzdHJpbmcsXG4gIHNyY1NldD86IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhbHQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZml0OiBQcm9wVHlwZXMub25lT2YoWydjb250YWluJywgJ2NvdmVyJywgJ25vbmUnXSksXG4gICAgbmF0dXJhbEhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIG5hdHVyYWxXaWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2l6ZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgc3JjOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgc3JjU2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgZml0OiAnbm9uZScsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHNob3VsZFNjYWxlSW1hZ2UodGhpcy5wcm9wcy5maXQpKSB7XG4gICAgICB0aGlzLmxvYWRJbWFnZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzKSB7XG4gICAgY29uc3QgeyBmaXQsIHNyYyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoc2hvdWxkU2NhbGVJbWFnZShmaXQpICYmIHByZXZQcm9wcy5zcmMgIT09IHNyYykge1xuICAgICAgdGhpcy5sb2FkSW1hZ2UoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVMb2FkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkxvYWQoKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlRXJyb3IgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy5vbkVycm9yKCk7XG4gICAgfVxuICB9O1xuXG4gIGxvYWRJbWFnZSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gdGhpcy5oYW5kbGVMb2FkO1xuICAgICAgaW1hZ2Uub25lcnJvciA9IHRoaXMuaGFuZGxlRXJyb3I7XG4gICAgICBpbWFnZS5zcmMgPSB0aGlzLnByb3BzLnNyYztcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWx0LFxuICAgICAgY29sb3IsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZpdCxcbiAgICAgIG5hdHVyYWxIZWlnaHQsXG4gICAgICBuYXR1cmFsV2lkdGgsXG4gICAgICBzaXplcyxcbiAgICAgIHNyYyxcbiAgICAgIHNyY1NldCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGlzU2NhbGVkSW1hZ2UgPSBzaG91bGRTY2FsZUltYWdlKGZpdCk7XG4gICAgY29uc3QgY2hpbGRDb250ZW50ID0gY2hpbGRyZW4gPyAoXG4gICAgICA8Qm94IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgbGVmdCBib3R0b20gcmlnaHQgb3ZlcmZsb3c9XCJoaWRkZW5cIj5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Cb3g+XG4gICAgKSA6IG51bGw7XG5cbiAgICByZXR1cm4gaXNTY2FsZWRJbWFnZSA/IChcbiAgICAgIDxkaXZcbiAgICAgICAgYXJpYS1sYWJlbD17YWx0fVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlc1tmaXRdfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCcke3NyY30nKWAsXG4gICAgICAgIH19XG4gICAgICAgIHJvbGU9XCJpbWdcIlxuICAgICAgPlxuICAgICAgICB7Y2hpbGRDb250ZW50fVxuICAgICAgPC9kaXY+XG4gICAgKSA6IChcbiAgICAgIDxCb3hcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogYCR7bmF0dXJhbEhlaWdodCAvIG5hdHVyYWxXaWR0aCAqIDEwMH0lYCxcbiAgICAgICAgICB9LFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgYWx0PXthbHR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaW1nfVxuICAgICAgICAgIG9uRXJyb3I9e3RoaXMuaGFuZGxlRXJyb3J9XG4gICAgICAgICAgb25Mb2FkPXt0aGlzLmhhbmRsZUxvYWR9XG4gICAgICAgICAgc2l6ZXM9e3NpemVzfVxuICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgIHNyY1NldD17c3JjU2V0fVxuICAgICAgICAvPlxuICAgICAgICB7Y2hpbGRDb250ZW50fVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vTWFzay5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBoZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmcsXG4gIHNoYXBlPzogJ2NpcmNsZScgfCAncm91bmRlZCcgfCAnc3F1YXJlJyxcbiAgd2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG4gIHdhc2g/OiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hc2socHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIHNoYXBlID0gJ3NxdWFyZScsIHdpZHRoLCBoZWlnaHQsIHdhc2ggPSBmYWxzZSB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5NYXNrLCBzdHlsZXNbc2hhcGVdKX0gc3R5bGU9e3sgd2lkdGgsIGhlaWdodCB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICAgIHt3YXNoICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud2FzaH0gLz59XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbk1hc2sucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzaGFwZTogUHJvcFR5cGVzLm9uZU9mKFsnY2lyY2xlJywgJ3JvdW5kZWQnLCAnc3F1YXJlJ10pLFxuICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICB3YXNoOiBQcm9wVHlwZXMuYm9vbCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBJbWFnZSBmcm9tICcuL0ltYWdlLmpzJztcbmltcG9ydCBNYXNrIGZyb20gJy4vTWFzay5qcyc7XG5pbXBvcnQgdHlwb2dyYXBoeSBmcm9tICcuL1R5cG9ncmFwaHkuY3NzJztcblxuY29uc3QgU3F1YXJlID0gKHByb3BzOiAqKSA9PiAoXG4gIDxCb3ggey4uLnByb3BzfSBwb3NpdGlvbj1cInJlbGF0aXZlXCI+XG4gICAgPEJveFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IHBhZGRpbmdCb3R0b206ICcxMDAlJyB9IH19XG4gICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAvPlxuICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCBsZWZ0IGJvdHRvbSByaWdodD5cbiAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICA8L0JveD5cbiAgPC9Cb3g+XG4pO1xuXG5jb25zdCBEZWZhdWx0QXZhdGFyID0gKHsgbmFtZSB9OiB7IG5hbWU6IHN0cmluZyB9KSA9PiB7XG4gIGNvbnN0IGZpcnN0SW5pdGlhbCA9IG5hbWUgPyBbLi4ubmFtZV1bMF0udG9VcHBlckNhc2UoKSA6ICcnO1xuICByZXR1cm4gKFxuICAgIDxTcXVhcmUgY29sb3I9XCJncmF5XCIgc2hhcGU9XCJjaXJjbGVcIj5cbiAgICAgIHtmaXJzdEluaXRpYWwgJiYgKFxuICAgICAgICA8c3ZnXG4gICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICB2aWV3Qm94PVwiLTUwIC01MCAxMDAgMTAwXCJcbiAgICAgICAgICB2ZXJzaW9uPVwiMS4xXCJcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG4gICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgID5cbiAgICAgICAgICA8dGl0bGU+e25hbWV9PC90aXRsZT5cbiAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgZm9udFNpemU9XCI1MHB4XCJcbiAgICAgICAgICAgIGZpbGw9XCIjZmZmXCJcbiAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgICAgICAgIHR5cG9ncmFwaHkuYW50aWFsaWFzZWQsXG4gICAgICAgICAgICAgIHR5cG9ncmFwaHkuc2Fuc1NlcmlmLFxuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LmxlYWRpbmdTbWFsbCxcbiAgICAgICAgICAgICAgdHlwb2dyYXBoeS5mb250V2VpZ2h0Qm9sZCxcbiAgICAgICAgICAgIF0uam9pbignICcpfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtmaXJzdEluaXRpYWx9XG4gICAgICAgICAgPC90ZXh0PlxuICAgICAgICA8L3N2Zz5cbiAgICAgICl9XG4gICAgPC9TcXVhcmU+XG4gICk7XG59O1xuXG50eXBlIFN0YXRlID0ge3wgaXNJbWFnZUxvYWRlZDogYm9vbGVhbiB8fTtcblxudHlwZSBBdmF0YXJQcm9wcyA9IHt8XG4gIG5hbWU6IHN0cmluZyxcbiAgb3V0bGluZT86IGJvb2xlYW4sXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycsXG4gIHNyYz86IHN0cmluZyxcbiAgdmVyaWZpZWQ/OiBib29sZWFuLFxufH07XG5cbmNvbnN0IHNpemVzID0ge1xuICBzbTogMjQsXG4gIG1kOiA0MCxcbiAgbGc6IDcyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXZhdGFyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxBdmF0YXJQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb3V0bGluZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3JjOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICAgIHZlcmlmaWVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBpc0ltYWdlTG9hZGVkOiB0cnVlLFxuICB9O1xuXG4gIGhhbmRsZUltYWdlRXJyb3IgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgaXNJbWFnZUxvYWRlZDogZmFsc2UgfSk7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbmFtZSwgb3V0bGluZSwgc2l6ZSwgc3JjLCB2ZXJpZmllZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGlzSW1hZ2VMb2FkZWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgd2lkdGggPSBzaXplID8gc2l6ZXNbc2l6ZV0gOiAnMTAwJSc7XG4gICAgY29uc3QgaGVpZ2h0ID0gc2l6ZSA/IHNpemVzW3NpemVdIDogJyc7XG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgIHsuLi4ob3V0bGluZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAwIDAgMnB4ICNmZmYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSl9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICA+XG4gICAgICAgIHtzcmMgJiYgaXNJbWFnZUxvYWRlZCA/IChcbiAgICAgICAgICA8TWFzayBzaGFwZT1cImNpcmNsZVwiIHdhc2g+XG4gICAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgICAgYWx0PXtuYW1lfVxuICAgICAgICAgICAgICBjb2xvcj1cIiNFRkVGRUZcIlxuICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0PXsxfVxuICAgICAgICAgICAgICBuYXR1cmFsV2lkdGg9ezF9XG4gICAgICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgICAgICBvbkVycm9yPXt0aGlzLmhhbmRsZUltYWdlRXJyb3J9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvTWFzaz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8RGVmYXVsdEF2YXRhciBuYW1lPXtuYW1lfSAvPlxuICAgICAgICApfVxuICAgICAgICB7dmVyaWZpZWQgJiYgKFxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgd2lkdGg9XCIyMCVcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMjAlXCJcbiAgICAgICAgICAgIG1pbldpZHRoPXs4fVxuICAgICAgICAgICAgbWluSGVpZ2h0PXs4fVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiAnNCUnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnNCUnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAwIDAgMnB4ICNmZmYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgICAgY29sb3I9XCJyZWRcIlxuICAgICAgICAgICAgICAgIGljb249XCJjaGVjay1jaXJjbGVcIlxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiXG4gICAgICAgICAgICAgICAgc2l6ZT1cIjEwMCVcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1RleHQuY3NzJztcbmltcG9ydCB0eXBvZ3JhcGh5IGZyb20gJy4vVHlwb2dyYXBoeS5jc3MnO1xuXG5jb25zdCBTSVpFX1NDQUxFOiB7IFtzaXplOiA/c3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gIHhzOiAxLFxuICBzbTogMixcbiAgbWQ6IDMsXG4gIGxnOiA0LFxuICB4bDogNSxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JyxcbiAgYm9sZD86IGJvb2xlYW4sXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgY29sb3I/OlxuICAgIHwgJ2dyZWVuJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAnb2xpdmUnXG4gICAgfCAnYmx1ZSdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ21pZG5pZ2h0J1xuICAgIHwgJ3B1cnBsZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAnZWdncGxhbnQnXG4gICAgfCAnbWFyb29uJ1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnb3JhbmdlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ3JlZCdcbiAgICB8ICd3aGl0ZScsXG4gIGlubGluZT86IGJvb2xlYW4sXG4gIGl0YWxpYz86IGJvb2xlYW4sXG4gIG92ZXJmbG93PzogJ25vcm1hbCcgfCAnYnJlYWtXb3JkJyxcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBzbVNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbWRTaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIGxnU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBsZWFkaW5nPzogJ3RhbGwnIHwgJ3Nob3J0JyxcbiAgdHJ1bmNhdGU/OiBib29sZWFuLFxuICBfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0PzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUZXh0KHtcbiAgYWxpZ24gPSAnbGVmdCcsXG4gIGJvbGQgPSBmYWxzZSxcbiAgY2hpbGRyZW4sXG4gIGNvbG9yID0gJ2RhcmtHcmF5JyxcbiAgaW5saW5lID0gZmFsc2UsXG4gIGl0YWxpYyA9IGZhbHNlLFxuICBvdmVyZmxvdyA9ICdicmVha1dvcmQnLFxuICBzaXplID0gJ21kJyxcbiAgc21TaXplLFxuICBtZFNpemUsXG4gIGxnU2l6ZSxcbiAgbGVhZGluZyA9ICdzaG9ydCcsXG4gIHRydW5jYXRlID0gZmFsc2UsXG4gIF9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQgPSBmYWxzZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNjYWxlID0gU0laRV9TQ0FMRVtzaXplXTtcbiAgY29uc3Qgc21TY2FsZSA9IFNJWkVfU0NBTEVbc21TaXplXTtcbiAgY29uc3QgbWRTY2FsZSA9IFNJWkVfU0NBTEVbbWRTaXplXTtcbiAgY29uc3QgbGdTY2FsZSA9IFNJWkVfU0NBTEVbbGdTaXplXTtcblxuICBjb25zdCBjcyA9IGN4KFxuICAgIHN0eWxlcy5UZXh0LFxuICAgIHN0eWxlc1tgZm9udFNpemUke3NjYWxlfWBdLFxuICAgIGxnU2l6ZSAmJiBzdHlsZXNbYGxnRm9udFNpemUke2xnU2NhbGV9YF0sXG4gICAgbWRTaXplICYmIHN0eWxlc1tgbWRGb250U2l6ZSR7bWRTY2FsZX1gXSxcbiAgICBzbVNpemUgJiYgc3R5bGVzW2BzbUZvbnRTaXplJHtzbVNjYWxlfWBdLFxuICAgIGNvbG9yID09PSAnYmx1ZScgJiYgY29sb3JzLmJsdWUsXG4gICAgY29sb3IgPT09ICdkYXJrR3JheScgJiYgY29sb3JzLmRhcmtHcmF5LFxuICAgIGNvbG9yID09PSAnZWdncGxhbnQnICYmIGNvbG9ycy5lZ2dwbGFudCxcbiAgICBjb2xvciA9PT0gJ2dyYXknICYmIGNvbG9ycy5ncmF5LFxuICAgIGNvbG9yID09PSAnZ3JlZW4nICYmIGNvbG9ycy5ncmVlbixcbiAgICBjb2xvciA9PT0gJ2xpZ2h0R3JheScgJiYgY29sb3JzLmxpZ2h0R3JheSxcbiAgICBjb2xvciA9PT0gJ21hcm9vbicgJiYgY29sb3JzLm1hcm9vbixcbiAgICBjb2xvciA9PT0gJ21pZG5pZ2h0JyAmJiBjb2xvcnMubWlkbmlnaHQsXG4gICAgY29sb3IgPT09ICduYXZ5JyAmJiBjb2xvcnMubmF2eSxcbiAgICBjb2xvciA9PT0gJ29saXZlJyAmJiBjb2xvcnMub2xpdmUsXG4gICAgY29sb3IgPT09ICdvcmFuZ2UnICYmIGNvbG9ycy5vcmFuZ2UsXG4gICAgY29sb3IgPT09ICdvcmNoaWQnICYmIGNvbG9ycy5vcmNoaWQsXG4gICAgY29sb3IgPT09ICdwaW5lJyAmJiBjb2xvcnMucGluZSxcbiAgICBjb2xvciA9PT0gJ3B1cnBsZScgJiYgY29sb3JzLnB1cnBsZSxcbiAgICBjb2xvciA9PT0gJ3JlZCcgJiYgY29sb3JzLnJlZCxcbiAgICBjb2xvciA9PT0gJ3dhdGVybWVsb24nICYmIGNvbG9ycy53YXRlcm1lbG9uLFxuICAgIGNvbG9yID09PSAnd2hpdGUnICYmIGNvbG9ycy53aGl0ZSxcbiAgICBsZWFkaW5nID09PSAnc2hvcnQnICYmIHR5cG9ncmFwaHkubGVhZGluZ1Nob3J0LFxuICAgIChsZWFkaW5nID09PSAndGFsbCcgfHwgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodCkgJiZcbiAgICAgIHR5cG9ncmFwaHkubGVhZGluZ1RhbGwsXG4gICAgYWxpZ24gPT09ICdjZW50ZXInICYmIHR5cG9ncmFwaHkuYWxpZ25DZW50ZXIsXG4gICAgYWxpZ24gPT09ICdqdXN0aWZ5JyAmJiB0eXBvZ3JhcGh5LmFsaWduSnVzdGlmeSxcbiAgICBhbGlnbiA9PT0gJ2xlZnQnICYmIHR5cG9ncmFwaHkuYWxpZ25MZWZ0LFxuICAgIGFsaWduID09PSAncmlnaHQnICYmIHR5cG9ncmFwaHkuYWxpZ25SaWdodCxcbiAgICBvdmVyZmxvdyA9PT0gJ2JyZWFrV29yZCcgJiYgdHlwb2dyYXBoeS5icmVha1dvcmQsXG4gICAgaXRhbGljICYmIHR5cG9ncmFwaHkuZm9udFN0eWxlSXRhbGljLFxuICAgICFpdGFsaWMgJiYgdHlwb2dyYXBoeS5mb250U3R5bGVOb3JtYWwsXG4gICAgYm9sZCAmJiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHRCb2xkLFxuICAgICFib2xkICYmIHR5cG9ncmFwaHkuZm9udFdlaWdodE5vcm1hbCxcbiAgICB0cnVuY2F0ZSAmJiB0eXBvZ3JhcGh5LnRydW5jYXRlXG4gICk7XG4gIGNvbnN0IFRhZyA9IGlubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuXG4gIHJldHVybiAoXG4gICAgPFRhZ1xuICAgICAgY2xhc3NOYW1lPXtjc31cbiAgICAgIHsuLi4odHJ1bmNhdGUgJiYgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHsgdGl0bGU6IGNoaWxkcmVuIH1cbiAgICAgICAgOiBudWxsKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UYWc+XG4gICk7XG59XG5cblRleHQucHJvcFR5cGVzID0ge1xuICBfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcbiAgYWxpZ246IFByb3BUeXBlcy5vbmVPZihbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJywgJ2p1c3RpZnknXSksXG4gIGJvbGQ6IFByb3BUeXBlcy5ib29sLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdncmVlbicsXG4gICAgJ3BpbmUnLFxuICAgICdvbGl2ZScsXG4gICAgJ2JsdWUnLFxuICAgICduYXZ5JyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICdwdXJwbGUnLFxuICAgICdvcmNoaWQnLFxuICAgICdlZ2dwbGFudCcsXG4gICAgJ21hcm9vbicsXG4gICAgJ3dhdGVybWVsb24nLFxuICAgICdvcmFuZ2UnLFxuICAgICdkYXJrR3JheScsXG4gICAgJ2dyYXknLFxuICAgICdsaWdodEdyYXknLFxuICAgICdyZWQnLFxuICAgICd3aGl0ZScsXG4gIF0pLFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBpdGFsaWM6IFByb3BUeXBlcy5ib29sLFxuICBsZWFkaW5nOiBQcm9wVHlwZXMub25lT2YoWyd0YWxsJywgJ3Nob3J0J10pLFxuICBsZ1NpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBtZFNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBvdmVyZmxvdzogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2JyZWFrV29yZCddKSxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHNtU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHRydW5jYXRlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0J1dHRvbi5jc3MnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlFeHBhbmRlZD86IGJvb2xlYW4sXG4gIGFjY2Vzc2liaWxpdHlIYXNwb3B1cD86IGJvb2xlYW4sXG4gIGFjY2Vzc2liaWxpdHlMYWJlbD86IHN0cmluZyxcbiAgY29sb3I/OiAnZ3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd0cmFuc3BhcmVudCcgfCAnd2hpdGUnLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlubGluZT86IGJvb2xlYW4sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2xpY2s/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+IH0pID0+IHZvaWQsXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycsXG4gIHRleHQ6IHN0cmluZyxcbiAgdHlwZT86ICdzdWJtaXQnIHwgJ2J1dHRvbicsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkLFxuICAgIGFjY2Vzc2liaWxpdHlIYXNwb3B1cCxcbiAgICBhY2Nlc3NpYmlsaXR5TGFiZWwsXG4gICAgY29sb3IgPSAnZ3JheScsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBpbmxpbmUgPSBmYWxzZSxcbiAgICBuYW1lLFxuICAgIG9uQ2xpY2ssXG4gICAgc2l6ZSA9ICdtZCcsXG4gICAgdGV4dCxcbiAgICB0eXBlID0gJ2J1dHRvbicsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCB0ZXh0Q29sb3IgPSB7XG4gICAgYmx1ZTogJ3doaXRlJyxcbiAgICBncmF5OiAnZGFya0dyYXknLFxuICAgIHJlZDogJ3doaXRlJyxcbiAgICB0cmFuc3BhcmVudDogJ3doaXRlJyxcbiAgICB3aGl0ZTogJ2RhcmtHcmF5JyxcbiAgfTtcblxuICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhzdHlsZXMuYnV0dG9uLCB7XG4gICAgW3N0eWxlcy5zbV06IHNpemUgPT09ICdzbScsXG4gICAgW3N0eWxlcy5tZF06IHNpemUgPT09ICdtZCcsXG4gICAgW3N0eWxlcy5sZ106IHNpemUgPT09ICdsZycsXG4gICAgW3N0eWxlcy5zb2xpZF06IGNvbG9yICE9PSAndHJhbnNwYXJlbnQnLFxuICAgIFtzdHlsZXNbY29sb3JdXTogIWRpc2FibGVkLFxuICAgIFtzdHlsZXMuZGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICBbc3R5bGVzLmVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgW3N0eWxlcy5pbmxpbmVdOiBpbmxpbmUsXG4gICAgW3N0eWxlcy5ibG9ja106ICFpbmxpbmUsXG4gIH0pO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2J1dHRvbi1oYXMtdHlwZSAqL1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGFyaWEtZXhwYW5kZWQ9e2FjY2Vzc2liaWxpdHlFeHBhbmRlZH1cbiAgICAgIGFyaWEtaGFzcG9wdXA9e2FjY2Vzc2liaWxpdHlIYXNwb3B1cH1cbiAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIG5hbWU9e25hbWV9XG4gICAgICBvbkNsaWNrPXtldmVudCA9PiBvbkNsaWNrICYmIG9uQ2xpY2soeyBldmVudCB9KX1cbiAgICAgIHR5cGU9e3R5cGV9XG4gICAgPlxuICAgICAgPFRleHRcbiAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICBib2xkXG4gICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdncmF5JyA6IHRleHRDb2xvcltjb2xvcl19XG4gICAgICAgIG92ZXJmbG93PVwibm9ybWFsXCJcbiAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgID5cbiAgICAgICAge3RleHR9XG4gICAgICA8L1RleHQ+XG4gICAgPC9idXR0b24+XG4gICk7XG4gIC8qIGVzbGludC1lbmFibGUgcmVhY3QvYnV0dG9uLWhhcy10eXBlICovXG59XG5cbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlFeHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGFjY2Vzc2liaWxpdHlIYXNwb3B1cDogUHJvcFR5cGVzLmJvb2wsXG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2JsdWUnLCAnZ3JheScsICdyZWQnLCAndHJhbnNwYXJlbnQnLCAnd2hpdGUnXSksXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2J1dHRvbicsICdzdWJtaXQnXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NhcmQuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjdGl2ZT86ID9ib29sZWFuLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGltYWdlPzogUmVhY3QuTm9kZSxcbiAgb25Nb3VzZUVudGVyPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uTW91c2VMZWF2ZT86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcmQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaW1hZ2U6IFByb3BUeXBlcy5ub2RlLFxuICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlTW91c2VFbnRlciA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uTW91c2VFbnRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgeyBob3ZlcmVkOiB0cnVlIH0sXG4gICAgICBvbk1vdXNlRW50ZXIgJiYgKCgpID0+IG9uTW91c2VFbnRlcih7IGV2ZW50IH0pKVxuICAgICk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9IChldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uTW91c2VMZWF2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgeyBob3ZlcmVkOiBmYWxzZSB9LFxuICAgICAgb25Nb3VzZUxlYXZlICYmICgoKSA9PiBvbk1vdXNlTGVhdmUoeyBldmVudCB9KSlcbiAgICApO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgY2hpbGRyZW4sIGltYWdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaG92ZXJlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jYXJkLCB7XG4gICAgICAvLyBJZiwgbGlrZSBAY2hyaXNsbG95ZCwgeW91IGNhbid0IHJlbWVtYmVyIEphdmFzY3JpcHQgZXF1YWxpdHkgcnVsZXMsXG4gICAgICAvLyA9PSBudWxsIGNoZWNrcyBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFuZCBsZWF2ZXMgb3V0IGBmYWxzZWAuXG4gICAgICBbc3R5bGVzLmhvdmVyXTogYWN0aXZlIHx8IChhY3RpdmUgPT0gbnVsbCAmJiBob3ZlcmVkKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5oYW5kbGVNb3VzZUVudGVyfVxuICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICA+XG4gICAgICAgIHtpbWFnZSAmJiA8Qm94IG1hcmdpbkJvdHRvbT17MX0+e2ltYWdlfTwvQm94Pn1cbiAgICAgICAgPEJveD57Y2hpbGRyZW59PC9Cb3g+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSAvPlxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DaGVja2JveC5jc3MnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hlY2tlZD86IGJvb2xlYW4sXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpbmRldGVybWluYXRlPzogYm9vbGVhbixcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIGNoZWNrZWQ6IGJvb2xlYW4gfSkgPT4gdm9pZCxcbiAgc2l6ZT86ICdzbScgfCAnbWQnLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBoYXNFcnJvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJ10pLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY2hlY2tlZDogZmFsc2UsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIGhhc0Vycm9yOiBmYWxzZSxcbiAgICBpbmRldGVybWluYXRlOiBmYWxzZSxcbiAgICBzaXplOiAnbWQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIHRoaXMuc2V0SW5kZXRlcm1pbmF0ZSghIXRoaXMucHJvcHMuaW5kZXRlcm1pbmF0ZSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHM6IFByb3BzKSB7XG4gICAgaWYgKHByZXZpb3VzUHJvcHMuaW5kZXRlcm1pbmF0ZSAhPT0gdGhpcy5wcm9wcy5pbmRldGVybWluYXRlKSB7XG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoISF0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmluZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7IGV2ZW50LCBjaGVja2VkIH0pO1xuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcblxuICBpbnB1dDogP0hUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoZWNrZWQsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGhhc0Vycm9yLFxuICAgICAgaWQsXG4gICAgICBpbmRldGVybWluYXRlLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBsZXQgYm9yZGVyU3R5bGUgPSBzdHlsZXMuYm9yZGVyO1xuICAgIGlmICghZGlzYWJsZWQgJiYgKGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZSkpIHtcbiAgICAgIGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlckRhcms7XG4gICAgfSBlbHNlIGlmIChoYXNFcnJvcikge1xuICAgICAgYm9yZGVyU3R5bGUgPSBzdHlsZXMuYm9yZGVyRXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3ggcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuaW5wdXQsIHtcbiAgICAgICAgICAgIFtzdHlsZXMuaW5wdXRFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgW3N0eWxlcy5pbmRldGVybWluYXRlXTogaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgICAgIFtzdHlsZXMuaW5wdXRTbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0TWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICByZWY9e2VsID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBlbDtcbiAgICAgICAgICB9fVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoXG4gICAgICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlcy5jaGVjayxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgPyBjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGUgPyBjb2xvcnMuZ3JheUJnIDogY29sb3JzLmxpZ2h0R3JheUJnXG4gICAgICAgICAgICAgIDogY2hlY2tlZCB8fCBpbmRldGVybWluYXRlID8gY29sb3JzLmRhcmtHcmF5QmcgOiBjb2xvcnMud2hpdGVCZyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgW3N0eWxlcy5jaGVja0VuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgICAgICAgICAgIFtzdHlsZXMuY2hlY2tGb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrU21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICl9XG4gICAgICAgID5cbiAgICAgICAgICB7KGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZSkgJiYgKFxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIGljb249e2luZGV0ZXJtaW5hdGUgPyAnZGFzaCcgOiAnY2hlY2snfVxuICAgICAgICAgICAgICBzaXplPXtzaXplID09PSAnc20nID8gOCA6IDEyfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG4vKlxuICAjIENvbGxlY3Rpb25cblxuICBDb2xsZWN0aW9uIGlzIGNvbXBvbmVudCB0aGF0IGNhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uIGFuZCB2aXJ0dWFsaXplIGl0ZW1zLiBJdCdzIG1lYW50IHRvIGJlIGFuIGV4dGVyZW1seSBzaW1wbGUgd29ya2hvcnNlIHRvIHJlLWltcGxlbWVudCBjdXN0b20gbGF5b3V0cy4gSXQncyBub3QgcGVyZmVjdCBmb3IgYWxsIHNpdHVhdGlvbnMgYnV0IGl0IGRvZXMgaGF2ZSBhIGNsb3NlZCBBUEkgYW5kIGlzIHByZXR0eSBwZXJmb3JtYW50LlxuXG4gICMjIEhvdyBpdCB3b3Jrc1xuXG4gIFRoZXJlIGFyZSB0d28gY2VudHJhbCBjb25jZXB0cyB0byBDb2xsZWN0aW9uIC0gdGhlIGNvbnRlbnQgbGF5ZXIgYW5kIHRoZSB2aWV3cG9ydCBsYXllci5cblxuICBDb250ZW50IGxheWVyICAgICAgICAgICAgICAgVmlld3BvcnQgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlIGxheWVyXG5cbiAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLStcbiAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCArLS0rICstLSsgKy0tKyB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHxcbiAgfCArLS0rIHwgIHwgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgfCAgfCB8ICB8IHxcbiAgfCAgICAgIHwgIHwgKy0tKyB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgICAgfCAgfCArLS18IHxcbiAgfCArLS0rICstLSsgICAgICB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgKy0tKyAgICB8IHxcbiAgfCB8ICB8ICAgICAgKy0tKyB8ICstLS0tLS0+IHwgfCAgICAgICAgICAgIHwgfCArLS0tLS0tPiB8IHwgIHwgICAgICArLS18IHxcbiAgfCArLS0rICstLSsgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgKy0tKyB8ICB8IHxcbiAgfCAgICAgIHwgIHwgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgICAgfCAgfCB8ICB8IHxcbiAgfCArLS0rIHwgIHwgKy0tKyB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgfCAgfCArLS18IHxcbiAgfCB8ICB8IHwgIHwgICAgICB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgIHwgfCAgfCAgICB8IHxcbiAgfCB8ICB8IHwgIHwgKy0tKyB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCArLS0rICstLSsgKy0tKyB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLStcblxuICBZb3UgcG9zaXRpb24geW91ciBpdGVtcyBpbiB0aGUgdmlydHVhbCBjb250ZW50IGxheWVyLCB0aGVuIHlvdSBkZWZpbmUgdGhlIHZpZXdwb3J0IGxheWVyIChieSBkZWZhdWx0IHRoaXMgaXMgdGhlIGZ1bGwgc2l6ZSBvZiB0aGUgY29udGVudCBsYXllcikuIENvbGxlY3Rpb24gdGhlbiB0YWtlcyB0aG9zZSBpdGVtcywgYW5kIHRoZSB2aWV3cG9ydCByZW5kZXJpbmcgdGhlIGNvbnRlbnQgbGF5ZXIgd2l0aCBvbmx5IHRoZSBpdGVtcyB0aGF0IGZpdCBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuXG4gICMjIEFzc3VtcHRpb25zXG5cbiAgMS4gWW91ciBsYXlvdXQgaXMgcHJlLWNhbGN1bGF0ZWQuIENvbGxlY3Rpb24gZXhwZWN0cyBsYXlvdXQgdG8gYmUgcGFzc2VkIGluIGFzIGEgcHJvcGVydHkuIElmIHlvdXIgbGF5b3V0IGlzbid0IHJlYWR5IChpLmUuIHNvbWV0aGluZyBuZWVkcyB0byBiZSBtZWFzdXJlZCkgdGhlIGNhbGxlciBuZWVkcyB0byBmaWd1cmUgdGhhdCBvdXQuXG4gIDIuIFBhc3NlZCBpbiBJdGVtIGFyZSBzb21ld2hhdCBwdXJlIC0gdGhleSBjYW4gYmUgbW91bnRlZCBhbmQgdW5tb3VudGVkIGF0IGFueXRpbWUgc28gSXRlbSdzIGxpZmVjeWNsZSBtZXRob2RzIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgMy4gUGFzc2VkIGluIEl0ZW1zIGFyZSBib3VuZCB0byB0aGVpciBkYXRhLXNvdXJjZSBzZXBlcmF0ZWx5LiBBbGwgdGhleSByZWNlaXZlIGlzIGFuIGluZGV4LCBzbyB0aGV5IG5lZWQgdG8gaGF2ZSBhbnkgZXh0ZXJuYWwgZGF0YSBzb3VyY2VzIGluIHNjb3BlLlxuICA0LiBUaGUgdmlld3BvcnQgY2FuIGJlIGFueSBzaXplLiBNb3N0IHdpbmRvd2luZy9yZWN5Y2xpbmcgc29sdXRpb25zIGltcGxlbWVudCBzb21lIHNvcnQgb2Ygb3ZlcnNjYW5uaW5nLCBob3dldmVyIENvbGxlY3Rpb24gbGVhdmVzIHRoaXMgdXAgdGhlIHRoZSBwYXJlbnQuXG5cbiovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGxheW91dFN0eWxlcyBmcm9tICcuL0xheW91dC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgSXRlbTogKHsgaWR4OiBudW1iZXIgfSkgPT4gUmVhY3QuTm9kZSxcbiAgbGF5b3V0OiBBcnJheTx7fFxuICAgIHRvcDogbnVtYmVyLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICB8fT4sXG4gIHZpZXdwb3J0VG9wPzogbnVtYmVyLFxuICB2aWV3cG9ydExlZnQ/OiBudW1iZXIsXG4gIHZpZXdwb3J0V2lkdGg/OiBudW1iZXIsXG4gIHZpZXdwb3J0SGVpZ2h0PzogbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCB2b2lkPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gICAgSXRlbTogUHJvcFR5cGVzLmFueSxcbiAgICBsYXlvdXQ6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICB9KS5pc1JlcXVpcmVkXG4gICAgKSxcbiAgICB2aWV3cG9ydEhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2aWV3cG9ydExlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmlld3BvcnRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGxheW91dDogW10sXG4gICAgdmlld3BvcnRMZWZ0OiAwLFxuICAgIHZpZXdwb3J0VG9wOiAwLFxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IEl0ZW0sIGxheW91dCwgdmlld3BvcnRUb3AgPSAwLCB2aWV3cG9ydExlZnQgPSAwIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmdWxsIGRpbWVuc2lvbnMgb2YgdGhlIGl0ZW0gbGF5ZXJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KC4uLmxheW91dC5tYXAoaXRlbSA9PiBpdGVtLmxlZnQgKyBpdGVtLndpZHRoKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoLi4ubGF5b3V0Lm1hcChpdGVtID0+IGl0ZW0udG9wICsgaXRlbS5oZWlnaHQpKTtcblxuICAgIC8vIERlZmF1bHQgdGhlIHZpZXdwb3J0IHRvIGJlaW5nIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBjb250ZW50IGxheWVyXG4gICAgY29uc3QgeyB2aWV3cG9ydFdpZHRoID0gd2lkdGgsIHZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2FsY3VsYXRlcyB3aGljaCBpdGVtcyBmcm9tIHRoZSBpdGVtIGxheWVyIHRvIHJlbmRlciBpbiB0aGUgdmlld3BvcnRcbiAgICAvLyBsYXllci5cbiAgICBjb25zdCBpdGVtcyA9IGxheW91dC5yZWR1Y2UoKGFjYywgcG9zaXRpb24sIGlkeCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgPiB2aWV3cG9ydFRvcCAmJlxuICAgICAgICBwb3NpdGlvbi50b3AgPCB2aWV3cG9ydEhlaWdodCArIHZpZXdwb3J0VG9wICYmXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgPCB2aWV3cG9ydFdpZHRoICsgdmlld3BvcnRMZWZ0ICYmXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aCA+IHZpZXdwb3J0TGVmdFxuICAgICAgKSB7XG4gICAgICAgIGFjYy5wdXNoKHsgaWR4LCAuLi5wb3NpdGlvbiB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtsYXlvdXRTdHlsZXMucmVsYXRpdmV9IHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX0+XG4gICAgICAgIHtpdGVtcy5tYXAoKHsgaWR4LCAuLi5zdHlsZSB9KSA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e2lkeH0gY2xhc3NOYW1lPXtsYXlvdXRTdHlsZXMuYWJzb2x1dGV9IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgICA8SXRlbSBpZHg9e2lkeH0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5cbnR5cGUgQ29sdW1uID0gMiB8IDMgfCA0O1xuXG4vKlxuXG5UaGlzIGZ1bmN0aW9uIGp1c3QgaW1wbGVtZW50cyB0aGUgZGVzaWduIGNvbnN0cmFpbnRzIGZvciBhc3ltZXRyaWNhbCBjb2x1bW5zIGluXG5hIHZlcnkgc2ltcGxlIHdheS4gSXQncyBub3QgcGVyZmVjdCwgYnV0IGl0J3MgdmVyeSBwcmVkaWN0aWJsZS4gSWYgeW91IGRvXG5hbnl0aGluZywgaW1wcm92ZSBpdCBzbyB0aGF0IGl0IHRha2VzIHRoZXNlIGNvbnN0cmFpbnRzIGFuZCBnZW5lcmF0ZXMgdGhlbVxuZm9yIG4gPiA0LlxuXG4xICsgbiBjb2x1bW5zOlxuICBmaXJzdCBjb2x1bW4gaXMgNTAvNTBcbiAgY2FuJ3QgaGF2ZSAzIGNvbHVtbnMgaW4gYSByb3cgYmUgNTAvNTBcblxuKi9cbmNvbnN0IFVQID0gWzAuNzUsIDAuMjVdO1xuY29uc3QgRE9XTiA9IFswLjI1LCAwLjc1XTtcbmNvbnN0IE1JRCA9IFswLjUsIDAuNV07XG5jb25zdCBjb2x1bW5MYXlvdXQgPSAobnVtT2ZDb2x1bW5zOiAxIHwgQ29sdW1uKSA9PiB7XG4gIHN3aXRjaCAobnVtT2ZDb2x1bW5zKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtbTUlEXSwgW1VQXSwgW0RPV05dXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW1tVUCwgTUlEXSwgW0RPV04sIE1JRF0sIFtNSUQsIFVQXSwgW01JRCwgRE9XTl1dO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtNSUQsIFVQLCBNSUQsIE1JRF0sXG4gICAgICAgIFtNSUQsIERPV04sIE1JRCwgTUlEXSxcbiAgICAgICAgW01JRCwgTUlELCBVUCwgTUlEXSxcbiAgICAgICAgW01JRCwgTUlELCBET1dOLCBNSURdLFxuICAgICAgICBbTUlELCBVUCwgTUlELCBET1dOXSxcbiAgICAgICAgW01JRCwgRE9XTiwgTUlELCBVUF0sXG4gICAgICBdO1xuICAgIGNhc2UgMzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW01JRCwgVVAsIE1JRF0sXG4gICAgICAgIFtNSUQsIERPV04sIE1JRF0sXG4gICAgICAgIFtNSUQsIE1JRCwgVVBdLFxuICAgICAgICBbTUlELCBNSUQsIERPV05dLFxuICAgICAgXTtcbiAgfVxufTtcblxuY29uc3QgcGFkZGluZ0FsbCA9IChndXR0ZXIsIHBvc2l0aW9ucykgPT5cbiAgcG9zaXRpb25zLm1hcCgoeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aDogd2lkdGggLSBndXR0ZXIsXG4gICAgaGVpZ2h0OiBoZWlnaHQgLSBndXR0ZXIsXG4gIH0pKTtcblxuY29uc3QgbWluZGV4ID0gYXJyID0+XG4gIGFyci5yZWR1Y2UoKG1pbkluZGV4LCBpdGVtLCBpKSA9PiAoaXRlbSA8IGFyclttaW5JbmRleF0gPyBpIDogbWluSW5kZXgpLCAwKTtcblxuY29uc3QgY29sdW1uc0ZvckNvbGxhZ2VXaXRoQ292ZXIgPSAobnVtT2ZDb2x1bW5zOiBDb2x1bW4pID0+XG4gIG51bU9mQ29sdW1ucyA9PT0gNCA/IDIgOiAxO1xuXG5mdW5jdGlvbiBnZXRDb2xsYWdlTGF5b3V0KHtcbiAgZ3V0dGVyLFxuICBjb3ZlcixcbiAgY29sdW1uczogbnVtQ29scyxcbiAgaGVpZ2h0OiBoLFxuICB3aWR0aDogdyxcbiAgbGF5b3V0S2V5LFxufToge1xuICBndXR0ZXI6IG51bWJlcixcbiAgY292ZXI6IGJvb2xlYW4sXG4gIGNvbHVtbnM6IENvbHVtbixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGxheW91dEtleTogbnVtYmVyLFxufSkge1xuICBsZXQgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IHdpZHRoID0gdyArIGd1dHRlcjtcbiAgY29uc3QgaGVpZ2h0ID0gaCArIGd1dHRlcjtcblxuICAvLyBJZiB0aGVyZSdzIGEgY292ZXIgaW1hZ2UsIHdlJ2xsIGFkZCB0aGF0IGxhdGVyLiBJdCBzaG91bGQgYmUgYSBsaXR0bGVcbiAgLy8gbGVzcyB0aGFuIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBjb2xsYWdlLiBXZSBkbyB0aGlzIG5vdyAoYW5kIG5vdCBsYXRlclxuICAvLyB3aGVuIHdlIGFkZCB0aGUgY292ZXIgaW1hZ2UpIGJlY2F1c2Ugb2YgYGNvbHVtbkxheW91dGAncyBjb25zdHJhaW50c1xuICAvLyBuZWVkaW5nIHRoZSBleGFjdCBudW1iZXIgb2YgY29sdW1ucyB0aGF0IGFyZSBkaXNwbGF5ZWQuXG4gIGNvbnN0IGdyaWRDb2xzID0gY292ZXIgPyBjb2x1bW5zRm9yQ29sbGFnZVdpdGhDb3ZlcihudW1Db2xzKSA6IG51bUNvbHM7XG5cbiAgLy8gU2VsZWN0cyB0aGUgbGF5b3V0IHRoYXQgd2UncmUgZ29pbmcgdG8gdXNlIGZvciB0aGUgZ3JpZFxuICBjb25zdCBjb2x1bW5zID0gY29sdW1uTGF5b3V0KGdyaWRDb2xzKTtcbiAgY29uc3QgbGF5b3V0SWR4ID0gbGF5b3V0S2V5ICUgY29sdW1ucy5sZW5ndGg7XG4gIGNvbnN0IGxheW91dCA9IGNvbHVtbnNbbGF5b3V0SWR4XTtcblxuICAvLyBUaGlzIGRvZXMgYSByZWFsbHkgc2ltcGxlIHZlcnNpb24gb2Ygb3VyIG1hc29ucnkgbGF5b3V0LiBXaHkgcmVwbGljYXRlXG4gIC8vIHRoYXQgaGVyZT8gYS4pIGZld2VyIGRlcGVuZGVuY2llcyBhbmQgYi4pIHdlIG5lZWQgdGhlIGFsZ29yaXRobSB0b1xuICAvLyByb3VnaGx5IHByZXNlcnZlIHRoZSBvcmRlciBvZiB0aGUgY29sbGFnZXMgZnJvbSB3aGVuIHRoZXkgd2VyZSBvcmRlcmVkXG4gIC8vIGJ5IE1hc29ucnkuXG4gIGNvbnN0IGNvbEhlaWdodHMgPSBuZXcgQXJyYXkoZ3JpZENvbHMpLmZpbGwoMCk7XG4gIGNvbnN0IGNvbENvdW50cyA9IG5ldyBBcnJheShncmlkQ29scykuZmlsbCgwKTtcblxuICAvLyBXZSBpdGVyYXRlIG92ZXIgZXZlcnkgcG9zaXRpb24gdGhhdCB3ZSB0aGluayB3ZSBjb3VsZCBfcG90ZW50aWFsbHlfIGhhdmVcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZmlsbCB0aGVtIHdpdGggZW1wdHkgc2VjdGlvbnMgaWYgbmVlZCBiZS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICogZ3JpZENvbHM7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNvbCA9IG1pbmRleChjb2xIZWlnaHRzKTtcbiAgICBjb25zdCBjb2xJZHggPSBjb2xDb3VudHNbY29sXTtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gbGF5b3V0W2NvbF1bY29sSWR4XSAqIGhlaWdodDtcblxuICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgIHRvcDogY29sSGVpZ2h0c1tjb2xdLFxuICAgICAgbGVmdDogY29sICogKHdpZHRoIC8gbnVtQ29scyksXG4gICAgICB3aWR0aDogd2lkdGggLyBudW1Db2xzLFxuICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgY29sSGVpZ2h0c1tjb2xdICs9IGl0ZW1IZWlnaHQ7XG4gICAgY29sQ291bnRzW2NvbF0gKz0gMTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBjb3ZlciBpbWFnZSwgZmlndXJlIG91dCBob3cgYmlnIGl0IGlzLCB0aGVuIG1vdmUgYWxsIHRoZVxuICAvLyBleGlzdGluZyBjb2x1bW5zIG92ZXIuXG4gIGlmIChjb3Zlcikge1xuICAgIGNvbnN0IGNvdmVySW1hZ2VXaWR0aCA9IE1hdGguY2VpbChudW1Db2xzIC8gMikgKiAod2lkdGggLyBudW1Db2xzKTtcbiAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMubWFwKHBvc2l0aW9uID0+ICh7XG4gICAgICAuLi5wb3NpdGlvbixcbiAgICAgIGxlZnQ6IGNvdmVySW1hZ2VXaWR0aCArIHBvc2l0aW9uLmxlZnQsXG4gICAgfSkpO1xuICAgIHBvc2l0aW9ucy51bnNoaWZ0KHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogY292ZXJJbWFnZVdpZHRoLCBoZWlnaHQgfSk7XG4gIH1cblxuICAvLyBUaGlzIGFkZHMgdGhlIHNwYWNlIGJldHdlZW4gYW55IGl0ZW1zIHRoYXQgd2UgaGF2ZS4gSXQncyBuaWNlIHRvIGRvXG4gIC8vIHRoaXMgYXMgYSBzZXBhcmF0ZSBwYXNzIGFmdGVyIGV2ZXJ5dGhpbmcgZWxzZSwgYmVjYXVzZSB0aGUgbWF0aCBlYXJsaWVyXG4gIC8vIGJlY29tZXMgZWFzaWVyIGFuZCBpdCdzIGxlc3MgYnJpdHRsZSB0byBjaGFuZ2UuXG4gIGlmIChndXR0ZXIpIHtcbiAgICBwb3NpdGlvbnMgPSBwYWRkaW5nQWxsKGd1dHRlciwgcG9zaXRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjb2x1bW5zOiBDb2x1bW4sXG4gIGNvdmVyPzogYm9vbGVhbixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgbGF5b3V0S2V5PzogbnVtYmVyLFxuICByZW5kZXJJbWFnZTogKHt8XG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgICBpbmRleDogbnVtYmVyLFxuICB8fSkgPT4gUmVhY3QuTm9kZSxcbiAgd2lkdGg6IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2xsYWdlKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBjb3ZlcixcbiAgICBndXR0ZXIsXG4gICAgaGVpZ2h0LFxuICAgIGxheW91dEtleSxcbiAgICByZW5kZXJJbWFnZSxcbiAgICB3aWR0aCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZXRDb2xsYWdlTGF5b3V0KHtcbiAgICBjb2x1bW5zLFxuICAgIGNvdmVyOiAhIWNvdmVyLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBndXR0ZXI6IGd1dHRlciB8fCAwLFxuICAgIGxheW91dEtleTogbGF5b3V0S2V5IHx8IDAsXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxDb2xsZWN0aW9uXG4gICAgICBJdGVtPXsoeyBpZHg6IGluZGV4IH0pID0+XG4gICAgICAgIHJlbmRlckltYWdlKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB3aWR0aDogcG9zaXRpb25zW2luZGV4XS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHBvc2l0aW9uc1tpbmRleF0uaGVpZ2h0LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgbGF5b3V0PXtwb3NpdGlvbnN9XG4gICAgLz5cbiAgKTtcbn1cblxuQ29sbGFnZS5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbnM6IFByb3BUeXBlcy5vbmVPZihbMiwgMywgNF0pLmlzUmVxdWlyZWQsXG4gIGNvdmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ3V0dGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbGF5b3V0S2V5OiBQcm9wVHlwZXMubnVtYmVyLFxuICByZW5kZXJJbWFnZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG4iLCIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbHVtbkNvbHVtbi5jc3MnO1xuXG50eXBlIERlcHJlY2F0ZWRDb2x1bW5zID0gMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IDEyO1xudHlwZSBDb2x1bW5zID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcblxudHlwZSBDb2x1bW5Qcm9wcyA9XG4gIHwge3xcbiAgICAgIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgICAgIHNwYW46IENvbHVtbnMsXG4gICAgICBzbVNwYW4/OiBDb2x1bW5zLFxuICAgICAgbWRTcGFuPzogQ29sdW1ucyxcbiAgICAgIGxnU3Bhbj86IENvbHVtbnMsXG4gICAgfH1cbiAgfCB7fFxuICAgICAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICAgICAgeHM/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICAgIHNtPzogRGVwcmVjYXRlZENvbHVtbnMsXG4gICAgICBtZD86IERlcHJlY2F0ZWRDb2x1bW5zLFxuICAgICAgbGc/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICB8fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29sdW1uKHByb3BzOiBDb2x1bW5Qcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgY3MgPSBjbGFzc25hbWVzKFxuICAgIChwcm9wcy54cyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5zbSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5tZCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5sZyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgc3R5bGVzLmRlcHJlY2F0ZWRDb2x1bW4sXG4gICAgcHJvcHMueHMgJiYgc3R5bGVzW2B4c0NvbCR7cHJvcHMueHN9YF0sXG4gICAgcHJvcHMuc20gJiYgc3R5bGVzW2BzbUNvbCR7cHJvcHMuc219YF0sXG4gICAgcHJvcHMubWQgJiYgc3R5bGVzW2BtZENvbCR7cHJvcHMubWR9YF0sXG4gICAgcHJvcHMubGcgJiYgc3R5bGVzW2BsZ0NvbCR7cHJvcHMubGd9YF0sXG4gICAgcHJvcHMuc3BhbiAhPSBudWxsICYmIHN0eWxlc1tgeHNDb2wke3Byb3BzLnNwYW59YF0sXG4gICAgcHJvcHMuc21TcGFuICE9IG51bGwgJiYgc3R5bGVzW2BzbUNvbCR7cHJvcHMuc21TcGFufWBdLFxuICAgIHByb3BzLm1kU3BhbiAhPSBudWxsICYmIHN0eWxlc1tgbWRDb2wke3Byb3BzLm1kU3Bhbn1gXSxcbiAgICBwcm9wcy5sZ1NwYW4gIT0gbnVsbCAmJiBzdHlsZXNbYGxnQ29sJHtwcm9wcy5sZ1NwYW59YF1cbiAgKTtcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjc30+e2NoaWxkcmVufTwvZGl2Pjtcbn1cblxuQ29sdW1uLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICB4czogUHJvcFR5cGVzLm51bWJlcixcbiAgc206IFByb3BUeXBlcy5udW1iZXIsXG4gIG1kOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc3BhbjogUHJvcFR5cGVzLm51bWJlcixcbiAgc21TcGFuOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtZFNwYW46IFByb3BUeXBlcy5udW1iZXIsXG4gIGxnU3BhbjogUHJvcFR5cGVzLm51bWJlcixcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbnRhaW5lcihwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPEJveCBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiIGRpc3BsYXk9XCJmbGV4XCI+XG4gICAgICA8Qm94IG1heFdpZHRoPXs4MDB9IHdpZHRoPVwiMTAwJVwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vRGl2aWRlci5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaXZpZGVyKCkge1xuICByZXR1cm4gPGhyIGNsYXNzTmFtZT17c3R5bGVzLmRpdmlkZXJ9IC8+O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGRpcmVjdGlvbj86ID8ndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0Jyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhcmV0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gcHJvcHM7XG4gIGxldCBwYXRoO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIHBhdGggPSAnTTAgMCBMMTIgMTIgTDI0IDAnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcGF0aCA9ICdNMjQgMCBMMTIgMTIgTDI0IDI0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgcGF0aCA9ICdNMCAyNCBMMTIgMTIgTDI0IDI0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcGF0aCA9ICdNMCAwIEwxMiAxMiBMMCAyNCc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPlxuICAgICAgPHBhdGggZD17cGF0aH0gLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cblxuQ2FyZXQucHJvcFR5cGVzID0ge1xuICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENhcmV0IGZyb20gJy4vQ2FyZXQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbnRlbnRzLmNzcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5cbi8qIE5lZWRlZCB1bnRpbCB0aGlzIEZsb3cgaXNzdWUgaXMgZml4ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8zODAgKi9cbi8qIGVzbGludCBxdW90ZS1wcm9wczogMCAqL1xuY29uc3QgU1BBQ0VTX0lOREVYX01BUCA9IHtcbiAgJzAnOiAndXAnLFxuICAnMSc6ICdyaWdodCcsXG4gICcyJzogJ2Rvd24nLFxuICAnMyc6ICdsZWZ0Jyxcbn07XG5cbmNvbnN0IERJUl9JTkRFWF9NQVAgPSB7XG4gIHVwOiAwLFxuICByaWdodDogMSxcbiAgZG93bjogMixcbiAgbGVmdDogMyxcbn07XG5cbmNvbnN0IE1BUkdJTiA9IDI0O1xuZXhwb3J0IGNvbnN0IENBUkVUX0hFSUdIVCA9IDI0O1xuY29uc3QgQ0FSRVRfT0ZGU0VUX0ZST01fU0lERSA9IDI0O1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9SQURJVVMgPSA4O1xuXG50eXBlIE1haW5EaXIgPSA/KCd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnKTtcbnR5cGUgU3ViRGlyID0gJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgfCAnbWlkZGxlJztcblxudHlwZSBDbGllbnRSZWN0ID0ge1xuICBib3R0b206IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG59O1xuXG50eXBlIFdpbmRvdyA9IHtcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIHNjcm9sbFk6IG51bWJlcixcbiAgc2Nyb2xsWDogbnVtYmVyLFxufTtcblxudHlwZSBGbHlvdXQgPSB7IGhlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyIH07XG5cbnR5cGUgU2hpZnQgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG5cbnR5cGUgRWRnZVNoaWZ0ID0geyBjYXJldDogU2hpZnQsIGZseW91dDogU2hpZnQgfTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGJnQ29sb3I6ICdibHVlJyB8ICdkYXJrR3JheScgfCAnb3JhbmdlJyB8ICd3aGl0ZScsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25LZXlEb3duOiAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHZvaWQsXG4gIG9uUmVzaXplOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICByZWxhdGl2ZU9mZnNldDoge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gIH0sXG4gIHNob3VsZEZvY3VzPzogYm9vbGVhbixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpZHRoOiBudW1iZXIsXG58fTtcblxudHlwZSBTdGF0ZSA9IHtcbiAgZmx5b3V0T2Zmc2V0OiB7XG4gICAgdG9wOiA/bnVtYmVyLFxuICAgIGxlZnQ6ID9udW1iZXIsXG4gIH0sXG4gIGNhcmV0T2Zmc2V0OiB7XG4gICAgdG9wOiA/bnVtYmVyLFxuICAgIHJpZ2h0OiA/bnVtYmVyLFxuICAgIGJvdHRvbTogP251bWJlcixcbiAgICBsZWZ0OiA/bnVtYmVyLFxuICB9LFxuICBtYWluRGlyOiA/TWFpbkRpcixcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbWFpbiBkaXJlY3Rpb24gdGhlIGZseW91dCBvcGVuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFpbkRpcihcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBpZGVhbERpcmVjdGlvbjogTWFpbkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpbmRvd1NpemU6IFdpbmRvd1xuKSB7XG4gIC8vIENhbGN1bGF0ZXMgdGhlIGF2YWlsYWJsZSBzcGFjZSBpZiB3ZSB3ZXJlIHRvIHBsYWNlIHRoZSBmbHlvdXQgaW4gdGhlIDQgbWFpbiBkaXJlY3Rpb25zXG4gIC8vIHRvIGRldGVybWluZSB3aGljaCAncXVhZHJhbnQnIHRvIHBvc2l0aW9uIHRoZSBmbHlvdXQgaW5zaWRlIG9mXG4gIGxldCB1cCA9IHRyaWdnZXJSZWN0LnRvcCAtIGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUO1xuICBsZXQgcmlnaHQgPVxuICAgIHdpbmRvd1NpemUud2lkdGggLSBmbHlvdXRTaXplLndpZHRoIC0gQ0FSRVRfSEVJR0hUIC0gdHJpZ2dlclJlY3QucmlnaHQ7XG4gIGxldCBkb3duID1cbiAgICB3aW5kb3dTaXplLmhlaWdodCAtIGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUIC0gdHJpZ2dlclJlY3QuYm90dG9tO1xuICBsZXQgbGVmdCA9IHRyaWdnZXJSZWN0LmxlZnQgLSBmbHlvdXRTaXplLndpZHRoIC0gQ0FSRVRfSEVJR0hUO1xuXG4gIC8vIG92ZXJyaWRlcyBhdmFpbGFibGUgc3BhY2Ugd2hlbiB0aGUgdHJpZ2dlciBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuXG4gIC8vIHRyaWdnZXIgaXMgdG9vIGNsb3NlIHRvIHRvcC9ib3R0b20gb2Ygc2NyZWVuIGZvciBsZWZ0ICYgcmlnaHQgZmx5b3V0c1xuICBpZiAoXG4gICAgdHJpZ2dlclJlY3QudG9wIDwgQk9SREVSX1JBRElVUyB8fFxuICAgIHdpbmRvd1NpemUuaGVpZ2h0IC0gdHJpZ2dlclJlY3QuYm90dG9tIDwgQk9SREVSX1JBRElVU1xuICApIHtcbiAgICBsZWZ0ID0gMDtcbiAgICByaWdodCA9IDA7XG4gIH1cblxuICAvLyB0cmlnZ2VyIGlzIHRvbyBjbG9zZSB0byB0aGUgbGVmdC9yaWdodCBvZiBzY3JlZW4gZm9yIHVwICYgZG93biBmbHlvdXRzXG4gIGlmIChcbiAgICB0cmlnZ2VyUmVjdC5sZWZ0IDwgQk9SREVSX1JBRElVUyB8fFxuICAgIHdpbmRvd1NpemUud2lkdGggLSB0cmlnZ2VyUmVjdC5yaWdodCA8IEJPUkRFUl9SQURJVVNcbiAgKSB7XG4gICAgdXAgPSAwO1xuICAgIGRvd24gPSAwO1xuICB9XG5cbiAgY29uc3Qgc3BhY2VzID0gW3VwLCByaWdodCwgZG93biwgbGVmdF07XG5cbiAgLy8gSWRlbnRpZnkgYmVzdCBkaXJlY3Rpb24gb2YgYXZhaWxhYmxlIHNwYWNlc1xuICBjb25zdCBtYXggPSBNYXRoLm1heCguLi5zcGFjZXMpO1xuXG4gIC8vIENob3NlIHRoZSBtYWluIGRpcmVjdGlvbiBmb3IgdGhlIGZseW91dCBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2VzICYgdXNlciBwcmVmZXJlbmNlXG4gIGxldCBtYWluRGlyO1xuICBpZiAoaWRlYWxEaXJlY3Rpb24gJiYgc3BhY2VzW0RJUl9JTkRFWF9NQVBbaWRlYWxEaXJlY3Rpb25dXSA+IDApIHtcbiAgICAvLyB1c2VyIHByZWZcbiAgICBtYWluRGlyID0gaWRlYWxEaXJlY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbm8gZGlyZWN0aW9uIHByZWYsIGNob3NlIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlcmUgaXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlXG4gICAgbWFpbkRpciA9IFNQQUNFU19JTkRFWF9NQVBbc3BhY2VzLmluZGV4T2YobWF4KV07XG4gIH1cbiAgcmV0dXJuIG1haW5EaXI7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgc3ViIGRpcmVjdGlvbiBvZiBob3cgdGhlIGZseW91dCBpcyBwb3NpdGlvbmVkIHdpdGhpbiB0aGUgbWFpbiBkaXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN1YkRpcihcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgbWFpbiBkaXJlY3Rpb24sIGNob3NlIGZyb20gMyBjYXJldCBwbGFjZW1lbnRzIGZvciB0aGF0IGRpcmVjdGlvblxuICBsZXQgb2Zmc2V0O1xuICBsZXQgdHJpZ2dlck1pZDtcbiAgbGV0IHdpbmRvd1NwYWNlQXZhaWxhYmxlO1xuXG4gIGlmIChtYWluRGlyID09PSAncmlnaHQnIHx8IG1haW5EaXIgPT09ICdsZWZ0Jykge1xuICAgIG9mZnNldCA9IGZseW91dFNpemUuaGVpZ2h0IC8gMjtcbiAgICB0cmlnZ2VyTWlkID0gdHJpZ2dlclJlY3QudG9wICsgKHRyaWdnZXJSZWN0LmJvdHRvbSAtIHRyaWdnZXJSZWN0LnRvcCkgLyAyO1xuICAgIHdpbmRvd1NwYWNlQXZhaWxhYmxlID0gd2luZG93U2l6ZS5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gKG1haW5EaXIgPT09ICd1cCcgfHwgbWFpbkRpciA9PT0gJ2Rvd24nKVxuICAgIG9mZnNldCA9IGZseW91dFNpemUud2lkdGggLyAyO1xuICAgIHRyaWdnZXJNaWQgPSB0cmlnZ2VyUmVjdC5sZWZ0ICsgKHRyaWdnZXJSZWN0LnJpZ2h0IC0gdHJpZ2dlclJlY3QubGVmdCkgLyAyO1xuICAgIHdpbmRvd1NwYWNlQXZhaWxhYmxlID0gd2luZG93U2l6ZS53aWR0aDtcbiAgfVxuXG4gIGNvbnN0IGFib3ZlT3JMZWZ0ID0gdHJpZ2dlck1pZCAtIG9mZnNldCAtIE1BUkdJTjtcbiAgY29uc3QgYmVsb3dPclJpZ2h0ID0gd2luZG93U3BhY2VBdmFpbGFibGUgLSB0cmlnZ2VyTWlkIC0gb2Zmc2V0IC0gTUFSR0lOO1xuICBsZXQgc3ViRGlyO1xuICBpZiAoYWJvdmVPckxlZnQgPiAwICYmIGJlbG93T3JSaWdodCA+IDApIHtcbiAgICAvLyBjYXJldCBzaG91bGQgZ28gaW4gbWlkZGxlIGIvYyBpdCBjYW5cbiAgICBzdWJEaXIgPSAnbWlkZGxlJztcbiAgfSBlbHNlIGlmIChiZWxvd09yUmlnaHQgPiAwKSB7XG4gICAgLy8gY2FyZXQgc2hvdWxkIGdvIGF0IHRvcCBmb3IgbGVmdC9yaWdodCBhbmQgbGVmdCBmb3IgdXAvZG93blxuICAgIHN1YkRpciA9IG1haW5EaXIgPT09ICdsZWZ0JyB8fCBtYWluRGlyID09PSAncmlnaHQnID8gJ3VwJyA6ICdsZWZ0JztcbiAgfSBlbHNlIHtcbiAgICAvLyBjYXJldCBzaG91bGQgZ28gYXQgYm90dG9tIGZvciBsZWZ0L3JpZ2h0IGFuZCByaWdodCBmb3IgdXAvZG93blxuICAgIHN1YkRpciA9IG1haW5EaXIgPT09ICdsZWZ0JyB8fCBtYWluRGlyID09PSAncmlnaHQnID8gJ2Rvd24nIDogJ3JpZ2h0JztcbiAgfVxuICByZXR1cm4gc3ViRGlyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCB0aGUgZmx5b3V0ICYgY2FyZXQgbmVlZCB0byBzaGlmdCBvdmVyIHRvIGFsaWduIHdpdGggZGVzaWduc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY0VkZ2VTaGlmdHMoXG4gIHN1YkRpcjogU3ViRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgLy8gVGFyZ2V0IHZhbHVlcyBmb3IgZmx5b3V0IGFuZCBjYXJldCBzaGlmdHNcbiAgbGV0IGZseW91dFZlcnRpY2FsU2hpZnQgPVxuICAgIENBUkVUX09GRlNFVF9GUk9NX1NJREUgLSAodHJpZ2dlclJlY3QuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gIGxldCBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPVxuICAgIENBUkVUX09GRlNFVF9GUk9NX1NJREUgLSAodHJpZ2dlclJlY3Qud2lkdGggLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgbGV0IGNhcmV0VmVydGljYWxTaGlmdCA9IENBUkVUX0hFSUdIVDtcbiAgbGV0IGNhcmV0SG9yaXpvbnRhbFNoaWZ0ID0gQ0FSRVRfSEVJR0hUO1xuXG4gIC8vIENvdmVycyBlZGdlIGNhc2Ugd2hlcmUgdHJpZ2dlciBpcyBpbiBhIGNvcm5lciBhbmQgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGUgY2FyZXRcbiAgLy8gdG8gc29tZXRoaW5nIHNtYWxsZXIgdGhhbiBub3JtYWwgaW4gb3JkZXJcbiAgY29uc3QgaXNDbG9zZVZlcnRpY2FsbHkgPVxuICAgIHRyaWdnZXJSZWN0LnRvcCAtIGZseW91dFZlcnRpY2FsU2hpZnQgPCAwIHx8XG4gICAgdHJpZ2dlclJlY3QuYm90dG9tICsgZmx5b3V0VmVydGljYWxTaGlmdCA+IHdpbmRvd1NpemUuaGVpZ2h0O1xuICBjb25zdCBpc0Nsb3NlSG9yaXpvbnRhbGx5ID1cbiAgICB0cmlnZ2VyUmVjdC5sZWZ0IC0gZmx5b3V0SG9yaXpvbnRhbFNoaWZ0IDwgMCB8fFxuICAgIHRyaWdnZXJSZWN0LnJpZ2h0ICsgZmx5b3V0SG9yaXpvbnRhbFNoaWZ0ID4gd2luZG93U2l6ZS53aWR0aDtcbiAgaWYgKGlzQ2xvc2VWZXJ0aWNhbGx5KSB7XG4gICAgZmx5b3V0VmVydGljYWxTaGlmdCA9XG4gICAgICBCT1JERVJfUkFESVVTIC0gKHRyaWdnZXJSZWN0LmhlaWdodCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIGNhcmV0VmVydGljYWxTaGlmdCA9IEJPUkRFUl9SQURJVVM7XG4gIH1cbiAgaWYgKGlzQ2xvc2VIb3Jpem9udGFsbHkpIHtcbiAgICBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPVxuICAgICAgQk9SREVSX1JBRElVUyAtICh0cmlnZ2VyUmVjdC53aWR0aCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIGNhcmV0SG9yaXpvbnRhbFNoaWZ0ID0gQk9SREVSX1JBRElVUztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmx5b3V0OiB7XG4gICAgICB4OiBmbHlvdXRIb3Jpem9udGFsU2hpZnQsXG4gICAgICB5OiBmbHlvdXRWZXJ0aWNhbFNoaWZ0LFxuICAgIH0sXG4gICAgY2FyZXQ6IHtcbiAgICAgIHg6IGNhcmV0SG9yaXpvbnRhbFNoaWZ0LFxuICAgICAgeTogY2FyZXRWZXJ0aWNhbFNoaWZ0LFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBmbHlvdXQgYW5kIGNhcmV0IG9mZnNldHMgZm9yIHN0eWxpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdE9mZnNldHMoXG4gIGJhc2U6IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9LFxuICBlZGdlU2hpZnQ6IEVkZ2VTaGlmdCxcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICBzdWJEaXI6IFN1YkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3Rcbikge1xuICBsZXQgZmx5b3V0TGVmdCA9IGJhc2UubGVmdDtcbiAgbGV0IGZseW91dFRvcCA9IGJhc2UudG9wO1xuXG4gIGxldCBjYXJldFRvcCA9IG1haW5EaXIgPT09ICdkb3duJyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuICBsZXQgY2FyZXRSaWdodCA9IG1haW5EaXIgPT09ICdsZWZ0JyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuICBsZXQgY2FyZXRCb3R0b20gPSBudWxsO1xuICBsZXQgY2FyZXRMZWZ0ID0gbWFpbkRpciA9PT0gJ3JpZ2h0JyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuXG4gIGlmIChzdWJEaXIgPT09ICd1cCcpIHtcbiAgICBmbHlvdXRUb3AgPSBiYXNlLnRvcCAtIGVkZ2VTaGlmdC5mbHlvdXQueTtcbiAgICBjYXJldFRvcCA9IGVkZ2VTaGlmdC5jYXJldC55O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ2Rvd24nKSB7XG4gICAgZmx5b3V0VG9wID1cbiAgICAgIGJhc2UudG9wIC0gZmx5b3V0U2l6ZS5oZWlnaHQgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgKyBlZGdlU2hpZnQuZmx5b3V0Lnk7XG4gICAgY2FyZXRCb3R0b20gPSBlZGdlU2hpZnQuY2FyZXQueTtcbiAgfSBlbHNlIGlmIChzdWJEaXIgPT09ICdsZWZ0Jykge1xuICAgIGZseW91dExlZnQgPSBiYXNlLmxlZnQgLSBlZGdlU2hpZnQuZmx5b3V0Lng7XG4gICAgY2FyZXRMZWZ0ID0gZWRnZVNoaWZ0LmNhcmV0Lng7XG4gIH0gZWxzZSBpZiAoc3ViRGlyID09PSAncmlnaHQnKSB7XG4gICAgZmx5b3V0TGVmdCA9XG4gICAgICBiYXNlLmxlZnQgLSBmbHlvdXRTaXplLndpZHRoICsgdHJpZ2dlclJlY3Qud2lkdGggKyBlZGdlU2hpZnQuZmx5b3V0Lng7XG4gICAgY2FyZXRSaWdodCA9IGVkZ2VTaGlmdC5jYXJldC54O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ21pZGRsZScpIHtcbiAgICBpZiAobWFpbkRpciA9PT0gJ2xlZnQnIHx8IG1haW5EaXIgPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXJNaWQgPSBmbHlvdXRUb3AgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgZmx5b3V0VG9wID0gdHJpZ2dlck1pZCAtIGZseW91dFNpemUuaGVpZ2h0IC8gMjtcbiAgICAgIGNhcmV0VG9wID0gKGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gICAgfVxuICAgIGlmIChtYWluRGlyID09PSAndXAnIHx8IG1haW5EaXIgPT09ICdkb3duJykge1xuICAgICAgY29uc3QgdHJpZ2dlck1pZCA9IGZseW91dExlZnQgKyB0cmlnZ2VyUmVjdC53aWR0aCAvIDI7XG4gICAgICBmbHlvdXRMZWZ0ID0gdHJpZ2dlck1pZCAtIGZseW91dFNpemUud2lkdGggLyAyO1xuICAgICAgY2FyZXRMZWZ0ID0gKGZseW91dFNpemUud2lkdGggLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZseW91dE9mZnNldDoge1xuICAgICAgdG9wOiBmbHlvdXRUb3AsXG4gICAgICBsZWZ0OiBmbHlvdXRMZWZ0LFxuICAgIH0sXG4gICAgY2FyZXRPZmZzZXQ6IHtcbiAgICAgIHRvcDogY2FyZXRUb3AsXG4gICAgICByaWdodDogY2FyZXRSaWdodCxcbiAgICAgIGJvdHRvbTogY2FyZXRCb3R0b20sXG4gICAgICBsZWZ0OiBjYXJldExlZnQsXG4gICAgfSxcbiAgfTtcbn1cblxuLyogQ2FsY3VsYXRlcyBiYXNlbGluZSB0b3AgYW5kIGxlZnQgb2Zmc2V0IGZvciBmbHlvdXQgKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlT2Zmc2V0cyhcbiAgcmVsYXRpdmVPZmZzZXQ6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSxcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgY29uc3QgSEFMRl9DQVJFVCA9IENBUkVUX0hFSUdIVCAvIDI7XG4gIC8vIFRPUCBPRkZTRVRcbiAgbGV0IHRvcDtcbiAgaWYgKG1haW5EaXIgPT09ICdkb3duJykge1xuICAgIHRvcCA9IHdpbmRvd1NpemUuc2Nyb2xsWSArIHRyaWdnZXJSZWN0LmJvdHRvbSArIEhBTEZfQ0FSRVQ7XG4gIH0gZWxzZSBpZiAobWFpbkRpciA9PT0gJ3VwJykge1xuICAgIHRvcCA9XG4gICAgICB3aW5kb3dTaXplLnNjcm9sbFkgKyAodHJpZ2dlclJlY3QudG9wIC0gZmx5b3V0U2l6ZS5oZWlnaHQgLSBIQUxGX0NBUkVUKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGFuZCByaWdodFxuICAgIHRvcCA9IHdpbmRvd1NpemUuc2Nyb2xsWSArIHRyaWdnZXJSZWN0LnRvcDtcbiAgfVxuXG4gIC8vIExFRlQgT0ZGU0VUXG4gIGxldCBsZWZ0O1xuICBpZiAobWFpbkRpciA9PT0gJ2xlZnQnKSB7XG4gICAgbGVmdCA9XG4gICAgICB3aW5kb3dTaXplLnNjcm9sbFggKyAodHJpZ2dlclJlY3QubGVmdCAtIGZseW91dFNpemUud2lkdGggLSBIQUxGX0NBUkVUKTtcbiAgfSBlbHNlIGlmIChtYWluRGlyID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IHdpbmRvd1NpemUuc2Nyb2xsWCArIHRyaWdnZXJSZWN0LnJpZ2h0ICsgSEFMRl9DQVJFVDtcbiAgfSBlbHNlIHtcbiAgICAvLyBkb3duIGFuZCB1cFxuICAgIGxlZnQgPSB3aW5kb3dTaXplLnNjcm9sbFggKyB0cmlnZ2VyUmVjdC5sZWZ0O1xuICB9XG5cbiAgLy8gQWRqdXN0cyBmb3IgdGhlIHJlbGF0aXZlIHBhcmVudCBjb250YWluZXJcbiAgdG9wIC09IHJlbGF0aXZlT2Zmc2V0Lnk7XG4gIGxlZnQgLT0gcmVsYXRpdmVPZmZzZXQueDtcbiAgcmV0dXJuIHsgdG9wLCBsZWZ0IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZmx5b3V0T2Zmc2V0OiB7XG4gICAgICB0b3A6IHVuZGVmaW5lZCxcbiAgICAgIHJpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHVuZGVmaW5lZCxcbiAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIGNhcmV0T2Zmc2V0OiB7XG4gICAgICB0b3A6IHVuZGVmaW5lZCxcbiAgICAgIHJpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHVuZGVmaW5lZCxcbiAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIG1haW5EaXI6IG51bGwsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRGbHlvdXRQb3NpdGlvbih0aGlzLnByb3BzKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNob3VsZEZvY3VzICYmIHRoaXMuZmx5b3V0KSB7XG4gICAgICAgIHRoaXMuZmx5b3V0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucHJvcHMub25SZXNpemUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9wcy5vbktleURvd24pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IFByb3BzKSB7XG4gICAgdGhpcy5zZXRGbHlvdXRQb3NpdGlvbihuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucHJvcHMub25SZXNpemUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9wcy5vbktleURvd24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG1haW4gZGlyZWNpdG9uLCBzdWIgZGlyZWN0aW9uLCBhbmQgY29ycmVzcG9uZGluZyBvZmZzZXRzIG5lZWRlZFxuICAgKiB0byBjb3JyZWN0bHkgcG9zaXRpb24gdGhlIG9mZnNldFxuICAgKi9cbiAgc2V0Rmx5b3V0UG9zaXRpb24gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVsYXRpdmVPZmZzZXQsXG4gICAgICBpZGVhbERpcmVjdGlvbixcbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcixcbiAgICAgIHRyaWdnZXJSZWN0LFxuICAgICAgd2lkdGgsXG4gICAgfSA9IHByb3BzO1xuXG4gICAgLy8gU2Nyb2xsIG5vdCBuZWVkZWQgZm9yIHJlbGF0aXZlIGVsZW1lbnRzXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5zY3JvbGxYIC8gd2luZG93LnNjcm9sbFkgc2luY2UgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IElFMTFcbiAgICBjb25zdCBzY3JvbGxYID0gcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICA/IDBcbiAgICAgIDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8XG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpIHx8XG4gICAgICAgIDA7XG4gICAgY29uc3Qgc2Nyb2xsWSA9IHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvclxuICAgICAgPyAwXG4gICAgICA6IHdpbmRvdy5wYWdlWU9mZnNldCB8fFxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8XG4gICAgICAgIDA7XG5cbiAgICBjb25zdCB3aW5kb3dTaXplID0ge1xuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBzY3JvbGxYLFxuICAgICAgc2Nyb2xsWSxcbiAgICB9O1xuXG4gICAgY29uc3QgZmx5b3V0U2l6ZSA9IHtcbiAgICAgIGhlaWdodDogdGhpcy5mbHlvdXQgPyB0aGlzLmZseW91dC5jbGllbnRIZWlnaHQgOiAwLFxuICAgICAgd2lkdGgsXG4gICAgfTtcblxuICAgIC8vIEZpcnN0IGNob29zZSBvbmUgb2YgNCBtYWluIGRpcmVjdGlvblxuICAgIGNvbnN0IG1haW5EaXIgPSBnZXRNYWluRGlyKFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgICAgdHJpZ2dlclJlY3QsXG4gICAgICB3aW5kb3dTaXplXG4gICAgKTtcblxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIG1haW4gZGlyZWN0aW9uLCBjaG9zZSBmcm9tIDMgY2FyZXQgcGxhY2VtZW50cyBmb3IgdGhhdCBkaXJlY3Rpb25cbiAgICBjb25zdCBzdWJEaXIgPSBnZXRTdWJEaXIoZmx5b3V0U2l6ZSwgbWFpbkRpciwgdHJpZ2dlclJlY3QsIHdpbmRvd1NpemUpO1xuXG4gICAgLy8gR2V0cyB0aGUgYmFzZSBvZmZzZXQgdGhhdCBwb3NpdGlvbnMgdGhlIGZseW91dCBiYXNlZCBvbiB0aGUgbWFpbiBkaXJlY3Rpb24gb25seVxuICAgIGNvbnN0IGJhc2UgPSBiYXNlT2Zmc2V0cyhcbiAgICAgIHJlbGF0aXZlT2Zmc2V0LFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIG1haW5EaXIsXG4gICAgICB0cmlnZ2VyUmVjdCxcbiAgICAgIHdpbmRvd1NpemVcbiAgICApO1xuXG4gICAgLy8gR2V0cyB0aGUgZWRnZSBzaGlmdHMgZm9yIHRoZSBmbHlvdXRcbiAgICBjb25zdCBlZGdlU2hpZnRzID0gY2FsY0VkZ2VTaGlmdHMoc3ViRGlyLCB0cmlnZ2VyUmVjdCwgd2luZG93U2l6ZSk7XG5cbiAgICAvLyBBZGp1c3RzIGZvciB0aGUgc3ViZGlyZWN0aW9uIG9mIHRoZSBjYXJldFxuICAgIGNvbnN0IHsgZmx5b3V0T2Zmc2V0LCBjYXJldE9mZnNldCB9ID0gYWRqdXN0T2Zmc2V0cyhcbiAgICAgIGJhc2UsXG4gICAgICBlZGdlU2hpZnRzLFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIG1haW5EaXIsXG4gICAgICBzdWJEaXIsXG4gICAgICB0cmlnZ2VyUmVjdFxuICAgICk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNhcmV0T2Zmc2V0LFxuICAgICAgZmx5b3V0T2Zmc2V0LFxuICAgICAgbWFpbkRpcixcbiAgICB9KTtcbiAgfTtcblxuICBmbHlvdXQ6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBiZ0NvbG9yLCBjaGlsZHJlbiwgd2lkdGggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBOZWVkZWQgdG8gcHJldmVudCBVSSB0aHJhc2hpbmdcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5zdGF0ZS5tYWluRGlyID09PSBudWxsID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IGAke2JnQ29sb3J9QmdgO1xuICAgIGNvbnN0IHN0cm9rZSA9IGJnQ29sb3IgPT09ICd3aGl0ZScgPyAnI2VmZWZlZicgOiBudWxsO1xuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gYmdDb2xvciA9PT0gJ3doaXRlJyA/ICdsaWdodEdyYXknIDogYmdDb2xvcjtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn1cbiAgICAgICAgc3R5bGU9e3sgc3Ryb2tlLCB2aXNpYmlsaXR5LCAuLi50aGlzLnN0YXRlLmZseW91dE9mZnNldCB9fVxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKFxuICAgICAgICAgICAgY29sb3JzW2JhY2tncm91bmRdLFxuICAgICAgICAgICAgY29sb3JzW2JvcmRlckNvbG9yXSxcbiAgICAgICAgICAgIHN0eWxlcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgc3R5bGVzLmNvbnRlbnRzXG4gICAgICAgICAgKX1cbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbHlvdXQgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdGFiSW5kZXg9ey0xfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5kaW1lbnNpb25zLCBzdHlsZXMuaW5uZXJDb250ZW50cyl9XG4gICAgICAgICAgICBzdHlsZT17eyB3aWR0aCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoY29sb3JzW2JnQ29sb3JdLCBzdHlsZXMuY2FyZXQpfVxuICAgICAgICAgICAgc3R5bGU9e3sgLi4udGhpcy5zdGF0ZS5jYXJldE9mZnNldCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxDYXJldCBkaXJlY3Rpb249e3RoaXMuc3RhdGUubWFpbkRpcn0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbi8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuQ29udGVudHMucHJvcFR5cGVzID0ge1xuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2RhcmtHcmF5JywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uUmVzaXplOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICByZWxhdGl2ZU9mZnNldDogUHJvcFR5cGVzLmV4YWN0KHsgeDogUHJvcFR5cGVzLm51bWJlciwgeTogUHJvcFR5cGVzLm51bWJlciB9KSxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvdWxkRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICB0cmlnZ2VyUmVjdDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBib3R0b206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgb25DbGljaz86IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZCxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRzaWRlRXZlbnRCZWhhdmlvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2tFdmVudCA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1maW5kLWRvbS1ub2RlXG4gICAgY29uc3QgZWwgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5wcm9wcy5vbkNsaWNrIHx8XG4gICAgICAhZWwgfHxcbiAgICAgIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIGVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb250ZW50cyBmcm9tICcuL0NvbnRlbnRzLmpzJztcbmltcG9ydCBPdXRzaWRlRXZlbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhbmNob3I6ID9IVE1MRWxlbWVudCxcbiAgYmdDb2xvcjogJ2JsdWUnIHwgJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBpZGVhbERpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnLFxuICBvbkRpc21pc3M6ICgpID0+IHZvaWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogYm9vbGVhbixcbiAgc2hvdWxkRm9jdXM/OiBib29sZWFuLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcgfCBudW1iZXIsXG58fTtcblxuY29uc3QgU0laRV9XSURUSF9NQVAgPSB7XG4gIHhzOiAxODUsXG4gIHNtOiAyMzAsXG4gIG1kOiAyODQsXG4gIGxnOiAzMjAsXG4gIHhsOiAzNzUsXG59O1xuXG5jb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcblxudHlwZSBDbGllbnRSZWN0ID0ge1xuICBib3R0b206IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG59O1xuXG50eXBlIFN0YXRlID0ge1xuICByZWxhdGl2ZU9mZnNldDoge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gIH0sXG4gIHRyaWdnZXJCb3VuZGluZ1JlY3Q6IENsaWVudFJlY3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgcmVsYXRpdmVPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgIH0sXG4gICAgdHJpZ2dlckJvdW5kaW5nUmVjdDoge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJSZWN0KHRoaXMucHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IFByb3BzKSB7XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyUmVjdChuZXh0UHJvcHMpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudDogeyBrZXlDb2RlOiBudW1iZXIgfSkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEVfS0VZX0NPREUpIHtcbiAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVBhZ2VDbGljayA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICBpZiAoXG4gICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmXG4gICAgICB0aGlzLnByb3BzLmFuY2hvciAmJlxuICAgICAgIXRoaXMucHJvcHMuYW5jaG9yLmNvbnRhaW5zKGV2ZW50LnRhcmdldClcbiAgICApIHtcbiAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJSZWN0KHRoaXMucHJvcHMpO1xuICB9O1xuXG4gIHVwZGF0ZVRyaWdnZXJSZWN0ID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgYW5jaG9yLCBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IgfSA9IHByb3BzO1xuICAgIGxldCB0cmlnZ2VyQm91bmRpbmdSZWN0O1xuICAgIGxldCByZWxhdGl2ZU9mZnNldDtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0cmlnZ2VyQm91bmRpbmdSZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBOZWVkZWQgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcgd2l0aGluIENvbnRlbnRzLmpzXG4gICAgICByZWxhdGl2ZU9mZnNldCA9IHtcbiAgICAgICAgeDogcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICAgICAgPyB0cmlnZ2VyQm91bmRpbmdSZWN0LmxlZnQgLSBhbmNob3Iub2Zmc2V0TGVmdFxuICAgICAgICAgIDogMCxcbiAgICAgICAgeTogcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICAgICAgPyB0cmlnZ2VyQm91bmRpbmdSZWN0LnRvcCAtIGFuY2hvci5vZmZzZXRUb3BcbiAgICAgICAgICA6IDAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyByZWxhdGl2ZU9mZnNldCwgdHJpZ2dlckJvdW5kaW5nUmVjdCB9KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yLFxuICAgICAgYmdDb2xvcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaWRlYWxEaXJlY3Rpb24sXG4gICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IsXG4gICAgICBzaG91bGRGb2N1cyxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB0aGlzLnByb3BzLnNpemUgPyB0aGlzLnByb3BzLnNpemUgOiAnc20nO1xuICAgIGNvbnN0IHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdzdHJpbmcnID8gU0laRV9XSURUSF9NQVBbc2l6ZV0gOiBzaXplO1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0c2lkZUV2ZW50QmVoYXZpb3Igb25DbGljaz17dGhpcy5oYW5kbGVQYWdlQ2xpY2t9PlxuICAgICAgICA8Q29udGVudHNcbiAgICAgICAgICBiZ0NvbG9yPXtiZ0NvbG9yfVxuICAgICAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbERpcmVjdGlvbn1cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBvblJlc2l6ZT17dGhpcy5oYW5kbGVSZXNpemV9XG4gICAgICAgICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yPXtwb3NpdGlvblJlbGF0aXZlVG9BbmNob3J9XG4gICAgICAgICAgcmVsYXRpdmVPZmZzZXQ9e3RoaXMuc3RhdGUucmVsYXRpdmVPZmZzZXR9XG4gICAgICAgICAgc2hvdWxkRm9jdXM9e3Nob3VsZEZvY3VzfVxuICAgICAgICAgIHRyaWdnZXJSZWN0PXt0aGlzLnN0YXRlLnRyaWdnZXJCb3VuZGluZ1JlY3R9XG4gICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0NvbnRlbnRzPlxuICAgICAgPC9PdXRzaWRlRXZlbnRCZWhhdmlvcj5cbiAgICApO1xuICB9XG59XG5cbkNvbnRyb2xsZXIucHJvcFR5cGVzID0ge1xuICBhbmNob3I6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY29udGFpbnM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIH0pLFxuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2RhcmtHcmF5JywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3VsZEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSwgLy8gZGVmYXVsdDogc21cbiAgXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICBjb2xvcj86ICdibHVlJyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyxcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnIHwgbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZseW91dChwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBjaGlsZHJlbixcbiAgICBpZGVhbERpcmVjdGlvbixcbiAgICBvbkRpc21pc3MsXG4gICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yID0gdHJ1ZSxcbiAgICBjb2xvciA9ICd3aGl0ZScsXG4gICAgc2l6ZSxcbiAgfSA9IHByb3BzO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxDb250cm9sbGVyXG4gICAgICBhbmNob3I9e2FuY2hvcn1cbiAgICAgIGJnQ29sb3I9e2NvbG9yfVxuICAgICAgaWRlYWxEaXJlY3Rpb249e2lkZWFsRGlyZWN0aW9ufVxuICAgICAgb25EaXNtaXNzPXtvbkRpc21pc3N9XG4gICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I9e3Bvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcn1cbiAgICAgIHNob3VsZEZvY3VzPXtjb2xvciAhPT0gJ29yYW5nZSd9XG4gICAgICBzaXplPXtzaXplfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NvbnRyb2xsZXI+XG4gICk7XG59XG5cbkZseW91dC5wcm9wVHlwZXMgPSB7XG4gIGFuY2hvcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjb250YWluczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IFByb3BUeXBlcy5ib29sLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnYmx1ZScsICdvcmFuZ2UnLCAnd2hpdGUnXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksIC8vIGRlZmF1bHQ6IHNtXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0dyb3VwQXZhdGFyLmNzcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJbWFnZSBmcm9tICcuL0ltYWdlLmpzJztcbmltcG9ydCB0eXBvZ3JhcGh5IGZyb20gJy4vVHlwb2dyYXBoeS5jc3MnO1xuXG5mdW5jdGlvbiB6aXAoYSwgYikge1xuICByZXR1cm4gYS5tYXAoKGl0ZW0sIGlkeCkgPT4gW2l0ZW0sIGJbaWR4XV0pO1xufVxuXG5jb25zdCBCT1JERVJfV0lEVEggPSAyO1xuXG5jb25zdCBBVkFUQVJfU0laRVMgPSB7XG4gIHNtOiAyNCxcbiAgbWQ6IDQwLFxuICBsZzogNzIsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgY29sbGFib3JhdG9yczogQXJyYXk8e3xcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgc3JjPzogc3RyaW5nLFxuICB8fT4sXG4gIG91dGxpbmU/OiBib29sZWFuLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxufH07XG5cbmNvbnN0IGF2YXRhckxheW91dCA9IChuLCBzaXplKSA9PiB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IHRvcDogMCwgbGVmdDogMCwgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSwgdGV4dExheW91dDogJ2NlbnRlcicgfSxcbiAgICAgIF07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgdGV4dExheW91dDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IGBjYWxjKDUwJSArICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHdpZHRoOiAnY2FsYyg1MCUpJyxcbiAgICAgICAgICBoZWlnaHQ6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICd0b3BMZWZ0JyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgbGVmdDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgd2lkdGg6ICdjYWxjKDUwJSknLFxuICAgICAgICAgIGhlaWdodDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgdGV4dExheW91dDogJ2JvdHRvbUxlZnQnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgfVxufTtcblxuY29uc3QgZGVnVG9SYWQgPSBkZWcgPT4gZGVnICogKE1hdGguUEkgLyAxODApO1xuXG5jb25zdCBEZWZhdWx0QXZhdGFyID0gKHByb3BzOiB7fFxuICBzaXplOiBzdHJpbmcgfCBudW1iZXIsXG4gIG5hbWU6IHN0cmluZyxcbiAgdGV4dExheW91dDogJ2NlbnRlcicgfCAndG9wTGVmdCcgfCAnYm90dG9tTGVmdCcsXG58fSkgPT4ge1xuICBjb25zdCB7IHNpemUsIG5hbWUsIHRleHRMYXlvdXQgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHF1YXJ0ZXJQYWRkaW5nID0gYGNhbGMoJHtNYXRoLnNpbihkZWdUb1JhZCg0NSkpfSAqICgke3NpemV9KSAvIDIpYDtcblxuICBjb25zdCBpbml0aWFsID0gKFxuICAgIDxzdmdcbiAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICB2aWV3Qm94PVwiLTUwIC01MCAxMDAgMTAwXCJcbiAgICAgIHZlcnNpb249XCIxLjFcIlxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgPlxuICAgICAgPHRpdGxlPntuYW1lfTwvdGl0bGU+XG4gICAgICA8dGV4dFxuICAgICAgICBmb250U2l6ZT1cIjUwcHhcIlxuICAgICAgICBmaWxsPVwiI2ZmZlwiXG4gICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgIHR5cG9ncmFwaHkuYW50aWFsaWFzZWQsXG4gICAgICAgICAgdHlwb2dyYXBoeS5zYW5zU2VyaWYsXG4gICAgICAgICAgdHlwb2dyYXBoeS5sZWFkaW5nU21hbGwsXG4gICAgICAgICAgdHlwb2dyYXBoeS5mb250V2VpZ2h0Qm9sZCxcbiAgICAgICAgXS5qb2luKCcgJyl9XG4gICAgICA+XG4gICAgICAgIHtuYW1lID8gWy4uLm5hbWVdWzBdLnRvVXBwZXJDYXNlKCkgOiAnJ31cbiAgICAgIDwvdGV4dD5cbiAgICA8L3N2Zz5cbiAgKTtcbiAgc3dpdGNoICh0ZXh0TGF5b3V0KSB7XG4gICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgYXJpYS1sYWJlbD17bmFtZX1cbiAgICAgICAgICBjb2xvcj1cImdyYXlcIlxuICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICBhbGlnbkl0ZW1zPVwiZW5kXCJcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAge2luaXRpYWx9XG4gICAgICAgIDwvQm94PlxuICAgICAgKTtcbiAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhcmlhLWxhYmVsPXtuYW1lfVxuICAgICAgICAgIGNvbG9yPVwiZ3JheVwiXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIGFsaWduSXRlbXM9XCJzdGFydFwiXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICBwYWRkaW5nVG9wOiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBxdWFydGVyUGFkZGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtpbml0aWFsfVxuICAgICAgICA8L0JveD5cbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhcmlhLWxhYmVsPXtuYW1lfVxuICAgICAgICAgIGNvbG9yPVwiZ3JheVwiXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCJcbiAgICAgICAgPlxuICAgICAgICAgIHtpbml0aWFsfVxuICAgICAgICA8L0JveD5cbiAgICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdyb3VwQXZhdGFyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNvbGxhYm9yYXRvcnMsIG91dGxpbmUsIHNpemUgfSA9IHByb3BzO1xuICBjb25zdCBhdmF0YXJXaWR0aCA9IHNpemUgPyBBVkFUQVJfU0laRVNbc2l6ZV0gOiAnMTAwJSc7XG4gIGNvbnN0IGF2YXRhckhlaWdodCA9IHNpemUgPyBBVkFUQVJfU0laRVNbc2l6ZV0gOiAnJztcbiAgY29uc3QgcG9zaXRpb25zID0gYXZhdGFyTGF5b3V0KGNvbGxhYm9yYXRvcnMubGVuZ3RoLCBhdmF0YXJXaWR0aCk7XG4gIHJldHVybiAoXG4gICAgPEJveFxuICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICBvdmVyZmxvdz1cImhpZGRlblwiXG4gICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICB3aWR0aD17YXZhdGFyV2lkdGh9XG4gICAgICBoZWlnaHQ9e2F2YXRhckhlaWdodH1cbiAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgLi4uKG91dGxpbmUgPyB7IGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyB9IDoge30pLFxuICAgICAgICAgIC8vIHdpbGxDaGFuZ2U6IHRyYW5zZm9ybSBmaXhlcyBhIHN0cmFuZ2UgYmVoYXZpb3Igd2hlcmUgdGhlIGJvcmRlciBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAvLyBhcmUgbm90IHByb3Blcmx5IHRyaW1tZWQgZXZlbiB0aG91Z2ggb3ZlcmZsb3c6IGhpZGRlbiBpcyBzZXRcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgfSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEJveCBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgcGFkZGluZ0JvdHRvbTogJzEwMCUnIH0gfX0gLz5cbiAgICAgIHt6aXAocG9zaXRpb25zLCBjb2xsYWJvcmF0b3JzKS5tYXAoXG4gICAgICAgIChbcG9zaXRpb24sIGNvbGxhYm9yYXRvciA9IHsgbmFtZTogJycsIHNyYzogdW5kZWZpbmVkIH1dLCBpZHgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCwgdGV4dExheW91dCB9ID0gcG9zaXRpb247XG4gICAgICAgICAgY29uc3QgeyBuYW1lLCBzcmMgfSA9IGNvbGxhYm9yYXRvcjtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBrZXk9e2lkeH1cbiAgICAgICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyB0b3AsIGxlZnQgfSB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7c3JjID8gKFxuICAgICAgICAgICAgICAgIDxJbWFnZVxuICAgICAgICAgICAgICAgICAgYWx0PXtuYW1lfVxuICAgICAgICAgICAgICAgICAgY29sb3I9XCIjRUZFRkVGXCJcbiAgICAgICAgICAgICAgICAgIHNyYz17c3JjfVxuICAgICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoPXsxfVxuICAgICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodD17MX1cbiAgICAgICAgICAgICAgICAgIGZpdD1cImNvdmVyXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxEZWZhdWx0QXZhdGFyXG4gICAgICAgICAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgICAgICAgICAgdGV4dExheW91dD17dGV4dExheW91dH1cbiAgICAgICAgICAgICAgICAgIHNpemU9e2hlaWdodH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndhc2h9IC8+XG4gICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApfVxuICAgIDwvQm94PlxuICApO1xufVxuXG5Hcm91cEF2YXRhci5wcm9wVHlwZXMgPSB7XG4gIGNvbGxhYm9yYXRvcnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgIFByb3BUeXBlcy5leGFjdCh7XG4gICAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgfSlcbiAgKS5pc1JlcXVpcmVkLFxuICBvdXRsaW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSGVhZGluZy5jc3MnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGV2ZWw/OiAxIHwgMiB8IDMgfCA0IHwgNSB8IDYsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgY29sb3I/OlxuICAgIHwgJ2JsdWUnXG4gICAgfCAnZGFya0dyYXknXG4gICAgfCAnZWdncGxhbnQnXG4gICAgfCAnZ3JheSdcbiAgICB8ICdncmVlbidcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAnbWFyb29uJ1xuICAgIHwgJ21pZG5pZ2h0J1xuICAgIHwgJ25hdnknXG4gICAgfCAnb2xpdmUnXG4gICAgfCAnb3JhbmdlJ1xuICAgIHwgJ29yY2hpZCdcbiAgICB8ICdwaW5lJ1xuICAgIHwgJ3B1cnBsZSdcbiAgICB8ICdyZWQnXG4gICAgfCAnd2F0ZXJtZWxvbidcbiAgICB8ICd3aGl0ZScsXG4gIGlkPzogc3RyaW5nLFxuICBsZ1NpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbWRTaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIG92ZXJmbG93PzogJ25vcm1hbCcgfCAnYnJlYWtXb3JkJyxcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBzbVNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgdHJ1bmNhdGU/OiBib29sZWFuLFxufH07XG5cbmNvbnN0IGRlZmF1bHRIZWFkaW5nTGV2ZWxzID0ge1xuICB4czogNSxcbiAgc206IDQsXG4gIG1kOiAzLFxuICBsZzogMixcbiAgeGw6IDEsXG59O1xuXG5jb25zdCBTSVpFX1NDQUxFOiB7IFtzaXplOiA/c3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gIHhzOiAxLFxuICBzbTogMixcbiAgbWQ6IDMsXG4gIGxnOiA0LFxuICB4bDogNSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRpbmcocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhY2Nlc3NpYmlsaXR5TGV2ZWwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29sb3IgPSAnZGFya0dyYXknLFxuICAgIGlkID0gbnVsbCxcbiAgICBsZ1NpemUsXG4gICAgbWRTaXplLFxuICAgIG92ZXJmbG93ID0gJ2JyZWFrV29yZCcsXG4gICAgc2l6ZSA9ICdtZCcsXG4gICAgc21TaXplLFxuICAgIHRydW5jYXRlID0gZmFsc2UsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjcyA9IGN4KFxuICAgIHN0eWxlcy5IZWFkaW5nLFxuICAgIHN0eWxlc1tgZm9udFNpemUke1NJWkVfU0NBTEVbc2l6ZV19YF0sXG4gICAgc21TaXplICYmIHN0eWxlc1tgc21Gb250U2l6ZSR7U0laRV9TQ0FMRVtzbVNpemVdfWBdLFxuICAgIG1kU2l6ZSAmJiBzdHlsZXNbYG1kRm9udFNpemUke1NJWkVfU0NBTEVbbWRTaXplXX1gXSxcbiAgICBsZ1NpemUgJiYgc3R5bGVzW2BsZ0ZvbnRTaXplJHtTSVpFX1NDQUxFW2xnU2l6ZV19YF0sXG4gICAgY29sb3JzW2NvbG9yXSxcbiAgICBvdmVyZmxvdyA9PT0gJ2JyZWFrV29yZCcgJiYgdHlwb2dyYXBoeS5icmVha1dvcmQsXG4gICAgdHJ1bmNhdGUgJiYgdHlwb2dyYXBoeS50cnVuY2F0ZVxuICApO1xuXG4gIGNvbnN0IGhlYWRpbmdMZXZlbCA9IGFjY2Vzc2liaWxpdHlMZXZlbCB8fCBkZWZhdWx0SGVhZGluZ0xldmVsc1tzaXplXTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgYGgke2hlYWRpbmdMZXZlbH1gLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogY3MsXG4gICAgICBpZCxcbiAgICAgIC4uLih0cnVuY2F0ZSAmJiB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnXG4gICAgICAgID8geyB0aXRsZTogY2hpbGRyZW4gfVxuICAgICAgICA6IG51bGwpLFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuSGVhZGluZy5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMZXZlbDogUHJvcFR5cGVzLm9uZU9mKFsxLCAyLCAzLCA0LCA1LCA2XSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ2JsdWUnLFxuICAgICdkYXJrR3JheScsXG4gICAgJ2VnZ3BsYW50JyxcbiAgICAnZ3JheScsXG4gICAgJ2dyZWVuJyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAnbWFyb29uJyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICduYXZ5JyxcbiAgICAnb2xpdmUnLFxuICAgICdvcmFuZ2UnLFxuICAgICdvcmNoaWQnLFxuICAgICdwaW5lJyxcbiAgICAncHVycGxlJyxcbiAgICAncmVkJyxcbiAgICAnd2F0ZXJtZWxvbicsXG4gICAgJ3doaXRlJyxcbiAgXSksXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvdmVyZmxvdzogUHJvcFR5cGVzLm9uZU9mKFsnbm9ybWFsJywgJ2JyZWFrV29yZCddKSxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHNtU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIG1kU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIGxnU2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIHRydW5jYXRlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1BvZy5jc3MnO1xuXG5jb25zdCBTSVpFX05BTUVfVE9fUElYRUwgPSB7XG4gIHhzOiAyNCxcbiAgc206IDMyLFxuICBtZDogNDAsXG4gIGxnOiA0OCxcbiAgeGw6IDU2LFxufTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjdGl2ZT86IGJvb2xlYW4sXG4gIGJnQ29sb3I/OiAndHJhbnNwYXJlbnQnIHwgJ2xpZ2h0R3JheScgfCAnd2hpdGUnLFxuICBmb2N1c2VkPzogYm9vbGVhbixcbiAgaG92ZXJlZD86IGJvb2xlYW4sXG4gIGljb25Db2xvcj86ICdncmF5JyB8ICdkYXJrR3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd3aGl0ZScsXG4gIGljb246ICRLZXlzPHR5cGVvZiBpY29ucz4sXG4gIHNpemU/OiAkS2V5czx0eXBlb2YgU0laRV9OQU1FX1RPX1BJWEVMPixcbnx9O1xuXG5jb25zdCBkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnMgPSB7XG4gIHRyYW5zcGFyZW50OiAnZ3JheScsXG4gIGxpZ2h0R3JheTogJ2dyYXknLFxuICB3aGl0ZTogJ2dyYXknLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUG9nKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWN0aXZlID0gZmFsc2UsXG4gICAgYmdDb2xvciA9ICd0cmFuc3BhcmVudCcsXG4gICAgZm9jdXNlZCA9IGZhbHNlLFxuICAgIGhvdmVyZWQgPSBmYWxzZSxcbiAgICBpY29uQ29sb3IgPSBkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnNbYmdDb2xvcl0sXG4gICAgaWNvbixcbiAgICBzaXplID0gJ21kJyxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGljb25TaXplID0gU0laRV9OQU1FX1RPX1BJWEVMW3NpemVdIC8gMjtcblxuICBjb25zdCBpbmxpbmVTdHlsZSA9IHtcbiAgICBoZWlnaHQ6IFNJWkVfTkFNRV9UT19QSVhFTFtzaXplXSxcbiAgICB3aWR0aDogU0laRV9OQU1FX1RPX1BJWEVMW3NpemVdLFxuICB9O1xuXG4gIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5wb2csIHN0eWxlc1tiZ0NvbG9yXSwge1xuICAgIFtzdHlsZXMuYWN0aXZlXTogYWN0aXZlLFxuICAgIFtzdHlsZXMuZm9jdXNlZF06IGZvY3VzZWQsXG4gICAgW3N0eWxlcy5ob3ZlcmVkXTogaG92ZXJlZCAmJiAhZm9jdXNlZCAmJiAhYWN0aXZlLFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfSBzdHlsZT17aW5saW5lU3R5bGV9PlxuICAgICAgPEJveCBzaGFwZT1cImNpcmNsZVwiPlxuICAgICAgICB7LypcbiAgICAgICAgICBXZSdyZSBleHBsaWNpdGx5IHNldHRpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgbGFiZWwgb24gdGhlIEljb24gc2luY2Ugd2VcbiAgICAgICAgICBhbHJlYWR5IGhhdmUgYW4gYXJpYS1sYWJlbCBvbiB0aGUgYnV0dG9uIGNvbnRhaW5lci5cbiAgICAgICAgICBUaGlzIGlzIHNpbWlsYXIgdG8gaGF2aW5nIGVtcHR5IGBhbHRgIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvYWNjZXNzaWJpbGl0eS10aXAtZW1wdHktYWx0LWF0dHJpYnV0ZXNcbiAgICAgICAgKi99XG4gICAgICAgIDxJY29uXG4gICAgICAgICAgY29sb3I9e2ljb25Db2xvcn1cbiAgICAgICAgICBpY29uPXtpY29ufVxuICAgICAgICAgIHNpemU9e2ljb25TaXplfVxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiXG4gICAgICAgIC8+XG4gICAgICA8L0JveD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuUG9nLnByb3BUeXBlcyA9IHtcbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgYmdDb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsndHJhbnNwYXJlbnQnLCAnbGlnaHRHcmF5JywgJ3doaXRlJ10pLFxuICBmb2N1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaG92ZXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGljb25Db2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZ3JheScsICdkYXJrR3JheScsICdyZWQnLCAnYmx1ZScsICd3aGl0ZSddKSxcbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKGljb25zKSkuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKFNJWkVfTkFNRV9UT19QSVhFTCkpLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0ljb25CdXR0b24uY3NzJztcbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zL2luZGV4LmpzJztcbmltcG9ydCBQb2cgZnJvbSAnLi9Qb2cuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwPzogYm9vbGVhbixcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBzdHJpbmcsXG4gIGJnQ29sb3I/OiAndHJhbnNwYXJlbnQnIHwgJ2xpZ2h0R3JheScgfCAnd2hpdGUnLFxuICBpY29uQ29sb3I/OiAnZ3JheScgfCAnZGFya0dyYXknIHwgJ3JlZCcgfCAnYmx1ZScgfCAnd2hpdGUnLFxuICBpY29uOiAkS2V5czx0eXBlb2YgaWNvbnM+LFxuICBvbkNsaWNrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiB9KSA9PiB2b2lkLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGFjdGl2ZTogYm9vbGVhbixcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgaG92ZXJlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlFeHBhbmRlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWyd0cmFuc3BhcmVudCcsICdsaWdodEdyYXknLCAnd2hpdGUnXSksXG4gICAgaWNvbjogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC5rZXlzKGljb25zKSkuaXNSZXF1aXJlZCxcbiAgICBpY29uQ29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2dyYXknLCAnZGFya0dyYXknLCAncmVkJywgJ2JsdWUnLCAnd2hpdGUnXSksXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnXSksXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZm9jdXNlZDogZmFsc2UsXG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiBmYWxzZSB9KTtcblxuICBoYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZURvd24gPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZUVudGVyID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiBmYWxzZSB9KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkLFxuICAgICAgYWNjZXNzaWJpbGl0eUhhc3BvcHVwLFxuICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsLFxuICAgICAgYmdDb2xvcixcbiAgICAgIGljb25Db2xvcixcbiAgICAgIGljb24sXG4gICAgICBzaXplLFxuICAgICAgb25DbGljayxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgYWN0aXZlLCBmb2N1c2VkLCBob3ZlcmVkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgYXJpYS1leHBhbmRlZD17YWNjZXNzaWJpbGl0eUV4cGFuZGVkfVxuICAgICAgICBhcmlhLWhhc3BvcHVwPXthY2Nlc3NpYmlsaXR5SGFzcG9wdXB9XG4gICAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufVxuICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgb25DbGljaz17ZXZlbnQgPT4gb25DbGljayAmJiBvbkNsaWNrKHsgZXZlbnQgfSl9XG4gICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLmhhbmRsZU1vdXNlRG93bn1cbiAgICAgICAgb25Nb3VzZUVudGVyPXt0aGlzLmhhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICBvbk1vdXNlVXA9e3RoaXMuaGFuZGxlTW91c2VVcH1cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICA+XG4gICAgICAgIDxQb2dcbiAgICAgICAgICBhY3RpdmU9e2FjdGl2ZX1cbiAgICAgICAgICBiZ0NvbG9yPXtiZ0NvbG9yfVxuICAgICAgICAgIGZvY3VzZWQ9e2ZvY3VzZWR9XG4gICAgICAgICAgaG92ZXJlZD17aG92ZXJlZH1cbiAgICAgICAgICBpY29uQ29sb3I9e2ljb25Db2xvcn1cbiAgICAgICAgICBpY29uPXtpY29ufVxuICAgICAgICAgIHNpemU9e3NpemV9XG4gICAgICAgIC8+XG4gICAgICA8L2J1dHRvbj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9MYWJlbC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBodG1sRm9yOiBzdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGFiZWwocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGh0bWxGb3IgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGxhYmVsIGNsYXNzTmFtZT17c3R5bGVzLmxhYmVsfSBodG1sRm9yPXtodG1sRm9yfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2xhYmVsPlxuICApO1xufVxuXG5MYWJlbC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaHRtbEZvcjogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG4gIH1cblxuICBlbDogSFRNTERpdkVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgdGhpcy5lbCk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE1hc2sgZnJvbSAnLi9NYXNrLmpzJztcblxuLypcbiAgTXVjaCBvZiB0aGUgbWF0aCBhbmQgdW5kZXJzdGFuZGluZyBhYm91dCB0aGlzIGNvbXBvbmVudCBjb21lcyBmcm9tIEB2amVhdXgnc1xuICBleGNlbGxlbnQgYmxvZyBwb3N0IG9uIGltYWdlIHJlc2l6aW5nLlxuXG4gIGh0dHA6Ly9ibG9nLnZqZXV4LmNvbS8yMDEzL2ltYWdlL2Nzcy1jb250YWluZXItYW5kLWNvdmVyLmh0bWxcblxuICBJIGhpZ2hseSByZWNvbW1lbmQgeW91IHJlYWQgdGhhdCBmaXJzdCBiZWZvcmUgY29udGludWluZyBvbiByZWFkaW5nLlxuKi9cblxuY29uc3QgYXNwZWN0UmF0aW8gPSAod2lkdGgsIGhlaWdodCkgPT4gd2lkdGggLyBoZWlnaHQ7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbnRlbnRBc3BlY3RSYXRpbzogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgd2lkdGg6IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZXR0ZXJib3goe1xuICBjaGlsZHJlbixcbiAgY29udGVudEFzcGVjdFJhdGlvLFxuICBoZWlnaHQsXG4gIHdpZHRoLFxufTogUHJvcHMpIHtcbiAgY29uc3Qgdmlld3BvcnRBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpO1xuXG4gIGxldCBjb250ZW50SGVpZ2h0O1xuICBsZXQgY29udGVudFdpZHRoO1xuXG4gIGlmIChjb250ZW50QXNwZWN0UmF0aW8gPCB2aWV3cG9ydEFzcGVjdFJhdGlvKSB7XG4gICAgY29udGVudFdpZHRoID0gd2lkdGg7XG4gICAgY29udGVudEhlaWdodCA9IHdpZHRoIC8gY29udGVudEFzcGVjdFJhdGlvO1xuICB9IGVsc2Uge1xuICAgIGNvbnRlbnRXaWR0aCA9IGhlaWdodCAqIGNvbnRlbnRBc3BlY3RSYXRpbztcbiAgICBjb250ZW50SGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0VG9wID0gKGNvbnRlbnRIZWlnaHQgLSBoZWlnaHQpIC8gLTI7XG4gIGNvbnN0IG9mZnNldExlZnQgPSAoY29udGVudFdpZHRoIC0gd2lkdGgpIC8gLTI7XG5cbiAgcmV0dXJuIChcbiAgICA8TWFzayB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fT5cbiAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luVG9wOiBvZmZzZXRUb3AsIG1hcmdpbkxlZnQ6IG9mZnNldExlZnQgfX0+XG4gICAgICAgIDxNYXNrIHdpZHRoPXtjb250ZW50V2lkdGh9IGhlaWdodD17Y29udGVudEhlaWdodH0+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L01hc2s+XG4gICAgICA8L2Rpdj5cbiAgICA8L01hc2s+XG4gICk7XG59XG5cbkxldHRlcmJveC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY29udGVudEFzcGVjdFJhdGlvOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xpbmsuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaHJlZjogc3RyaW5nLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBvbkNsaWNrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiB9KSA9PiB2b2lkLFxuICB0YXJnZXQ/OiBudWxsIHwgJ3NlbGYnIHwgJ2JsYW5rJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZW5hYmxlRm9jdXNTdHlsZXM6IGJvb2xlYW4sXG58fTtcblxuY29uc3QgVEFCX0tFWV9DT0RFID0gOTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB0YXJnZXQ6IFByb3BUeXBlcy5vbmVPZihbbnVsbCwgJ3NlbGYnLCAnYmxhbmsnXSksXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGVuYWJsZUZvY3VzU3R5bGVzOiB0cnVlLFxuICB9O1xuXG4gIGhhbmRsZUNsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IGhyZWYsIG9uQ2xpY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uQ2xpY2sgJiYgaHJlZikge1xuICAgICAgb25DbGljayh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVNb3VzZURvd24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBocmVmLCB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRhcmdldCA9PT0gJ2JsYW5rJyAmJiBocmVmKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZW5hYmxlRm9jdXNTdHlsZXM6IGZhbHNlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlVcCA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBocmVmLCB0YXJnZXQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHRhcmdldCA9PT0gJ2JsYW5rJyAmJiBldmVudC5rZXlDb2RlID09PSBUQUJfS0VZX0NPREUgJiYgaHJlZikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVuYWJsZUZvY3VzU3R5bGVzOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaW5saW5lID0gZmFsc2UsIHRhcmdldCA9IG51bGwsIGhyZWYgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcmVsID0gdGFyZ2V0ID09PSAnYmxhbmsnID8gJ25vb3BlbmVyIG5vcmVmZXJyZXInIDogbnVsbDtcbiAgICBjb25zdCBsaW5rVGFyZ2V0ID0gdGFyZ2V0ID8gYF8ke3RhcmdldH1gIDogbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8YVxuICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgIHN0eWxlcy5saW5rLFxuICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlRm9jdXNTdHlsZXMgPyBzdHlsZXMuYWNjZXNzaWJsZUZvY3VzU3R5bGUgOiAnJyxcbiAgICAgICAgICBpbmxpbmUgPyAnJyA6IHN0eWxlcy5ibG9ja1xuICAgICAgICApfVxuICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5oYW5kbGVNb3VzZURvd259XG4gICAgICAgIG9uS2V5VXA9e3RoaXMuaGFuZGxlS2V5VXB9XG4gICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlbD17cmVsfVxuICAgICAgICB0YXJnZXQ9e2xpbmtUYXJnZXR9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvYT5cbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIEZldGNoSXRlbXMgaXMgYSBsb2dpYyBjb21wb25lbnQgdGhhdCByZW5kZXJzIG5vIGNvbnRlbnQgaXRzZWxmLiBJdHMgam9iXG4gKiBpcyB0byBtYW5hZ2Ugd2hlbiB0aGUgZ2l2ZW4gZmV0Y2hNb3JlIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJhc2VkIG9uXG4gKiB0aGUgZ2l2ZW4gc2Nyb2xsL3NpemUgcHJvcHMuXG4gKlxuICogV2hpbGUgbm8gZWxlbWVudCBpcyBhY3R1YWxseSBwYXNzZWQgdG8gRmV0Y2hJdGVtcywgaXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICogaW4gY29uanVuY3Rpb24gd2l0aCBhIGxhcmdlIHNjcm9sbCBjb250YWluZXIgdGhhdCB1c2VzIGFzeW5jIGZldGNoaW5nIHRvXG4gKiBsb2FkIGFuZCByZW5kZXIgYWRkaXRpb25hbCBkYXRhLiBCYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIHRoaXMgY29udGFpbmVyIGFuZFxuICogaXRzIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBGZXRjaEl0ZW1zIGlzIHJlc3BvbnNpYmxlIGZvciB0cmlnZ2VyaW5nIGZ1dHVyZVxuICogZmV0Y2ggY2FsbHMuXG4gKi9cblxuLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyLFxuICBpc0F0RW5kPzogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgZmV0Y2hNb3JlPzogKCkgPT4gdm9pZCxcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXIsXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmV0Y2hJdGVtcyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjb250YWluZXJIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBpc0F0RW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc0ZldGNoaW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIGZldGNoTW9yZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2Nyb2xsSGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc2Nyb2xsVG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgc2V0VGltZW91dCh0aGlzLmNoZWNrKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBjaGVjayA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICBpc0F0RW5kLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGZldGNoTW9yZSxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpc0F0RW5kIHx8IGlzRmV0Y2hpbmcgfHwgIWZldGNoTW9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxCdWZmZXIgPSBjb250YWluZXJIZWlnaHQgKiAzO1xuXG4gICAgaWYgKHNjcm9sbFRvcCArIHNjcm9sbEJ1ZmZlciA+IHNjcm9sbEhlaWdodCkge1xuICAgICAgZmV0Y2hNb3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVhc3VyZW1lbnRTdG9yZTxULCBWPiBpbXBsZW1lbnRzIENhY2hlPFQsIFY+IHtcbiAgbWFwOiBXZWFrTWFwPFQsIFY+ID0gbmV3IFdlYWtNYXAoKTtcblxuICBnZXQoa2V5OiBUKTogP1Yge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgfVxuXG4gIGhhcyhrZXk6IFQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSk7XG4gIH1cblxuICBzZXQoa2V5OiBULCB2YWx1ZTogVik6IHZvaWQge1xuICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBkZWJvdW5jZSBwcmV2ZW50cyBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gZnJvbSBiZWluZyBjYWxsZWQgdW50aWwgYWZ0ZXIgYSBnaXZlblxuICogY29vbGRvd24gcGVyaW9kIChkZWZhdWx0IDEwMG1zKS4gRXZlcnkgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCByZXNldHNcbiAqIHRoZSBjb29sZG93bi5cbiAqL1xuXG4vLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoXG4gIGZuOiAoLi4uYXJnczogKikgPT4gdm9pZCxcbiAgdGhyZXNoaG9sZDogbnVtYmVyID0gMTAwXG4pIHtcbiAgbGV0IGRlZmVyVGltZXI6IFRpbWVvdXRJRCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzOiAqKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG5cbiAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkZWZlclRpbWVyID0gbnVsbDtcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgIH0sIHRocmVzaGhvbGQpO1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhclRpbWVvdXQgPSAoKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbiIsIi8qKlxuICogU2Nyb2xsQ29udGFpbmVyIGlzIGEgcGFzcy10aHJvdWdoIGNvbXBvbmVudCB0aGF0IHNpbXBseSBzZXRzIHVwIGFuIG9uU2Nyb2xsXG4gKiBoYW5kbGVyIG9uIHRoZSBnaXZlbiBzY3JvbGxDb250YWluZXIgZWxlbWVudCAob3IgdGhlIGVsZW1lbnQgdGhhdCBpc1xuICogcmV0dXJuZWQgYXMgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIHNjcm9sbENvbnRhaW5lciBtZXRob2QpLiBUaGlzIGFsbG93cyBmb3JcbiAqIHRoZSBldmVudCBsaXN0ZW5lciBzdWJzY3JpcHRpb24gb2YgdGhlIHNjcm9sbENvbnRhaW5lciB0byBiZSBtYW5hZ2VkIGluc2lkZVxuICogdGhlIFJlYWN0IGxpZmVjeWNsZSB3aXRob3V0IGFkZGluZyBibG9hdCB0byBNYXNvbnJ5IG9yIG90aGVyIG9uU2Nyb2xsXG4gKiBzdWJzY3JpYmVycy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBDb21wb25lbnQgcmVuZGVycyBpdHMgY2hpbGRyZW4gd2l0aG91dCBjcmVhdGluZyBhbnlcbiAqIGFkZGl0aW9uYWwgY29udGVudC4gQWxzbyBub3RlIHRoYXQsIHdoaWxlIHRoZSBjb21wb25lbnQgaXMgYnVpbHQgdG8gbWFuYWdlXG4gKiBvblNjcm9sbCBpbnNpZGUgb2YgdGhlIFJlYWN0IGxpZmVjeWNsZSwgaXQgZG9lc24ndCBjaGFuZ2Ugb25TY3JvbGwgZXZlbnRzXG4gKiBvciB0aGUgQVBJIGF0IGFsbCwgc28gaXQgY291bGQgZWFzaWx5IGJlIGFkYXB0ZWQgdG8gb3RoZXIgZXZlbnQgdHlwZXMuXG4gKi9cblxuLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIG9uU2Nyb2xsOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkLFxuICBzY3JvbGxDb250YWluZXI6ID9IVE1MRWxlbWVudCB8ICgoKSA9PiA/SFRNTEVsZW1lbnQpLFxufH07XG5cbmZ1bmN0aW9uIGdldFNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY3JvbGxDb250YWluZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcm9sbENvbnRhaW5lcigpXG4gICAgOiBzY3JvbGxDb250YWluZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbENvbnRhaW5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAgIG9uU2Nyb2xsOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKVxuICAgICAgLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gZ2V0U2Nyb2xsQ29udGFpbmVyKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKTtcbiAgICBpZiAoc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U2Nyb2xsQ29udGFpbmVyID0gZ2V0U2Nyb2xsQ29udGFpbmVyKHRoaXMucHJvcHMuc2Nyb2xsQ29udGFpbmVyKTtcbiAgICBpZiAobmV4dFNjcm9sbENvbnRhaW5lciAmJiBuZXh0U2Nyb2xsQ29udGFpbmVyICE9PSB0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGxDb250YWluZXIobmV4dFNjcm9sbENvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2Nyb2xsQ29udGFpbmVyUmVmID0gKCkgPT4gdGhpcy5zY3JvbGxDb250YWluZXI7XG5cbiAgaGFuZGxlU2Nyb2xsID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25TY3JvbGwoZXZlbnQpO1xuICB9O1xuXG4gIHVwZGF0ZVNjcm9sbENvbnRhaW5lcihzY3JvbGxDb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAvLyBjbGVhbnVwIGV4aXN0aW5nIHNjcm9sbCBjb250YWluZXIgaWYgaXQgZXhpc3RzXG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyO1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxuXG4gIHNjcm9sbENvbnRhaW5lcjogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufVxuIiwiLyoqXG4gKiB0aHJvdHRsZSBsaW1pdHMgdGhlIG51bWJlciBvZiB0aW1lcyBhIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gYVxuICogZ2l2ZW4gdGhyZXNoaG9sZCAoMTAwbXMgYnkgZGVmYXVsdCkuIFRoZSBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkXG4gKiBvbiB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgZWRnZS5cbiAqL1xuXG4vLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyb3R0bGUoXG4gIGZuOiAoLi4uYXJnczogKikgPT4gdm9pZCxcbiAgdGhyZXNoaG9sZDogbnVtYmVyID0gMTAwXG4pIHtcbiAgbGV0IGxhc3Q6IG51bWJlciB8IHZvaWQ7XG4gIGxldCBkZWZlclRpbWVyOiBUaW1lb3V0SUQgfCB2b2lkO1xuICBjb25zdCB0aHJvdHRsZWQgPSAoLi4uYXJnczogKikgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKGxhc3QgIT09IHVuZGVmaW5lZCAmJiBub3cgLSBsYXN0IDwgdGhyZXNoaG9sZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgIH0sIHRocmVzaGhvbGQgLSAobm93IC0gbGFzdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfVxuICB9O1xuXG4gIHRocm90dGxlZC5jbGVhclRpbWVvdXQgPSAoKSA9PiB7XG4gICAgaWYgKGRlZmVyVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cbiIsIi8qKlxuICogTWVhc3VyaW5nIHNjcm9sbCBwb3NpdGlvbnMsIGVsZW1lbnQgaGVpZ2h0cywgZXRjIGlzIGRpZmZlcmVudCBiZXR3ZWVuXG4gKiBkaWZmZXJlbnQgYnJvd3NlcnMgYW5kIHRoZSB3aW5kb3cgb2JqZWN0IHZzIG90aGVyIERPTSBub2Rlcy4gVGhlc2VcbiAqIHV0aWxzIGFic3RyYWN0IGF3YXkgdGhlc2UgZGlmZmVyZW5jZXMuXG4gKi9cblxuLy8gQGZsb3dcbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50SGVpZ2h0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsUG9zKCkge1xuICBpZiAod2luZG93LnNjcm9sbFkgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyXG4gICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICB9XG4gIGlmIChcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgLy8gSUUgc3VwcG9ydC5cbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGF0aXZlU2Nyb2xsVG9wKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IHdpbmRvd1xuICAgID8gZ2V0V2luZG93U2Nyb2xsUG9zKClcbiAgICA6IGVsZW1lbnQuc2Nyb2xsVG9wIC0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICByZXR1cm4gZWxlbWVudCA9PT0gd2luZG93ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgIDogZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxQb3MoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICByZXR1cm4gZWxlbWVudCA9PT0gd2luZG93ID8gZ2V0V2luZG93U2Nyb2xsUG9zKCkgOiBlbGVtZW50LnNjcm9sbFRvcDtcbn1cbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3QgRGVmYXVsdExheW91dFN5bWJvbCA9IFN5bWJvbCgnZGVmYXVsdCcpO1xuZXhwb3J0IGNvbnN0IFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wgPSBTeW1ib2woJ3VuaWZvcm1Sb3cnKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5cbmV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge1xuICB0b3A6IG51bWJlcixcbiAgbGVmdDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbn07XG5cbmNvbnN0IG1pbmRleCA9IGFyciA9PiB7XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhcnJbaV0gPCBhcnJbaWR4XSkge1xuICAgICAgaWR4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkeDtcbn07XG5cbmNvbnN0IG9mZnNjcmVlbiA9ICh3aWR0aCwgaGVpZ2h0ID0gSW5maW5pdHkpID0+ICh7XG4gIHRvcDogLTk5OTksXG4gIGxlZnQ6IC05OTk5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IDxUPih7XG4gIGNhY2hlLFxuICBjb2x1bW5XaWR0aCA9IDIzNixcbiAgZ3V0dGVyID0gMTQsXG4gIG1pbkNvbHMgPSAyLFxuICB3aWR0aCxcbn06IHt8XG4gIGNvbHVtbldpZHRoPzogbnVtYmVyLFxuICBndXR0ZXI/OiBudW1iZXIsXG4gIGNhY2hlOiBDYWNoZTxULCBudW1iZXI+LFxuICBtaW5Db2xzPzogbnVtYmVyLFxuICB3aWR0aD86ID9udW1iZXIsXG58fSkgPT4gKGl0ZW1zOiBBcnJheTwqPik6IEFycmF5PFBvc2l0aW9uPiA9PiB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoKSA9PiBvZmZzY3JlZW4oY29sdW1uV2lkdGgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbHVtbldpZHRoQW5kR3V0dGVyID0gY29sdW1uV2lkdGggKyBndXR0ZXI7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggKyBndXR0ZXIpIC8gY29sdW1uV2lkdGhBbmRHdXR0ZXIpLFxuICAgIG1pbkNvbHNcbiAgKTtcbiAgLy8gdGhlIHRvdGFsIGhlaWdodCBvZiBlYWNoIGNvbHVtblxuICBjb25zdCBoZWlnaHRzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KS5maWxsKDApO1xuICBjb25zdCBjZW50ZXJPZmZzZXQgPSBNYXRoLm1heChcbiAgICBNYXRoLmZsb29yKCh3aWR0aCAtIGNvbHVtbldpZHRoQW5kR3V0dGVyICogY29sdW1uQ291bnQgKyBndXR0ZXIpIC8gMiksXG4gICAgMFxuICApO1xuXG4gIHJldHVybiBpdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGFjYztcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FjaGUuZ2V0KGl0ZW0pO1xuICAgIGxldCBwb3NpdGlvbjtcblxuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcG9zaXRpb24gPSBvZmZzY3JlZW4oY29sdW1uV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHRBbmRHdXR0ZXIgPSBoZWlnaHQgKyBndXR0ZXI7XG4gICAgICBjb25zdCBjb2wgPSBtaW5kZXgoaGVpZ2h0cyk7XG4gICAgICBjb25zdCB0b3AgPSBoZWlnaHRzW2NvbF07XG4gICAgICBjb25zdCBsZWZ0ID0gY29sICogY29sdW1uV2lkdGhBbmRHdXR0ZXIgKyBjZW50ZXJPZmZzZXQ7XG5cbiAgICAgIGhlaWdodHNbY29sXSArPSBoZWlnaHRBbmRHdXR0ZXI7XG4gICAgICBwb3NpdGlvbiA9IHsgdG9wLCBsZWZ0LCB3aWR0aDogY29sdW1uV2lkdGgsIGhlaWdodCB9O1xuICAgIH1cbiAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfSwgW10pO1xufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZS5qcyc7XG5cbnR5cGUgUG9zaXRpb24gPSB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH07XG5cbmNvbnN0IG9mZnNjcmVlbiA9ICh3aWR0aCwgaGVpZ2h0ID0gSW5maW5pdHkpID0+ICh7XG4gIHRvcDogLTk5OTksXG4gIGxlZnQ6IC05OTk5LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IDxUPih7XG4gIGNhY2hlLFxuICBjb2x1bW5XaWR0aCA9IDIzNixcbiAgZ3V0dGVyID0gMTQsXG4gIHdpZHRoLFxuICBtaW5Db2xzID0gMyxcbn06IHt8XG4gIGNhY2hlOiBDYWNoZTxULCBudW1iZXI+LFxuICBjb2x1bW5XaWR0aD86IG51bWJlcixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICB3aWR0aD86ID9udW1iZXIsXG4gIG1pbkNvbHM/OiBudW1iZXIsXG58fSkgPT4gKGl0ZW1zOiBBcnJheTxUPik6IEFycmF5PFBvc2l0aW9uPiA9PiB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoKSA9PiBvZmZzY3JlZW4oY29sdW1uV2lkdGgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbHVtbldpZHRoQW5kR3V0dGVyID0gY29sdW1uV2lkdGggKyBndXR0ZXI7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gTWF0aC5tYXgoXG4gICAgTWF0aC5mbG9vcigod2lkdGggKyBndXR0ZXIpIC8gY29sdW1uV2lkdGhBbmRHdXR0ZXIpLFxuICAgIG1pbkNvbHNcbiAgKTtcblxuICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FjaGUuZ2V0KGl0ZW1zW2ldKTtcblxuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgcG9zaXRpb24gPSBvZmZzY3JlZW4oY29sdW1uV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBpICUgY29sdW1uQ291bnQ7XG4gICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKGkgLyBjb2x1bW5Db3VudCk7XG5cbiAgICAgIGlmIChjb2x1bW4gPT09IDAgfHwgaGVpZ2h0ID4gaGVpZ2h0c1tyb3ddKSB7XG4gICAgICAgIGhlaWdodHNbcm93XSA9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9wID1cbiAgICAgICAgcm93ID4gMFxuICAgICAgICAgID8gaGVpZ2h0cy5zbGljZSgwLCByb3cpLnJlZHVjZSgoc3VtLCB5KSA9PiBzdW0gKyB5ICsgZ3V0dGVyLCAwKVxuICAgICAgICAgIDogMDtcblxuICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdDogY29sdW1uICogY29sdW1uV2lkdGhBbmRHdXR0ZXIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9XG4gICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbnM7XG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxudHlwZSBQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTtcblxuY29uc3QgbWluZGV4ID0gYXJyID0+IHtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFycltpXSA8IGFycltpZHhdKSB7XG4gICAgICBpZHggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWR4O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KHtcbiAgZ3V0dGVyID0gMCxcbiAgY2FjaGUsXG4gIG1pbkNvbHMgPSAyLFxuICBpZGVhbENvbHVtbldpZHRoID0gMjQwLFxuICB3aWR0aCxcbn06IHt8XG4gIGd1dHRlcj86IG51bWJlcixcbiAgY2FjaGU6IENhY2hlPFQsIG51bWJlcj4sXG4gIG1pbkNvbHM/OiBudW1iZXIsXG4gIGlkZWFsQ29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIHdpZHRoPzogP251bWJlcixcbnx9KSA9PiB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIChpdGVtczogQXJyYXk8bWl4ZWQ+KTogQXJyYXk8UG9zaXRpb24+ID0+XG4gICAgICBpdGVtcy5tYXAoKCkgPT4gKHtcbiAgICAgICAgdG9wOiBJbmZpbml0eSxcbiAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgIHdpZHRoOiBJbmZpbml0eSxcbiAgICAgICAgaGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgIH0pKTtcbiAgfVxuXG4gIC8vIFwiVGhpcyBpcyBraW5kIG9mIGNyYXp5IVwiIC0geW91XG4gIC8vIFllcywgaW5kZWVkLiBUaGUgXCJndWVzc2luZ1wiIGhlcmUgaXMgbWVhbnQgdG8gcmVwbGljYXRlIHRoZSBwYXNzIHRoYXQgdGhlXG4gIC8vIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIHRha2VzIHdpdGggQ1NTLlxuICBjb25zdCBjb2xndWVzcyA9IE1hdGguZmxvb3Iod2lkdGggLyBpZGVhbENvbHVtbldpZHRoKTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBNYXRoLm1heChcbiAgICBNYXRoLmZsb29yKCh3aWR0aCAtIGNvbGd1ZXNzICogZ3V0dGVyKSAvIGlkZWFsQ29sdW1uV2lkdGgpLFxuICAgIG1pbkNvbHNcbiAgKTtcbiAgY29uc3QgY29sdW1uV2lkdGggPSBNYXRoLmZsb29yKHdpZHRoIC8gY29sdW1uQ291bnQpO1xuXG4gIHJldHVybiAoaXRlbXM6IEFycmF5PFQ+KSA9PiB7XG4gICAgLy8gdGhlIHRvdGFsIGhlaWdodCBvZiBlYWNoIGNvbHVtblxuICAgIGNvbnN0IGhlaWdodHMgPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpLmZpbGwoMCk7XG5cbiAgICByZXR1cm4gaXRlbXMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGFjYztcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNhY2hlLmdldChpdGVtKTtcbiAgICAgIGxldCBwb3NpdGlvbjtcblxuICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgIHRvcDogSW5maW5pdHksXG4gICAgICAgICAgbGVmdDogSW5maW5pdHksXG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogSW5maW5pdHksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2wgPSBtaW5kZXgoaGVpZ2h0cyk7XG4gICAgICAgIGNvbnN0IHRvcCA9IGhlaWdodHNbY29sXTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGNvbCAqIGNvbHVtbldpZHRoICsgZ3V0dGVyIC8gMjtcblxuICAgICAgICBoZWlnaHRzW2NvbF0gKz0gaGVpZ2h0O1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGggLSBndXR0ZXIsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sIFtdKTtcbiAgfTtcbn07XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzb25yeUxheW91dCB7fVxuIiwiLy8gQGZsb3dcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaWZvcm1Sb3dMYXlvdXQge31cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc29ucnkuY3NzJztcbmltcG9ydCBTY3JvbGxDb250YWluZXIgZnJvbSAnLi9TY3JvbGxDb250YWluZXIuanMnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJy4vdGhyb3R0bGUuanMnO1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCB7XG4gIGdldEVsZW1lbnRIZWlnaHQsXG4gIGdldFJlbGF0aXZlU2Nyb2xsVG9wLFxuICBnZXRTY3JvbGxQb3MsXG59IGZyb20gJy4vc2Nyb2xsVXRpbHMuanMnO1xuaW1wb3J0IHtcbiAgRGVmYXVsdExheW91dFN5bWJvbCxcbiAgVW5pZm9ybVJvd0xheW91dFN5bWJvbCxcbn0gZnJvbSAnLi9sZWdhY3lMYXlvdXRTeW1ib2xzLmpzJztcbmltcG9ydCBkZWZhdWx0TGF5b3V0LCB7IHR5cGUgUG9zaXRpb24gfSBmcm9tICcuL2RlZmF1bHRMYXlvdXQuanMnO1xuaW1wb3J0IHVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi91bmlmb3JtUm93TGF5b3V0LmpzJztcbmltcG9ydCBmdWxsV2lkdGhMYXlvdXQgZnJvbSAnLi9mdWxsV2lkdGhMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeU1hc29ucnlMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL01hc29ucnlMYXlvdXQuanMnO1xuaW1wb3J0IExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQgZnJvbSAnLi9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMnO1xuXG50eXBlIExheW91dCA9XG4gIHwgdHlwZW9mIERlZmF1bHRMYXlvdXRTeW1ib2xcbiAgfCB0eXBlb2YgVW5pZm9ybVJvd0xheW91dFN5bWJvbFxuICB8IExlZ2FjeU1hc29ucnlMYXlvdXRcbiAgfCBMZWdhY3lVbmlmb3JtUm93TGF5b3V0O1xuXG5leHBvcnQgdHlwZSBNZWFzdXJlbWVudFN0YXRlID0gJ2lkbGUnIHwgJ21lYXN1cmluZyc7XG5cbmV4cG9ydCB0eXBlIFByb3BzPFQ+ID0ge3xcbiAgY29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIGNvbXA6IFJlYWN0LkNvbXBvbmVudFR5cGU8e1xuICAgIGRhdGE6IFQsXG4gICAgaXRlbUlkeDogbnVtYmVyLFxuICAgIGlzTWVhc3VyaW5nOiBib29sZWFuLFxuICB9PixcbiAgZmxleGlibGU/OiBib29sZWFuLFxuICBndXR0ZXJXaWR0aD86IG51bWJlcixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBtZWFzdXJlbWVudFN0b3JlOiBDYWNoZTxULCAqPixcbiAgbWluQ29sczogbnVtYmVyLFxuICAvLyBDb250ZW50IGxheWVyIGFuZCBWaWV3cG9ydCBsYXllciBpcyBhcyBkZWZpbmVkIGluIENvbGxlY3Rpb24uXG4gIG9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGU/OiAoXG4gICAgY29udGVudDogUG9zaXRpb24sXG4gICAgdmlld3BvcnQ6IFBvc2l0aW9uXG4gICkgPT4gdm9pZCxcbiAgb25BdXRvTWVhc3VyaW5nVXBkYXRlPzogKHN0YXRlOiBNZWFzdXJlbWVudFN0YXRlKSA9PiB2b2lkLFxuICBsYXlvdXQ/OiBMYXlvdXQsXG4gIC8vIFN1cHBvcnQgbGVnYWN5IGxvYWRJdGVtcyB1c2FnZS5cbiAgLy8gVE9ETzogU2ltcGxpZnkgbm9uIGZhbHNleSBmbG93dHlwZS5cbiAgbG9hZEl0ZW1zPzpcbiAgICB8IGZhbHNlXG4gICAgfCAoKFxuICAgICAgICA/e1xuICAgICAgICAgIGZyb206IG51bWJlcixcbiAgICAgICAgfVxuICAgICAgKSA9PiB2b2lkIHwgYm9vbGVhbiB8IHt9KSxcbiAgc2Nyb2xsQ29udGFpbmVyPzogKCkgPT4gSFRNTEVsZW1lbnQsXG4gIHZpcnR1YWxCb3VuZHNUb3A/OiBudW1iZXIsXG4gIHZpcnR1YWxCb3VuZHNCb3R0b20/OiBudW1iZXIsXG4gIHZpcnR1YWxpemU/OiBib29sZWFuLFxufH07XG5cbnR5cGUgU3RhdGU8VD4gPSB7fFxuICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBib29sZWFuLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgaXRlbXM6IEFycmF5PFQ+LFxuICBpdGVtc1RvTWVhc3VyZTogQXJyYXk8VD4sXG4gIGl0ZW1zVG9SZW5kZXI6IEFycmF5PFQ+LFxuICBtZWFzdXJpbmdQb3NpdGlvbnM6IEFycmF5PFBvc2l0aW9uPixcbiAgcmVuZGVyUG9zaXRpb25zOiBBcnJheTxQb3NpdGlvbj4sXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxuICB3aWR0aDogP251bWJlcixcbnx9O1xuXG5jb25zdCBSRVNJWkVfREVCT1VOQ0UgPSAzMDA7XG4vLyBNdWx0aXBsaWVkIGFnYWluc3QgY29udGFpbmVyIGhlaWdodC5cbi8vIFRoZSBhbW91bnQgb2YgZXh0cmEgYnVmZmVyIHNwYWNlIGZvciBwb3B1bGF0aW5nIHZpc2libGUgaXRlbXMuXG5jb25zdCBWSVJUVUFMX0JVRkZFUl9GQUNUT1IgPSAwLjc7XG5cbmNvbnN0IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uID0gbiA9PiAobiAhPT0gSW5maW5pdHkgPyBuIDogdW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gbGF5b3V0Q2xhc3M8VD4oXG4gIHtcbiAgICBjb2x1bW5XaWR0aCxcbiAgICBmbGV4aWJsZSxcbiAgICBndXR0ZXJXaWR0aDogZ3V0dGVyLFxuICAgIGxheW91dCxcbiAgICBtZWFzdXJlbWVudFN0b3JlLFxuICAgIG1pbkNvbHMsXG4gIH06IFByb3BzPFQ+LFxuICB7IHdpZHRoIH06IFN0YXRlPFQ+XG4pIHtcbiAgaWYgKGZsZXhpYmxlICYmIHdpZHRoICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bGxXaWR0aExheW91dCh7XG4gICAgICBndXR0ZXIsXG4gICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgIG1pbkNvbHMsXG4gICAgICBpZGVhbENvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgIHdpZHRoLFxuICAgIH0pO1xuICB9XG4gIGlmIChcbiAgICBsYXlvdXQgPT09IFVuaWZvcm1Sb3dMYXlvdXRTeW1ib2wgfHxcbiAgICBsYXlvdXQgaW5zdGFuY2VvZiBMZWdhY3lVbmlmb3JtUm93TGF5b3V0XG4gICkge1xuICAgIHJldHVybiB1bmlmb3JtUm93TGF5b3V0KHtcbiAgICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgY29sdW1uV2lkdGgsXG4gICAgICBndXR0ZXIsXG4gICAgICBtaW5Db2xzLFxuICAgICAgd2lkdGgsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRMYXlvdXQoe1xuICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgIGNvbHVtbldpZHRoLFxuICAgIGd1dHRlcixcbiAgICBtaW5Db2xzLFxuICAgIHdpZHRoLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RhdGVzRm9yUmVuZGVyaW5nPFQ+KHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gIGNvbnN0IHsgbWVhc3VyZW1lbnRTdG9yZSwgbWluQ29scyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgaXRlbXMgfSA9IHN0YXRlO1xuXG4gIC8vIEZ1bGwgbGF5b3V0IGlzIHBvc3NpYmxlXG4gIGNvbnN0IGl0ZW1zVG9SZW5kZXIgPSBpdGVtcy5maWx0ZXIoXG4gICAgaXRlbSA9PiBpdGVtICYmIG1lYXN1cmVtZW50U3RvcmUuaGFzKGl0ZW0pXG4gICk7XG5cbiAgY29uc3QgbGF5b3V0ID0gbGF5b3V0Q2xhc3MocHJvcHMsIHN0YXRlKTtcbiAgY29uc3QgcmVuZGVyUG9zaXRpb25zID0gbGF5b3V0KGl0ZW1zVG9SZW5kZXIpO1xuICAvLyBNYXRoLm1heCgpID09PSAtSW5maW5pdHkgd2hlbiB0aGVyZSBhcmUgbm8gcmVuZGVyUG9zaXRpb25zXG4gIGNvbnN0IGhlaWdodCA9IHJlbmRlclBvc2l0aW9ucy5sZW5ndGhcbiAgICA/IE1hdGgubWF4KC4uLnJlbmRlclBvc2l0aW9ucy5tYXAocG9zID0+IHBvcy50b3AgKyBwb3MuaGVpZ2h0KSlcbiAgICA6IDA7XG5cbiAgY29uc3QgaXRlbXNUb01lYXN1cmUgPSBpdGVtc1xuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKSlcbiAgICAuc2xpY2UoMCwgbWluQ29scyk7XG4gIGNvbnN0IG1lYXN1cmluZ1Bvc2l0aW9ucyA9IGxheW91dChpdGVtc1RvTWVhc3VyZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgaXRlbXNUb1JlbmRlcixcbiAgICBpdGVtc1RvTWVhc3VyZSxcbiAgICBtZWFzdXJpbmdQb3NpdGlvbnMsXG4gICAgcmVuZGVyUG9zaXRpb25zLFxuICB9O1xufVxuXG4vKipcbiAqIFRPRE8gdGhpcyBzaG91bGQgYmUgcmVuYW1lZCB0byBNYXNyb255QmV0YSBvciBzb21ldGhpbmcgZWxzZSBzbyBpdCBpcyBjbGVhclxuICogdGhhdCB0aGlzIGlzIG5vdCB0aGUgZXhwb3J0ZWQgTWFzb25yeS5cbiAqXG4gKiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IG5vdCBoYXZlIGFueSBzY3JvbGwgZmV0Y2hpbmcgY29uY2VybnMgaW4gdGhpcyBjb21wb25lbnQuXG4gKiBUaGUgbmFtZSBpcyBrZXB0IGZvciBub3cgdG8gaGF2ZSBhbiBlYXNpZXIgdGltZSBzZWVpbmcgdGhlIGRpZmZzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5PFQ+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPFQ+LCBTdGF0ZTxUPj4ge1xuICAvKipcbiAgICogRGVsYXlzIHJlc2l6ZSBoYW5kbGluZyBpbiBjYXNlIHRoZSBzY3JvbGwgY29udGFpbmVyIGlzIHN0aWxsIGJlaW5nIHJlc2l6ZWQuXG4gICAqL1xuICBoYW5kbGVSZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgaWYgKHRoaXMuZ3JpZFdyYXBwZXIpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyB3aWR0aDogdGhpcy5ncmlkV3JhcHBlci5jbGllbnRXaWR0aCB9KTtcbiAgICB9XG4gIH0sIFJFU0laRV9ERUJPVU5DRSk7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb24gPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxDb250YWluZXJSZWYoKTtcblxuICAgIGlmICghc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzY3JvbGxUb3A6IGdldFNjcm9sbFBvcyhzY3JvbGxDb250YWluZXIpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5oYW5kbGVWaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZSgpO1xuICB9KTtcblxuICBtZWFzdXJlQ29udGFpbmVyQXN5bmMgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG4gIH0sIDApO1xuXG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByZWZlcnJlZC90YXJnZXQgaXRlbSB3aWR0aC4gSWYgYGZsZXhpYmxlYCBpcyBzZXQsIHRoZSBpdGVtIHdpZHRoIHdpbGxcbiAgICAgKiBncm93IHRvIGZpbGwgY29sdW1uIHNwYWNlLCBhbmQgc2hyaW5rIHRvIGZpdCBpZiBiZWxvdyBtaW4gY29sdW1ucy5cbiAgICAgKi9cbiAgICBjb2x1bW5XaWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wb25lbnQgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIC8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuICAgIGNvbXA6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJdGVtIHdpZHRoIHdpbGwgZ3JvdyB0byBmaWxsXG4gICAgICogY29sdW1uIHNwYWNlLCBhbmQgc2hyaW5rIHRvIGZpdCBpZiBiZWxvdyBtaW4gY29sdW1ucy5cbiAgICAgKi9cbiAgICBmbGV4aWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gZWFjaCBpdGVtLlxuICAgICAqL1xuICAgIGd1dHRlcldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgdG8gZGlzcGxheSBpbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHt9KSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmVtZW50IFN0b3JlXG4gICAgICovXG4gICAgbWVhc3VyZW1lbnRTdG9yZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoTWVhc3VyZW1lbnRTdG9yZSksXG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgc3lzdGVtIHRvIHVzZSBmb3IgaXRlbXNcbiAgICAgKi9cbiAgICBsYXlvdXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoTGVnYWN5TWFzb25yeUxheW91dCksXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lVbmlmb3JtUm93TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5zeW1ib2wsXG4gICAgXSksXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIHRoZSBncmlkIGNhbGxzIHdoZW4gd2UgbmVlZCB0byBsb2FkIG1vcmUgaXRlbXMgYXMgdGhlIHVzZXIgc2Nyb2xscy5cbiAgICAgKiBUaGUgY2FsbGJhY2sgc2hvdWxkIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGl0ZW1zLCBhbmQgcGFzcyB0aG9zZSBpbiBhcyBwcm9wc1xuICAgICAqIHRvIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGxvYWRJdGVtczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIG51bWJlciBvZiBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gICAgICovXG4gICAgbWluQ29sczogUHJvcFR5cGVzLm51bWJlcixcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhlIGdyaWQgY2FsbHMgdG8gZ2V0IHRoZSBzY3JvbGwgY29udGFpbmVyLlxuICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgaWYgdGhlIGdyaWQgaXMgZXhwZWN0ZWQgdG8gYmUgc2Nyb2xsYWJsZS5cbiAgICAgKi9cbiAgICBzY3JvbGxDb250YWluZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdG8gdXNlIGFjdHVhbCB2aXJ0dWFsaXphdGlvblxuICAgICAqL1xuICAgIHZpcnR1YWxpemU6IFByb3BUeXBlcy5ib29sLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29sdW1uV2lkdGg6IDIzNixcbiAgICBtZWFzdXJlbWVudFN0b3JlOiBuZXcgTWVhc3VyZW1lbnRTdG9yZSgpLFxuICAgIG1pbkNvbHM6IDMsXG4gICAgbGF5b3V0OiBEZWZhdWx0TGF5b3V0U3ltYm9sLFxuICAgIGxvYWRJdGVtczogKCkgPT4ge30sXG4gICAgdmlydHVhbGl6ZTogZmFsc2UsXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzPFQ+KSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSAwO1xuICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBwcm9wcy5pdGVtcy5zb21lKFxuICAgICAgICBpdGVtID0+ICEhaXRlbSAmJiAhcHJvcHMubWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICAgICksXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBpdGVtc1RvUmVuZGVyOiBbXSxcbiAgICAgIGl0ZW1zVG9NZWFzdXJlOiBbXSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby11bnVzZWQtc3RhdGVcbiAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgIG1lYXN1cmluZ1Bvc2l0aW9uczogW10sXG4gICAgICByZW5kZXJQb3NpdGlvbnM6IFtdLFxuICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaG9va3MgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG5cbiAgICBsZXQgeyBzY3JvbGxUb3AgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICBzY3JvbGxUb3AgPSBnZXRTY3JvbGxQb3Moc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgc2Nyb2xsVG9wLFxuICAgICAgd2lkdGg6IHRoaXMuZ3JpZFdyYXBwZXIgPyB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIDogcHJldlN0YXRlLndpZHRoLFxuICAgIH0pKTtcblxuICAgIC8vIG5lZWQgdG8gbWFrZSBzdXJlIHBhcmVudCBjb21wb25lbnQgaGFzIHRoZSBjb3JyZWN0IHBlbmRpbmcgbWVhc3VyZW1lbnQgdmFsdWVcbiAgICB0aGlzLmhhbmRsZU9uQXV0b01lYXN1cmluZ1VwZGF0ZShcbiAgICAgIHRoaXMuc3RhdGUuaGFzUGVuZGluZ01lYXN1cmVtZW50cyA/ICdtZWFzdXJpbmcnIDogJ2lkbGUnXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzPFQ+LCBwcmV2U3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lckFzeW5jKCk7XG5cbiAgICBpZiAocHJldlN0YXRlLndpZHRoICE9IG51bGwgJiYgdGhpcy5zdGF0ZS53aWR0aCAhPT0gcHJldlN0YXRlLndpZHRoKSB7XG4gICAgICBtZWFzdXJlbWVudFN0b3JlLnJlc2V0KCk7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB3aGV0aGVyIHdlIHN0aWxsIGhhdmUgcGVuZGluZyBtZWFzdXJlbWVudHNcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gaXRlbXMuc29tZShcbiAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICk7XG5cbiAgICBpZiAoaGFzUGVuZGluZ01lYXN1cmVtZW50cyAmJiAhcHJldlN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIHRoaXMuaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlKCdtZWFzdXJpbmcnKTtcbiAgICB9IGVsc2UgaWYgKCFoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICYmIHByZXZTdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICB0aGlzLmhhbmRsZU9uQXV0b01lYXN1cmluZ1VwZGF0ZSgnaWRsZScpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlKCk7XG5cbiAgICBpZiAoXG4gICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzIHx8XG4gICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSB0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMgfHxcbiAgICAgIHByZXZTdGF0ZS53aWR0aCA9PSBudWxsXG4gICAgKSB7XG4gICAgICB0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyaW5nU3RhdGVzID0gc3RhdGVzRm9yUmVuZGVyaW5nKHRoaXMucHJvcHMsIHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIC4uLnJlbmRlcmluZ1N0YXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgfHwgcHJldlN0YXRlLml0ZW1zICE9PSBpdGVtcykge1xuICAgICAgdGhpcy5pbnNlcnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmluZ1N0YXRlcyA9IHN0YXRlc0ZvclJlbmRlcmluZyh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IC4uLnJlbmRlcmluZ1N0YXRlcyB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIHdoZW4gdW5tb3VudGluZy5cbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmluc2VydEFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgYXN5bmMgbWV0aG9kcyBhcmUgY2FuY2VsbGVkLlxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lckFzeW5jLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb24uY2xlYXJUaW1lb3V0KCk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wczogUHJvcHM8VD4sIHN0YXRlOiBTdGF0ZTxUPikge1xuICAgIGNvbnN0IHsgaXRlbXMsIG1lYXN1cmVtZW50U3RvcmUgfSA9IHByb3BzO1xuICAgIC8vIHdoZW5ldmVyIHdlJ3JlIHJlY2VpdmluZyBuZXcgcHJvcHMsIGRldGVybWluZSB3aGV0aGVyIGFueSBpdGVtcyBuZWVkIHRvIGJlIG1lYXN1cmVkXG4gICAgLy8gVE9ETyAtIHdlIHNob3VsZCB0cmVhdCBpdGVtcyBhcyBpbW11dGFibGVcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gaXRlbXMuc29tZShcbiAgICAgIGl0ZW0gPT4gaXRlbSAmJiAhbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICApO1xuXG4gICAgLy8gU2hhbGxvdyBjb21wYXJlIGFsbCBpdGVtcywgaWYgYW55IGNoYW5nZSByZWZsb3cgdGhlIGdyaWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIG91ciBjdXJyZW50IHByb3BzIGFuZCBldmVyeXRoaW5nIG1hdGNoZXMuXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhpcyBjYXNlIGl0IG1lYW5zIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBpdGVtcy5cbiAgICAgIGlmIChzdGF0ZS5pdGVtc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgZ3JpZCBpdGVtcyB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbiBpdGVtIG9iamVjdCByZWYgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgIGl0ZW1zW2ldICE9PSBzdGF0ZS5pdGVtc1tpXSB8fFxuICAgICAgICAvLyBPciBsZXNzIGl0ZW1zIHRoYW4gd2UgY3VycmVudGx5IGhhdmUgYXJlIHBhc3NlZCBpbi5cbiAgICAgICAgaXRlbXMubGVuZ3RoIDwgc3RhdGUuaXRlbXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIGl0ZW1zLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGl0ZW1zIGlmIG5ldyBpdGVtcyBhcnJheSBpcyBlbXB0eS5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHN0YXRlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgIT09IHN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHMpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhbHdheXMgdXBkYXRlIGhhc1BlbmRpbmdNZWFzdXJlbWVudHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzZXRHcmlkV3JhcHBlclJlZiA9IChyZWY6ID9IVE1MRWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZ3JpZFdyYXBwZXIgPSByZWY7XG4gIH07XG5cbiAgc2V0U2Nyb2xsQ29udGFpbmVyUmVmID0gKHJlZjogP1Njcm9sbENvbnRhaW5lcikgPT4ge1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyID0gcmVmO1xuICB9O1xuXG4gIGhhbmRsZVZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdGhpcy5wcm9wcy5vblZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0aGlzLmNvbnRhaW5lckhlaWdodFxuICAgICkge1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSB7XG4gICAgICAgIHRvcDogdGhpcy5zdGF0ZS5zY3JvbGxUb3AsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb250YWluZXJIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCB8fCAwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgIHRvcDogdGhpcy5jb250YWluZXJPZmZzZXQsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IDAsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnByb3BzLm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUoY29udGVudCwgdmlld3BvcnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUgPSAoc3RhdGU6IE1lYXN1cmVtZW50U3RhdGUpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkF1dG9NZWFzdXJpbmdVcGRhdGUpIHtcbiAgICAgIHRoaXMucHJvcHMub25BdXRvTWVhc3VyaW5nVXBkYXRlKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG5cbiAgY29udGFpbmVyT2Zmc2V0OiBudW1iZXI7XG5cbiAgZ3JpZFdyYXBwZXI6ID9IVE1MRWxlbWVudDtcblxuICBpbnNlcnRBbmltYXRpb25GcmFtZTogQW5pbWF0aW9uRnJhbWVJRDtcblxuICBtZWFzdXJlVGltZW91dDogVGltZW91dElEO1xuXG4gIHNjcm9sbENvbnRhaW5lcjogP1Njcm9sbENvbnRhaW5lcjtcblxuICBtZWFzdXJlQ29udGFpbmVyKCkge1xuICAgIGlmICh0aGlzLnNjcm9sbENvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7IHNjcm9sbENvbnRhaW5lciB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclJlZiA9IHNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxDb250YWluZXJSZWYoKTtcbiAgICAgIGlmIChzY3JvbGxDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBnZXRFbGVtZW50SGVpZ2h0KHNjcm9sbENvbnRhaW5lclJlZik7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5ncmlkV3JhcHBlcjtcbiAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVNjcm9sbFRvcCA9IGdldFJlbGF0aXZlU2Nyb2xsVG9wKHNjcm9sbENvbnRhaW5lclJlZik7XG4gICAgICAgICAgdGhpcy5jb250YWluZXJPZmZzZXQgPVxuICAgICAgICAgICAgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgcmVsYXRpdmVTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgbWVhc3VyZW1lbnRzL3Bvc2l0aW9ucyBhbmQgZm9yY2UgYSByZWZsb3cgb2YgdGhlIGVudGlyZSBncmlkLlxuICAgKiBPbmx5IHVzZSB0aGlzIGlmIGFic29sdXRlbHkgbmVjZXNzYXJ5IC0gZXg6IFdlIG5lZWQgdG8gcmVmbG93IGl0ZW1zIGlmIHRoZVxuICAgKiBudW1iZXIgb2YgY29sdW1ucyB3ZSB3b3VsZCBkaXNwbGF5IHNob3VsZCBjaGFuZ2UgYWZ0ZXIgYSByZXNpemUuXG4gICAqL1xuICByZWZsb3coKSB7XG4gICAgdGhpcy5wcm9wcy5tZWFzdXJlbWVudFN0b3JlLnJlc2V0KCk7XG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG4gICAgdGhpcy5oYW5kbGVWaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZSgpO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlck1hc29ucnlDb21wb25lbnQgPSAoaXRlbURhdGE6IFQsIGlkeDogbnVtYmVyLCBwb3NpdGlvbjogKikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXA6IENvbXBvbmVudCxcbiAgICAgIHZpcnR1YWxpemUsXG4gICAgICB2aXJ0dWFsQm91bmRzVG9wLFxuICAgICAgdmlydHVhbEJvdW5kc0JvdHRvbSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gcG9zaXRpb247XG5cbiAgICBsZXQgaXNWaXNpYmxlO1xuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgY29uc3QgdmlydHVhbEJ1ZmZlciA9IHRoaXMuY29udGFpbmVySGVpZ2h0ICogVklSVFVBTF9CVUZGRVJfRkFDVE9SO1xuICAgICAgY29uc3Qgb2Zmc2V0U2Nyb2xsUG9zID0gdGhpcy5zdGF0ZS5zY3JvbGxUb3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0VG9wID0gdmlydHVhbEJvdW5kc1RvcFxuICAgICAgICA/IG9mZnNldFNjcm9sbFBvcyAtIHZpcnR1YWxCb3VuZHNUb3BcbiAgICAgICAgOiBvZmZzZXRTY3JvbGxQb3MgLSB2aXJ0dWFsQnVmZmVyO1xuICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgID8gb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgIDogb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQnVmZmVyO1xuXG4gICAgICBpc1Zpc2libGUgPSAhKFxuICAgICAgICBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgPCB2aWV3cG9ydFRvcCB8fFxuICAgICAgICBwb3NpdGlvbi50b3AgPiB2aWV3cG9ydEJvdHRvbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm8gc2Nyb2xsIGNvbnRhaW5lciBpcyBwYXNzZWQgaW4sIGl0ZW1zIHNob3VsZCBhbHdheXMgYmUgdmlzaWJsZVxuICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQ29tcG9uZW50ID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9e2BpdGVtLSR7aWR4fWB9XG4gICAgICAgIGNsYXNzTmFtZT17W3N0eWxlcy5NYXNvbnJ5X19JdGVtLCBzdHlsZXMuTWFzb25yeV9fSXRlbV9fTW91bnRlZF0uam9pbihcbiAgICAgICAgICAnICdcbiAgICAgICAgKX1cbiAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bGVmdH1weCkgdHJhbnNsYXRlWSgke3RvcH1weClgLFxuICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KSB0cmFuc2xhdGVZKCR7dG9wfXB4KWAsXG4gICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHdpZHRoKSxcbiAgICAgICAgICBoZWlnaHQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKGhlaWdodCksXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxDb21wb25lbnQgZGF0YT17aXRlbURhdGF9IGl0ZW1JZHg9e2lkeH0gaXNNZWFzdXJpbmc9e2ZhbHNlfSAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIHJldHVybiB2aXJ0dWFsaXplID8gKGlzVmlzaWJsZSAmJiBpdGVtQ29tcG9uZW50KSB8fCBudWxsIDogaXRlbUNvbXBvbmVudDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sdW1uV2lkdGgsXG4gICAgICBjb21wOiBDb21wb25lbnQsXG4gICAgICBmbGV4aWJsZSxcbiAgICAgIG1lYXN1cmVtZW50U3RvcmUsXG4gICAgICBpdGVtcyxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgaGVpZ2h0LFxuICAgICAgaXRlbXNUb01lYXN1cmUsXG4gICAgICBpdGVtc1RvUmVuZGVyLFxuICAgICAgbWVhc3VyaW5nUG9zaXRpb25zLFxuICAgICAgcmVuZGVyUG9zaXRpb25zLFxuICAgICAgd2lkdGgsXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBsZXQgZ3JpZEJvZHk7XG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGFzUGVuZGluZ01lYXN1cmVtZW50cykge1xuICAgICAgLy8gV2hlbiBoeXJkYXRpbmcgZnJvbSBhIHNlcnZlciByZW5kZXIsIHdlIGRvbid0IGhhdmUgdGhlIHdpZHRoIG9mIHRoZSBncmlkXG4gICAgICAvLyBhbmQgdGhlIG1lYXN1cmVtZW50IHN0b3JlIGlzIGVtcHR5XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLk1hc29ucnl9XG4gICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAwLCB3aWR0aDogJzEwMCUnIH19XG4gICAgICAgICAgcmVmPXt0aGlzLnNldEdyaWRXcmFwcGVyUmVmfVxuICAgICAgICA+XG4gICAgICAgICAge2l0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0pLm1hcCgoaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgPGRpdiAvLyBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIHJlbmRlck1hc29ucnlDb21wb25lbnRcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic3RhdGljXCJcbiAgICAgICAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMHB4KSB0cmFuc2xhdGVZKDBweCknLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmbGV4aWJsZVxuICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24oY29sdW1uV2lkdGgpLCAvLyB3ZSBjYW4ndCBzZXQgYSB3aWR0aCBmb3Igc2VydmVyIHJlbmRlcmVkIGZsZXhpYmxlIGl0ZW1zXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiAhZmxleGlibGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgbWVhc3VyZSBmbGV4aWJsZSBpdGVtcyBvbiBjbGllbnRcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGl0ZW0sIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q29tcG9uZW50IGRhdGE9e2l0ZW19IGl0ZW1JZHg9e2l9IGlzTWVhc3VyaW5nPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAvLyBXaGVuIHRoZSB3aWR0aCBpcyBlbXB0eSAodXN1YWxseSBhZnRlciBhIHJlLW1vdW50KSByZW5kZXIgYW4gZW1wdHlcbiAgICAgIC8vIGRpdiB0byBjb2xsZWN0IHRoZSB3aWR0aCBmb3IgbGF5b3V0XG4gICAgICBncmlkQm9keSA9IDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9IC8+O1xuICAgIH0gZWxzZSB7XG4gICAgICBncmlkQm9keSA9IChcbiAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19IHJlZj17dGhpcy5zZXRHcmlkV3JhcHBlclJlZn0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5NYXNvbnJ5fSBzdHlsZT17eyBoZWlnaHQsIHdpZHRoIH19PlxuICAgICAgICAgICAge2l0ZW1zVG9SZW5kZXIubWFwKChpdGVtLCBpKSA9PlxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIHRoaXMgaXMgdGhlIHJpZ2h0IGRlZmluaXRpb24sIGl0IGFuIEFycmF5PFQ+XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyTWFzb25yeUNvbXBvbmVudChpdGVtLCBpLCByZW5kZXJQb3NpdGlvbnNbaV0pXG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICB7aXRlbXNUb01lYXN1cmUubWFwKChkYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGl0ZW1zVG9NZWFzdXJlIGlzIGFsd2F5cyB0aGUgbGVuZ3RoIG9mIG1pbkNvbHMsIHNvIGkgd2lsbCBhbHdheXMgYmUgMC4ubWluQ29scy5sZW5ndGhcbiAgICAgICAgICAgICAgLy8gd2Ugbm9ybWFsaXplIHRoZSBpbmRleCBoZXJlIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGxpc3QgYXMgYSB3aG9sZSBzbyB0aGF0IGl0ZW1JZHggaXMgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhhdCBSZWFjdCBkb2VzbnQgcmV1c2UgdGhlIG1lYXN1cmVtZW50IG5vZGVzXG4gICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SW5kZXggPSBpdGVtc1RvUmVuZGVyLmxlbmd0aCArIGk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWVhc3VyaW5nUG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YG1lYXN1cmluZy0ke21lYXN1cmVtZW50SW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLndpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihwb3NpdGlvbi5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJlZj17ZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlbWVudFN0b3JlLnNldChkYXRhLCBlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkeD17bWVhc3VyZW1lbnRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaXNNZWFzdXJpbmdcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgcmVmPXt0aGlzLnNldFNjcm9sbENvbnRhaW5lclJlZn1cbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17dGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIHtncmlkQm9keX1cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICkgOiAoXG4gICAgICBncmlkQm9keVxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCBNYXNvbnJ5LCB7IHR5cGUgUHJvcHMsIHR5cGUgTWVhc3VyZW1lbnRTdGF0ZSB9IGZyb20gJy4vTWFzb25yeS5qcyc7XG5pbXBvcnQgeyB0eXBlIFBvc2l0aW9uIH0gZnJvbSAnLi9kZWZhdWx0TGF5b3V0LmpzJztcblxudHlwZSBTdGF0ZTxUPiA9IHt8XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyLFxuICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzOiBib29sZWFuLFxuICBpc0ZldGNoaW5nOiBib29sZWFuLFxuICBpdGVtczogQXJyYXk8VD4sXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxuICBzY3JvbGxIZWlnaHQ6IG51bWJlcixcbnx9O1xuXG4vKipcbiAqIFRoaXMgTWFzb25yeUluZmluaXRlIGlzIGJhY2t3YXJkIGNvbXBhdGlibGUgYW5kIHNlcnZlcyB0byBoZWxwIHdpdGggbWlncmF0aW5nXG4gKiB0byBhIE1hc3JvbnkgdGhhdCBkb2Vzbid0IGhhdmUgdGhlIHNjcm9sIGZldGNoIGNvbmNlcm5zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hc29ucnlJbmZpbml0ZTxUPiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgUHJvcHM8VD4sXG4gIFN0YXRlPFQ+XG4+IHtcbiAgc3RhdGljIGNyZWF0ZU1lYXN1cmVtZW50U3RvcmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNZWFzdXJlbWVudFN0b3JlKCk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0gTWFzb25yeS5kZWZhdWx0UHJvcHM7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzPFQ+KSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNvbnRhaW5lckhlaWdodDogMCxcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IGZhbHNlLFxuICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tdW51c2VkLXN0YXRlXG4gICAgICBpdGVtczogcHJvcHMuaXRlbXMsXG4gICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICBzY3JvbGxIZWlnaHQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250ZW50IGxheWVyIGFuZCBWaWV3cG9ydCBsYXllciBpcyBhcyBkZWZpbmVkIGluIENvbGxlY3Rpb24uXG4gICAqL1xuICBvblZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlID0gKGNvbnRlbnQ6IFBvc2l0aW9uLCB2aWV3cG9ydDogUG9zaXRpb24pID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckhlaWdodCwgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKFxuICAgICAgdmlld3BvcnQuaGVpZ2h0ICE9PSBjb250YWluZXJIZWlnaHQgfHxcbiAgICAgIHZpZXdwb3J0LnRvcCAhPT0gc2Nyb2xsVG9wIHx8XG4gICAgICBjb250ZW50LmhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0XG4gICAgKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgIHNjcm9sbFRvcDogdmlld3BvcnQudG9wLFxuICAgICAgICBzY3JvbGxIZWlnaHQ6IGNvbnRlbnQuaGVpZ2h0LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHM6IFByb3BzPFQ+LCBzdGF0ZTogU3RhdGU8VD4pIHtcbiAgICBjb25zdCB7IGl0ZW1zIH0gPSBwcm9wcztcblxuICAgIC8vIGFzc3VtZSBpbW11dGFibGUgaXRlbXNcbiAgICBpZiAocHJvcHMuaXRlbXMgIT09IHN0YXRlLml0ZW1zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNoYW5nZSB0byBzdGF0ZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldFJlZiA9IChyZWY6IFJlYWN0LkVsZW1lbnRSZWY8Kj4pID0+IHtcbiAgICBpZiAocmVmKSB7XG4gICAgICB0aGlzLmdyaWRSZWYgPSByZWY7XG4gICAgfVxuICB9O1xuXG4gIGZldGNoTW9yZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGxvYWRJdGVtcyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobG9hZEl0ZW1zICYmIHR5cGVvZiBsb2FkSXRlbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICBpc0ZldGNoaW5nOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBsb2FkSXRlbXMoeyBmcm9tOiB0aGlzLnByb3BzLml0ZW1zLmxlbmd0aCB9KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlT25BdXRvTWVhc3VyaW5nVXBkYXRlID0gKHN0YXRlOiBNZWFzdXJlbWVudFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaGFzUGVuZGluZ01lYXN1cmVtZW50cyA9IHN0YXRlID09PSAnbWVhc3VyaW5nJztcbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgaGFzUGVuZGluZ01lYXN1cmVtZW50cyB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25BdXRvTWVhc3VyaW5nVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQXV0b01lYXN1cmluZ1VwZGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJlZmxvdyA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkUmVmKSB7XG4gICAgICB0aGlzLmdyaWRSZWYucmVmbG93KCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkUmVmKSB7XG4gICAgICB0aGlzLmdyaWRSZWYuaGFuZGxlUmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIGdyaWRSZWY6IE1hc29ucnk8VD47XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgPEZldGNoSXRlbXNcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ9e3RoaXMuc3RhdGUuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICAgIGZldGNoTW9yZT17dGhpcy5mZXRjaE1vcmV9XG4gICAgICAgICAgaXNGZXRjaGluZz17XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlzRmV0Y2hpbmcgfHwgdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbEhlaWdodD17dGhpcy5zdGF0ZS5zY3JvbGxIZWlnaHR9XG4gICAgICAgICAgc2Nyb2xsVG9wPXt0aGlzLnN0YXRlLnNjcm9sbFRvcH1cbiAgICAgICAgLz5cbiAgICAgICAgPE1hc29ucnlcbiAgICAgICAgICB7Li4udGhpcy5wcm9wc31cbiAgICAgICAgICBvblZpcnR1YWxpemF0aW9uV2luZG93VXBkYXRlPXt0aGlzLm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGV9XG4gICAgICAgICAgb25BdXRvTWVhc3VyaW5nVXBkYXRlPXt0aGlzLmhhbmRsZU9uQXV0b01lYXN1cmluZ1VwZGF0ZX1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0UmVmfVxuICAgICAgICAvPlxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICApIDogKFxuICAgICAgPE1hc29ucnkgey4uLnRoaXMucHJvcHN9IHJlZj17dGhpcy5zZXRSZWZ9IC8+XG4gICAgKTtcbiAgfVxufVxuIiwiLyogQGZsb3cgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb1Njcm9sbEJlaGF2aW9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnByZXZPdmVyZmxvdyA9IG51bGw7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucHJldk92ZXJmbG93ID0gd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLnByZXZPdmVyZmxvdztcbiAgICB9XG4gIH1cblxuICBwcmV2T3ZlcmZsb3c6IHN0cmluZyB8IG51bGw7XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG4iLCIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlQWxsKGVsOiBIVE1MRGl2RWxlbWVudCkge1xuICBjb25zdCBzZWxlY3RvciA9IFtcbiAgICAnYVtocmVmXScsXG4gICAgJ2FyZWFbaHJlZl0nLFxuICAgICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLFxuICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsXG4gICAgJ2lmcmFtZScsXG4gICAgJ29iamVjdCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnW3RhYmluZGV4PVwiLTFcIl0nLFxuICAgICdbdGFiaW5kZXg9XCIwXCJdJyxcbiAgICAnW2NvbnRlbnRlZGl0YWJsZV0nLFxuICAgICdhdWRpb1tjb250cm9sc10nLFxuICAgICd2aWRlb1tjb250cm9sc10nLFxuICAgICdzdW1tYXJ5JyxcbiAgXS5qb2luKCcsJyk7XG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbn1cblxuY29uc3QgZm9jdXNFbGVtZW50ID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICBpZiAodHlwZW9mIGVsLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZWwuZm9jdXMoKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhcEZvY3VzQmVoYXZpb3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLmZvY3VzRmlyc3RDaGlsZCgpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cywgdHJ1ZSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMsIHRydWUpO1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWwpIHtcbiAgICAgIGZvY3VzRWxlbWVudCh0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWwpO1xuICAgIH1cbiAgfVxuXG4gIHNldEVsUmVmID0gKGVsOiA/SFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlRm9jdXMgPSAoZXZlbnQ6IEZvY3VzRXZlbnQpID0+IHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5lbCB8fFxuICAgICAgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiYgdGhpcy5lbC5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgfTtcblxuICBmb2N1c0ZpcnN0Q2hpbGQoKSB7XG4gICAgY29uc3QgeyBlbCB9ID0gdGhpcztcbiAgICBpZiAoZWwpIHtcbiAgICAgIGZvY3VzRWxlbWVudChxdWVyeUZvY3VzYWJsZUFsbChlbClbMF0pO1xuICAgIH1cbiAgfVxuXG4gIGVsOiA/SFRNTERpdkVsZW1lbnQ7XG5cbiAgcHJldmlvdXNseUZvY3VzZWRFbDogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuc2V0RWxSZWZ9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvZGl2PjtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBEaXZpZGVyIGZyb20gJy4vRGl2aWRlci5qcyc7XG5pbXBvcnQgSGVhZGluZyBmcm9tICcuL0hlYWRpbmcuanMnO1xuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi9JY29uQnV0dG9uLmpzJztcbmltcG9ydCBTdG9wU2Nyb2xsQmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvU3RvcFNjcm9sbEJlaGF2aW9yLmpzJztcbmltcG9ydCBUcmFwRm9jdXNCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9UcmFwRm9jdXNCZWhhdmlvci5qcyc7XG5pbXBvcnQgT3V0c2lkZUV2ZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvT3V0c2lkZUV2ZW50QmVoYXZpb3IuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01vZGFsLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbDogc3RyaW5nLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGZvb3Rlcj86IFJlYWN0Lk5vZGUsXG4gIGhlYWRpbmc6IHN0cmluZyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICByb2xlPzogJ2FsZXJ0ZGlhbG9nJyB8ICdkaWFsb2cnLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxufH07XG5cbmNvbnN0IFNJWkVfV0lEVEhfTUFQID0ge1xuICBzbTogNDE0LFxuICBtZDogNTQ0LFxuICBsZzogODA0LFxufTtcblxuY29uc3QgRVNDQVBFX0tFWV9DT0RFID0gMjc7XG5cbmNvbnN0IEJhY2tkcm9wID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbj86IFJlYWN0Lk5vZGUgfSkgPT4gKFxuICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5CYWNrZHJvcH0gLz5cbiAgICB7Y2hpbGRyZW59XG4gIDwvUmVhY3QuRnJhZ21lbnQ+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGZvb3RlcjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaGVhZGluZzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlNb2RhbExhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICByb2xlOiBQcm9wVHlwZXMub25lT2YoWydhbGVydGRpYWxvZycsICdkaWFsb2cnXSksXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnXSksXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVLZXlVcCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZUtleVVwKTtcbiAgfVxuXG4gIGhhbmRsZU91dHNpZGVDbGljayA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICB9O1xuXG4gIGhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoKTtcbiAgfTtcblxuICBoYW5kbGVLZXlVcCA9IChldmVudDogeyBrZXlDb2RlOiBudW1iZXIgfSkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEVfS0VZX0NPREUpIHtcbiAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlNb2RhbExhYmVsLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBmb290ZXIsXG4gICAgICBoZWFkaW5nLFxuICAgICAgcm9sZSA9ICdkaWFsb2cnLFxuICAgICAgc2l6ZSA9ICdzbScsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgd2lkdGggPSBTSVpFX1dJRFRIX01BUFtzaXplXTtcblxuICAgIHJldHVybiAoXG4gICAgICA8U3RvcFNjcm9sbEJlaGF2aW9yPlxuICAgICAgICA8VHJhcEZvY3VzQmVoYXZpb3I+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eU1vZGFsTGFiZWx9XG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9XG4gICAgICAgICAgICByb2xlPXtyb2xlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxCYWNrZHJvcD5cbiAgICAgICAgICAgICAgPE91dHNpZGVFdmVudEJlaGF2aW9yIG9uQ2xpY2s9e3RoaXMuaGFuZGxlT3V0c2lkZUNsaWNrfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9IHRhYkluZGV4PXstMX0gc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgICAgICAgIGZsZXg9XCJncm93XCJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPEJveCBmaXQ+XG4gICAgICAgICAgICAgICAgICAgICAge3JvbGUgPT09ICdkaWFsb2cnID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogNTAsIHBhZGRpbmdSaWdodDogNTAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdZPXs1fVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8SGVhZGluZyBzaXplPVwieHNcIiBhY2Nlc3NpYmlsaXR5TGV2ZWw9ezF9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtoZWFkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L0hlYWRpbmc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJveCBkaXNwbGF5PVwiZmxleFwiIHBhZGRpbmc9ezR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8SGVhZGluZyBzaXplPVwic21cIiBhY2Nlc3NpYmlsaXR5TGV2ZWw9ezF9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtoZWFkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L0hlYWRpbmc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgIHtyb2xlID09PSAnZGlhbG9nJyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgcmlnaHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPXthY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsb3NlQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgIHtyb2xlID09PSAnZGlhbG9nJyAmJiA8RGl2aWRlciAvPn1cbiAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgIDxCb3ggZmxleD1cImdyb3dcIiBvdmVyZmxvdz1cImF1dG9cIiBwb3NpdGlvbj1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgPEJveCBmaXQ+XG4gICAgICAgICAgICAgICAgICAgICAge2Zvb3RlciAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8Qm94PlxuICAgICAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgJiYgPERpdmlkZXIgLz59XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxCb3ggcGFkZGluZz17NH0+e2Zvb3Rlcn08L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvT3V0c2lkZUV2ZW50QmVoYXZpb3I+XG4gICAgICAgICAgICA8L0JhY2tkcm9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1RyYXBGb2N1c0JlaGF2aW9yPlxuICAgICAgPC9TdG9wU2Nyb2xsQmVoYXZpb3I+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9QdWxzYXIuY3NzJztcblxudHlwZSBQcm9wcyA9IHtcbiAgcGF1c2VkPzogYm9vbGVhbixcbiAgc2l6ZT86IG51bWJlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFB1bHNhcihwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBwYXVzZWQsIHNpemUgPSAxMzUgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPEJveFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHBhdXNlZCA/IDAgOiAnaW5maW5pdGUnLFxuICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAgICAgfSxcbiAgICAgIH19XG4gICAgICBkaXNwbGF5PXtwYXVzZWQgPyAnbm9uZScgOiAnYmxvY2snfVxuICAgICAgaGVpZ2h0PXtzaXplfVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICB3aWR0aD17c2l6ZX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmlubmVyQ2lyY2xlfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vdXRlckNpcmNsZX0gLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvQm94PlxuICApO1xufVxuXG5QdWxzYXIucHJvcFR5cGVzID0ge1xuICBwYXVzZWQ6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vUmFkaW9CdXR0b24uY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoZWNrZWQ/OiBib29sZWFuLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sXG4gICAgY2hlY2tlZDogYm9vbGVhbixcbiAgfSkgPT4gdm9pZCxcbiAgdmFsdWU6IHN0cmluZyxcbiAgc2l6ZT86ICdzbScgfCAnbWQnLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvQnV0dG9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCddKSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzaXplOiAnbWQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7IGNoZWNrZWQsIGV2ZW50IH0pO1xuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGlkLCBuYW1lLCBzaXplLCB2YWx1ZSB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLlJhZGlvQnV0dG9uLCB7XG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbklzRm9jdXNlZF06IHRoaXMuc3RhdGUuZm9jdXNlZCxcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uU21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25NZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbldoaXRlQmddOiAhZGlzYWJsZWQgfHwgY2hlY2tlZCxcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uTGlnaHRHcmF5QmddOiBkaXNhYmxlZCAmJiAhY2hlY2tlZCxcbiAgICAgICAgfSl9XG4gICAgICA+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5JbnB1dCwge1xuICAgICAgICAgICAgW3N0eWxlcy5JbnB1dEVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgICAgICAgICBbc3R5bGVzLklucHV0U21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgW3N0eWxlcy5JbnB1dE1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICB9KX1cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtjaGVja2VkICYmIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLkNoZWNrLCB7XG4gICAgICAgICAgICAgIFtzdHlsZXMuQ2hlY2tTbV06IHNpemUgPT09ICdzbScsXG4gICAgICAgICAgICAgIFtzdHlsZXMuQ2hlY2tNZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgICAgICAgIFtzdHlsZXMuQ2hlY2tFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrRGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGZXRjaEl0ZW1zIGZyb20gJy4vRmV0Y2hJdGVtcy5qcyc7XG5pbXBvcnQgU2Nyb2xsQ29udGFpbmVyIGZyb20gJy4vU2Nyb2xsQ29udGFpbmVyLmpzJztcbmltcG9ydCB7XG4gIGdldEVsZW1lbnRIZWlnaHQsXG4gIGdldFNjcm9sbEhlaWdodCxcbiAgZ2V0U2Nyb2xsUG9zLFxufSBmcm9tICcuL3Njcm9sbFV0aWxzLmpzJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICcuL3Rocm90dGxlLmpzJztcblxudHlwZSBQcm9wcyA9IHtcbiAgY29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gIGlzQXRFbmQ/OiBib29sZWFuLFxuICBpc0ZldGNoaW5nOiBib29sZWFuLFxuICBmZXRjaE1vcmU/OiAoKSA9PiB2b2lkLFxuICByZW5kZXJIZWlnaHQ/OiAoKSA9PiBudW1iZXIsXG59O1xuXG50eXBlIFN0YXRlID0ge1xuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcixcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXIsXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsRmV0Y2ggZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICAvKipcbiAgICogRmV0Y2hlcyBhZGRpdGlvbmFsIGl0ZW1zIGlmIG5lZWRlZC5cbiAgICovXG4gIHVwZGF0ZVBvc2l0aW9uID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5nZXRTY3JvbGxTdGF0ZSgpKTtcbiAgfSk7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wczoge307XG5cbiAgc3RhdGUgPSB7XG4gICAgY29udGFpbmVySGVpZ2h0OiAwLFxuICAgIHNjcm9sbEhlaWdodDogMCxcbiAgICBzY3JvbGxUb3A6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgc2Nyb2xsIGxpc3RlbmVyIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBnZXRFbGVtZW50SGVpZ2h0KGNvbnRhaW5lciksXG4gICAgICAgIC4uLnRoaXMuZ2V0U2Nyb2xsU3RhdGUoKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzY3JvbGwgYnVmZmVyIGFuZCBjaGVjayBhZnRlciB0aGUgY29tcG9uZW50IHVwZGF0ZXMuXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgLy8gc2V0VGltZW91dCBzbyB0aGUgcGFyZW50IGNvbXBvbmVudCBjYW4gY2FsY3VsYXRlIHJlbmRlckhlaWdodCgpLlxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JvbGxhYmxlIGNvbnRlbnQgaGVpZ2h0LlxuICAgKi9cbiAgZ2V0U2Nyb2xsSGVpZ2h0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGdldFNjcm9sbEhlaWdodChjb250YWluZXIpO1xuICB9O1xuXG4gIGdldFNjcm9sbFN0YXRlKCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyLCByZW5kZXJIZWlnaHQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSByZW5kZXJIZWlnaHQgfHwgdGhpcy5nZXRTY3JvbGxIZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxIZWlnaHQoKSxcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsUG9zKGNvbnRhaW5lciksXG4gICAgfTtcbiAgfVxuXG4gIHNjcm9sbEJ1ZmZlcjogbnVtYmVyO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBjb250YWluZXIsIGZldGNoTW9yZSwgaXNBdEVuZCwgaXNGZXRjaGluZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgY29udGFpbmVySGVpZ2h0LFxuICAgICAgZmV0Y2hNb3JlLFxuICAgICAgaXNBdEVuZCxcbiAgICAgIGlzRmV0Y2hpbmcsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgfTtcblxuICAgIGlmICghY29udGFpbmVyIHx8IGlzQXRFbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPFNjcm9sbENvbnRhaW5lclxuICAgICAgICBvblNjcm9sbD17dGhpcy51cGRhdGVQb3NpdGlvbn1cbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyPXtjb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIDxGZXRjaEl0ZW1zIHsuLi5wcm9wc30gLz5cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICk7XG4gIH1cbn1cblxuU2Nyb2xsRmV0Y2gucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIHNjcm9sbCBjb250YWluZXIgdG8gdXNlLiBEZWZhdWx0cyB0byB3aW5kb3cuXG4gICAqL1xuICBjb250YWluZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG4gIH0pLFxuICByZW5kZXJIZWlnaHQ6IFByb3BUeXBlcy5mdW5jLFxuICBpc0F0RW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgaXNGZXRjaGluZzogUHJvcFR5cGVzLmJvb2wsXG4gIGZldGNoTW9yZTogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5TY3JvbGxGZXRjaC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRhaW5lcjogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU2VhcmNoRmllbGQuY3NzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBvbkJsdXI/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25DaGFuZ2U6ICh7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBzeW50aGV0aWNFdmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gIH0pID0+IHZvaWQsXG4gIG9uRm9jdXM/OiAoe1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgc3ludGhldGljRXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICB9KSA9PiB2b2lkLFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgdmFsdWU/OiBzdHJpbmcsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG4gIGhvdmVyZWQ6IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoRmllbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWNjZXNzaWJpbGl0eUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9O1xuXG4gIHN0YXRlOiBTdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBob3ZlcmVkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIHN5bnRoZXRpY0V2ZW50OiBldmVudCxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVDbGVhciA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIHN5bnRoZXRpY0V2ZW50OiBldmVudCxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZUVudGVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWQ6IHRydWUgfSk7XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiBmYWxzZSB9KTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogdHJ1ZSB9KTtcblxuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyh7XG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlQmx1ciA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25CbHVyKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGFjY2Vzc2liaWxpdHlMYWJlbCwgaWQsIHBsYWNlaG9sZGVyLCB2YWx1ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgYnVpbHQgaW4gYnJvd3NlciBiZWhhdmlvci4gSWYgdGhlcmUncyBhIHZhbHVlLCBzaG93IHRoZVxuICAgIC8vIGNsZWFyIGJ1dHRvbiBpZiB5b3UncmUgaG92ZXJpbmcgb3IgaWYgeW91J3ZlIGZvY3VzZWQgb24gdGhlIGZpZWxkXG4gICAgY29uc3Qgc2hvd0NsZWFyID1cbiAgICAgICh0aGlzLnN0YXRlLmZvY3VzZWQgfHwgdGhpcy5zdGF0ZS5ob3ZlcmVkKSAmJiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgIG9uTW91c2VFbnRlcj17dGhpcy5oYW5kbGVNb3VzZUVudGVyfVxuICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgPlxuICAgICAgICA8Qm94XG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICAgIC8vIEFkZGVkIHRoZSBmb2xsb3dpbmcgbGluZXMgZm9yIFNhZmFyaSBzdXBwb3J0XG4gICAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwJSknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgIGxlZnRcbiAgICAgICAgICBwYWRkaW5nWD17NH1cbiAgICAgICAgPlxuICAgICAgICAgIDxJY29uIGljb249XCJzZWFyY2hcIiBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIiAvPlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmlucHV0fVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgIHJvbGU9XCJzZWFyY2hib3hcIlxuICAgICAgICAgIHR5cGU9XCJzZWFyY2hcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICAge3Nob3dDbGVhciAmJiAoXG4gICAgICAgICAgPEJveCBwb3NpdGlvbj1cImFic29sdXRlXCIgcmlnaHQgdG9wPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jbGVhcn1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGVhcn1cbiAgICAgICAgICAgICAgdGFiSW5kZXg9ey0xfVxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEljb24gaWNvbj1cImNsZWFyXCIgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCIgLz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9TZWdtZW50ZWRDb250cm9sLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBpdGVtczogQXJyYXk8UmVhY3QuTm9kZT4sXG4gIG9uQ2hhbmdlOiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+LCBhY3RpdmVJbmRleDogbnVtYmVyIH0pID0+IHZvaWQsXG4gIHNlbGVjdGVkSXRlbUluZGV4OiBudW1iZXIsXG4gIHNpemU/OiAnbWQnIHwgJ2xnJyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWdtZW50ZWRDb250cm9sKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGl0ZW1zLCBvbkNoYW5nZSwgc2VsZWN0ZWRJdGVtSW5kZXgsIHNpemUgPSAnbWQnIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLlNlZ21lbnRlZENvbnRyb2wsIHtcbiAgICAgICAgW3N0eWxlcy5tZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgIFtzdHlsZXMubGddOiBzaXplID09PSAnbGcnLFxuICAgICAgfSl9XG4gICAgICByb2xlPVwidGFibGlzdFwiXG4gICAgPlxuICAgICAge2l0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gaSA9PT0gc2VsZWN0ZWRJdGVtSW5kZXg7XG4gICAgICAgIGNvbnN0IGNzID0gY2xhc3NuYW1lcyhzdHlsZXMuaXRlbSwge1xuICAgICAgICAgIFtzdHlsZXMuaXRlbUlzTm90U2VsZWN0ZWRdOiAhaXNTZWxlY3RlZCxcbiAgICAgICAgICBbc3R5bGVzLml0ZW1Jc1NlbGVjdGVkXTogaXNTZWxlY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNTZWxlY3RlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICBvbkNsaWNrPXtlID0+IG9uQ2hhbmdlKHsgZXZlbnQ6IGUsIGFjdGl2ZUluZGV4OiBpIH0pfVxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnID8gKFxuICAgICAgICAgICAgICA8VGV4dFxuICAgICAgICAgICAgICAgIGJvbGRcbiAgICAgICAgICAgICAgICBjb2xvcj17aXNTZWxlY3RlZCA/ICdkYXJrR3JheScgOiAnZ3JheSd9XG4gICAgICAgICAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgIHNpemU9e3NpemV9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7aXRlbX1cbiAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPEJveCBkaXNwbGF5PVwiZmxleFwiIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCI+XG4gICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5TZWdtZW50ZWRDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgaXRlbXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKS5pc1JlcXVpcmVkLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgc2VsZWN0ZWRJdGVtSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgRmx5b3V0IGZyb20gJy4vRmx5b3V0LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NlbGVjdExpc3QuY3NzJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgZXJyb3JJc09wZW46IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgaWRlYWxFcnJvckRpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnIC8qIGRlZmF1bHQ6IHJpZ2h0ICovLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkNoYW5nZTogKHsgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PiwgdmFsdWU6IHN0cmluZyB9KSA9PiB2b2lkLFxuICBvcHRpb25zOiBBcnJheTx7XG4gICAgbGFiZWw6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9PixcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXG4gIHZhbHVlPzogP3N0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBlcnJvck1lc3NhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgICAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgfSlcbiAgICApLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246ICdyaWdodCcsXG4gICAgb3B0aW9uczogW10sXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgZm9jdXNlZDogZmFsc2UsXG4gICAgZXJyb3JJc09wZW46IGZhbHNlLFxuICB9O1xuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHM6IFByb3BzLCBzdGF0ZTogU3RhdGUpIHtcbiAgICBpZiAocHJvcHMuZXJyb3JNZXNzYWdlICE9PSBzdGF0ZS5lcnJvck1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9ySXNPcGVuOiAhIXByb3BzLmVycm9yTWVzc2FnZSxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaGFuZGxlT25DaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PikgPT4ge1xuICAgIGlmIChcbiAgICAgIGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50ICYmXG4gICAgICB0aGlzLnByb3BzLnZhbHVlICE9PSBldmVudC50YXJnZXQudmFsdWVcbiAgICApIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyBldmVudCwgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZSB9KTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5lcnJvck1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcklzT3BlbjogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgc2VsZWN0OiA/SFRNTFNlbGVjdEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgaWQsXG4gICAgICBpZGVhbEVycm9yRGlyZWN0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHZhbHVlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMuc2VsZWN0LFxuICAgICAgZGlzYWJsZWQgPyBzdHlsZXMuZGlzYWJsZWQgOiBzdHlsZXMuZW5hYmxlZCxcbiAgICAgIGVycm9yTWVzc2FnZSA/IHN0eWxlcy5lcnJvcmVkIDogc3R5bGVzLm5vcm1hbFxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBjb2xvcj17ZGlzYWJsZWQgPyAnbGlnaHRHcmF5JyA6ICd3aGl0ZSd9XG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBib3JkZXJSYWRpdXM6IDQgfSB9fVxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgPlxuICAgICAgICA8Qm94XG4gICAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgICAgYm90dG9tXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgX19zdHlsZTogeyBwYWRkaW5nUmlnaHQ6IDE0LCBwYWRkaW5nVG9wOiAyIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgcG9zaXRpb249XCJhYnNvbHV0ZVwiXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgICB0b3BcbiAgICAgICAgPlxuICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICBpY29uPVwiYXJyb3ctZG93blwiXG4gICAgICAgICAgICBzaXplPXsxMn1cbiAgICAgICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdncmF5JyA6ICdkYXJrR3JheSd9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkID8gYCR7aWR9LWdlc3RhbHQtZXJyb3JgIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmlhLWludmFsaWQ9e2Vycm9yTWVzc2FnZSA/ICd0cnVlJyA6ICdmYWxzZSd9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZU9uQ2hhbmdlfVxuICAgICAgICAgIHJlZj17YyA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCA9IGM7XG4gICAgICAgICAgfX1cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgID5cbiAgICAgICAgICB7cGxhY2Vob2xkZXIgJiZcbiAgICAgICAgICAgICF2YWx1ZSAmJiAoXG4gICAgICAgICAgICAgIDxvcHRpb24gc2VsZWN0ZWQgZGlzYWJsZWQgdmFsdWUgaGlkZGVuPlxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIHtvcHRpb25zLm1hcChvcHRpb24gPT4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e29wdGlvbi52YWx1ZX0gdmFsdWU9e29wdGlvbi52YWx1ZX0+XG4gICAgICAgICAgICAgIHtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICB0aGlzLnN0YXRlLmVycm9ySXNPcGVuICYmIChcbiAgICAgICAgICAgIDxGbHlvdXRcbiAgICAgICAgICAgICAgYW5jaG9yPXt0aGlzLnNlbGVjdH1cbiAgICAgICAgICAgICAgY29sb3I9XCJvcmFuZ2VcIlxuICAgICAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxFcnJvckRpcmVjdGlvbn1cbiAgICAgICAgICAgICAgb25EaXNtaXNzPXsoKSA9PiB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pfVxuICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezN9PlxuICAgICAgICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9TcGlubmVyLmNzcyc7XG5cbmNvbnN0IFNJWkUgPSA0MDtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogc3RyaW5nLFxuICBzaG93OiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNwaW5uZXIoeyBhY2Nlc3NpYmlsaXR5TGFiZWwsIHNob3cgfTogUHJvcHMpIHtcbiAgcmV0dXJuIHNob3cgPyAoXG4gICAgPEJveCB4cz17eyBkaXNwbGF5OiAnZmxleCcgfX0ganVzdGlmeUNvbnRlbnQ9XCJhcm91bmRcIiBvdmVyZmxvdz1cImhpZGRlblwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pY29ufT5cbiAgICAgICAgPEljb25cbiAgICAgICAgICBpY29uPVwia25vb3BcIlxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICAgIHNpemU9e1NJWkV9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L0JveD5cbiAgKSA6IChcbiAgICA8ZGl2IC8+XG4gICk7XG59XG5cblNwaW5uZXIucHJvcFR5cGVzID0ge1xuICBzaG93OiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbn07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGxheW91dCBmcm9tICcuL0xheW91dC5jc3MnO1xuXG50eXBlIFRocmVzaG9sZCA9XG4gIHwge3wgdG9wOiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCBib3R0b206IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8IGxlZnQ6IG51bWJlciB8IHN0cmluZyB8fVxuICB8IHt8IHJpZ2h0OiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCB0b3A6IG51bWJlciB8IHN0cmluZywgYm90dG9tOiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCBsZWZ0OiBudW1iZXIgfCBzdHJpbmcsIHJpZ2h0OiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fFxuICAgICAgdG9wOiBudW1iZXIgfCBzdHJpbmcsXG4gICAgICBsZWZ0OiBudW1iZXIgfCBzdHJpbmcsXG4gICAgICByaWdodDogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgYm90dG9tOiBudW1iZXIgfCBzdHJpbmcsXG4gICAgfH07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbjogUmVhY3QuTm9kZSxcbiAgZGFuZ2Vyb3VzbHlTZXRaSW5kZXg/OiB7IF9fekluZGV4OiBudW1iZXIgfSxcbiAgLi4uVGhyZXNob2xkLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0aWNreShwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBkYW5nZXJvdXNseVNldFpJbmRleCA9IHsgX196SW5kZXg6IDEgfSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICB0b3A6IHByb3BzLnRvcCAhPSBudWxsID8gcHJvcHMudG9wIDogdW5kZWZpbmVkLFxuICAgIGxlZnQ6IHByb3BzLmxlZnQgIT0gbnVsbCA/IHByb3BzLmxlZnQgOiB1bmRlZmluZWQsXG4gICAgcmlnaHQ6IHByb3BzLnJpZ2h0ICE9IG51bGwgPyBwcm9wcy5yaWdodCA6IHVuZGVmaW5lZCxcbiAgICBib3R0b206IHByb3BzLmJvdHRvbSAhPSBudWxsID8gcHJvcHMuYm90dG9tIDogdW5kZWZpbmVkLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHpJbmRleDogZGFuZ2Vyb3VzbHlTZXRaSW5kZXguX196SW5kZXgsXG4gIH07XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2xheW91dC5zdGlja3l9IHN0eWxlPXtzdHlsZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9kaXY+XG4gICk7XG59XG5cblN0aWNreS5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgZGFuZ2Vyb3VzbHlTZXRaSW5kZXg6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgX196SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICB0b3A6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbGVmdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBib3R0b206IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgcmlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1N3aXRjaC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkNoYW5nZTogKHsgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PiwgdmFsdWU6IGJvb2xlYW4gfSkgPT4gdm9pZCxcbiAgc3dpdGNoZWQ/OiBib29sZWFuLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXRjaCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHN3aXRjaGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzd2l0Y2hlZDogZmFsc2UsXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldDtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHtcbiAgICAgIGV2ZW50LFxuICAgICAgdmFsdWU6IGNoZWNrZWQsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQsIGlkLCBuYW1lLCBzd2l0Y2hlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHN3aXRjaFN0eWxlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMuc3dpdGNoLFxuICAgICAge1xuICAgICAgICBbc3R5bGVzLmZvY3VzZWRdOiB0aGlzLnN0YXRlLmZvY3VzZWQsXG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICBkaXNhYmxlZFxuICAgICAgICA/IHN3aXRjaGVkID8gc3R5bGVzLnN3aXRjaEdyYXkgOiBzdHlsZXMuc3dpdGNoTGlnaHRHcmF5XG4gICAgICAgIDogc3dpdGNoZWQgPyBzdHlsZXMuc3dpdGNoRGFya0dyYXkgOiBzdHlsZXMuc3dpdGNoV2hpdGVcbiAgICApO1xuXG4gICAgY29uc3Qgc2xpZGVyU3R5bGVzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zbGlkZXIsXG4gICAgICBzd2l0Y2hlZCA/IHN0eWxlcy5zbGlkZXJSaWdodCA6IHN0eWxlcy5zbGlkZXJMZWZ0LFxuICAgICAgc3dpdGNoZWQgJiYgIWRpc2FibGVkID8gc3R5bGVzLnNsaWRlckRhcmsgOiBzdHlsZXMuc2xpZGVyTGlnaHRcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXRTdHlsZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jaGVja2JveCwge1xuICAgICAgW3N0eWxlcy5jaGVja2JveEVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N3aXRjaFN0eWxlc30+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNoZWNrZWQ9e3N3aXRjaGVkfVxuICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzbGlkZXJTdHlsZXN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UYWJzLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmVUYWJJbmRleDogbnVtYmVyLFxuICB0YWJzOiBBcnJheTx7fFxuICAgIHRleHQ6IFJlYWN0Lk5vZGUsXG4gICAgaHJlZjogc3RyaW5nLFxuICB8fT4sXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4sXG4gICAgYWN0aXZlVGFiSW5kZXg6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZFRhYkluZGV4OiA/bnVtYmVyLFxuICBob3ZlcmVkVGFiSW5kZXg6ID9udW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY3RpdmVUYWJJbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRhYnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgICAgdGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICB9KVxuICAgICkuaXNSZXF1aXJlZCxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZm9jdXNlZFRhYkluZGV4OiB1bmRlZmluZWQsXG4gICAgaG92ZXJlZFRhYkluZGV4OiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaGFuZGxlVGFiQ2xpY2sgPSAoaTogbnVtYmVyLCBlOiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uQ2hhbmdlKHsgYWN0aXZlVGFiSW5kZXg6IGksIGV2ZW50OiBlIH0pO1xuICB9O1xuXG4gIGhhbmRsZVRhYkZvY3VzID0gKGk6IG51bWJlcikgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWRUYWJJbmRleDogaSB9KTtcblxuICBoYW5kbGVUYWJCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWRUYWJJbmRleDogdW5kZWZpbmVkIH0pO1xuXG4gIGhhbmRsZVRhYk1vdXNlRW50ZXIgPSAoaTogbnVtYmVyKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZFRhYkluZGV4OiBpIH0pO1xuXG4gIGhhbmRsZVRhYk1vdXNlTGVhdmUgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZFRhYkluZGV4OiB1bmRlZmluZWQgfSk7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdGFicywgYWN0aXZlVGFiSW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBmb2N1c2VkVGFiSW5kZXgsIGhvdmVyZWRUYWJJbmRleCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5UYWJzfSByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICB7dGFicy5tYXAoKHsgdGV4dCwgaHJlZiB9LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBpID09PSBhY3RpdmVUYWJJbmRleDtcbiAgICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSBpID09PSBob3ZlcmVkVGFiSW5kZXg7XG4gICAgICAgICAgY29uc3QgaXNGb2N1c2VkID0gaSA9PT0gZm9jdXNlZFRhYkluZGV4O1xuICAgICAgICAgIGNvbnN0IGNzID0gY2xhc3NuYW1lcyhzdHlsZXMudGFiLCB7XG4gICAgICAgICAgICBbc3R5bGVzLnRhYklzTm90QWN0aXZlXTogIWlzQWN0aXZlLFxuICAgICAgICAgICAgW3N0eWxlcy50YWJJc0FjdGl2ZV06IGlzQWN0aXZlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPXtpc0FjdGl2ZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc31cbiAgICAgICAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB0aGlzLmhhbmRsZVRhYkNsaWNrKGksIGUpfVxuICAgICAgICAgICAgICBvbkZvY3VzPXsoKSA9PiB0aGlzLmhhbmRsZVRhYkZvY3VzKGkpfVxuICAgICAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlVGFiQmx1cn1cbiAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiB0aGlzLmhhbmRsZVRhYk1vdXNlRW50ZXIoaSl9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVUYWJNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgICBib2xkXG4gICAgICAgICAgICAgICAgY29sb3I9e2lzQWN0aXZlIHx8IGlzSG92ZXJlZCB8fCBpc0ZvY3VzZWQgPyAnZGFya0dyYXknIDogJ2dyYXknfVxuICAgICAgICAgICAgICAgIHNpemU9XCJtZFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7dGV4dH1cbiAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEZseW91dCBmcm9tICcuL0ZseW91dC5qcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVGV4dEFyZWEuY3NzJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgZXJyb3JJc09wZW46IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpZGVhbEVycm9yRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgLyogZGVmYXVsdDogcmlnaHQgKi8sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQmx1cj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25DaGFuZ2U6ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25Gb2N1cz86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25LZXlEb3duPzogKHtcbiAgICBldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgcm93cz86IG51bWJlciAvKiBkZWZhdWx0OiAzICovLFxuICB2YWx1ZT86IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0QXJlYSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZXJyb3JNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGhhc0Vycm9yOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcm93czogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgaWRlYWxFcnJvckRpcmVjdGlvbjogJ3JpZ2h0JyxcbiAgICByb3dzOiAzLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGVycm9ySXNPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcywgc3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmVycm9yTWVzc2FnZSAhPT0gc3RhdGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcklzT3BlbjogISFwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgZXZlbnQsXG4gICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25CbHVyKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IHRydWUgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyh7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25LZXlEb3duKSB7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5RG93bih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0ZXh0YXJlYTogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIGhhc0Vycm9yLFxuICAgICAgaWQsXG4gICAgICBpZGVhbEVycm9yRGlyZWN0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgcm93cyxcbiAgICAgIHZhbHVlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMudGV4dEFyZWEsXG4gICAgICBkaXNhYmxlZCA/IHN0eWxlcy5kaXNhYmxlZCA6IHN0eWxlcy5lbmFibGVkLFxuICAgICAgaGFzRXJyb3IgfHwgZXJyb3JNZXNzYWdlID8gc3R5bGVzLmVycm9yZWQgOiBzdHlsZXMubm9ybWFsXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8c3Bhbj5cbiAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkID8gYCR7aWR9LWdlc3RhbHQtZXJyb3JgIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmlhLWludmFsaWQ9e2Vycm9yTWVzc2FnZSB8fCBoYXNFcnJvciA/ICd0cnVlJyA6ICdmYWxzZSd9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgcm93cz17cm93c31cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5lcnJvcklzT3BlbiA/IChcbiAgICAgICAgICA8Rmx5b3V0XG4gICAgICAgICAgICBhbmNob3I9e3RoaXMudGV4dGFyZWF9XG4gICAgICAgICAgICBjb2xvcj1cIm9yYW5nZVwiXG4gICAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxFcnJvckRpcmVjdGlvbn1cbiAgICAgICAgICAgIG9uRGlzbWlzcz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KX1cbiAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveCBwYWRkaW5nPXszfT5cbiAgICAgICAgICAgICAgPFRleHQgYm9sZCBjb2xvcj1cIndoaXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgRmx5b3V0IGZyb20gJy4vRmx5b3V0LmpzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0RmllbGQuY3NzJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgZXJyb3JJc09wZW46IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhdXRvQ29tcGxldGU/OiAnY3VycmVudC1wYXNzd29yZCcgfCAnb24nIHwgJ29mZicgfCAndXNlcm5hbWUnLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpZGVhbEVycm9yRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgLyogZGVmYXVsdDogcmlnaHQgKi8sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQmx1cj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25DaGFuZ2U6ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25Gb2N1cz86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25LZXlEb3duPzogKHtcbiAgICBldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgdHlwZT86ICdkYXRlJyB8ICdlbWFpbCcgfCAnbnVtYmVyJyB8ICdwYXNzd29yZCcgfCAndGV4dCcgfCAndXJsJyxcbiAgdmFsdWU/OiBzdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgICdjdXJyZW50LXBhc3N3b3JkJyxcbiAgICAgICdvbicsXG4gICAgICAnb2ZmJyxcbiAgICAgICd1c2VybmFtZScsXG4gICAgXSksXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGVycm9yTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNFcnJvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAnZGF0ZScsXG4gICAgICAnZW1haWwnLFxuICAgICAgJ251bWJlcicsXG4gICAgICAncGFzc3dvcmQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3VybCcsXG4gICAgXSksXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246ICdyaWdodCcsXG4gICAgdHlwZTogJ3RleHQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGVycm9ySXNPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcywgc3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmVycm9yTWVzc2FnZSAhPT0gc3RhdGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcklzT3BlbjogISFwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgZXZlbnQsXG4gICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25CbHVyKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IHRydWUgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyh7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25LZXlEb3duKSB7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5RG93bih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0ZXh0ZmllbGQ6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgaWRlYWxFcnJvckRpcmVjdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnRleHRGaWVsZCxcbiAgICAgIGRpc2FibGVkID8gc3R5bGVzLmRpc2FibGVkIDogc3R5bGVzLmVuYWJsZWQsXG4gICAgICBoYXNFcnJvciB8fCBlcnJvck1lc3NhZ2UgPyBzdHlsZXMuZXJyb3JlZCA6IHN0eWxlcy5ub3JtYWxcbiAgICApO1xuXG4gICAgLy8gdHlwZT0nbnVtYmVyJyBkb2Vzbid0IHdvcmsgb24gaW9zIHNhZmFyaSB3aXRob3V0IGEgcGF0dGVyblxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NDQ3NjY4L2lucHV0LXR5cGUtbnVtYmVyLWlzLW5vdC1zaG93aW5nLWEtbnVtYmVyLWtleXBhZC1vbi1pb3NcbiAgICBjb25zdCBwYXR0ZXJuID0gdHlwZSA9PT0gJ251bWJlcicgPyAnXFxcXGQqJyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiAoXG4gICAgICA8c3Bhbj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkID8gYCR7aWR9LWdlc3RhbHQtZXJyb3JgIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmlhLWludmFsaWQ9e2Vycm9yTWVzc2FnZSB8fCBoYXNFcnJvciA/ICd0cnVlJyA6ICdmYWxzZSd9XG4gICAgICAgICAgYXV0b0NvbXBsZXRlPXthdXRvQ29tcGxldGV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBwYXR0ZXJuPXtwYXR0ZXJufVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0ZmllbGQgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICB0aGlzLnN0YXRlLmVycm9ySXNPcGVuICYmIChcbiAgICAgICAgICAgIDxGbHlvdXRcbiAgICAgICAgICAgICAgYW5jaG9yPXt0aGlzLnRleHRmaWVsZH1cbiAgICAgICAgICAgICAgY29sb3I9XCJvcmFuZ2VcIlxuICAgICAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxFcnJvckRpcmVjdGlvbn1cbiAgICAgICAgICAgICAgb25EaXNtaXNzPXsoKSA9PiB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pfVxuICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezN9PlxuICAgICAgICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICAgICl9XG4gICAgICA8L3NwYW4+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBNYXNrIGZyb20gJy4vTWFzay5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbG9yPzogJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnLFxuICBpY29uPzogJ2Fycm93LWNpcmNsZS1mb3J3YXJkJywgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+LFxuICB0aHVtYm5haWw/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvYXN0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNvbG9yID0gJ2RhcmtHcmF5JywgaWNvbiwgdGh1bWJuYWlsLCB0ZXh0IH0gPSBwcm9wcztcblxuICBsZXQgY29udGVudHM7XG4gIC8vIENvbmZpcm1hdGlvbiBUb2FzdHNcbiAgaWYgKHRleHQgaW5zdGFuY2VvZiBBcnJheSAmJiB0ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICBjb250ZW50cyA9IChcbiAgICAgIDxCb3ggeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19PlxuICAgICAgICA8Qm94IHhzPXt7IGRpc3BsYXk6ICdmbGV4Q29sdW1uJyB9fSBmbGV4PVwibm9uZVwiIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCI+XG4gICAgICAgICAge3RodW1ibmFpbCA/IChcbiAgICAgICAgICAgIDxNYXNrIHNoYXBlPVwicm91bmRlZFwiIGhlaWdodD17NDh9IHdpZHRoPXs0OH0+XG4gICAgICAgICAgICAgIHt0aHVtYm5haWx9XG4gICAgICAgICAgICA8L01hc2s+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94XG4gICAgICAgICAgeHM9e3sgZGlzcGxheTogJ2ZsZXhDb2x1bW4nIH19XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMTAgfSB9fVxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IGZvbnRXZWlnaHQ6ICdub3JtYWwnIH0gfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgc2l6ZT1cImxnXCI+XG4gICAgICAgICAgICAgIHt0ZXh0WzBdfVxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgICAge3RleHRbMV19XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9hc3RzIGFzIEd1aWRlc1xuICAgIGNvbnRlbnRzID0gKFxuICAgICAgPEJveFxuICAgICAgICB4cz17eyBkaXNwbGF5OiAnZmxleCcgfX1cbiAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJiZXR3ZWVuXCJcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICA+XG4gICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgIHt0ZXh0fVxuICAgICAgICA8L1RleHQ+XG4gICAgICAgIHtpY29uICYmIChcbiAgICAgICAgICA8Qm94IGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMjQgfSB9fT5cbiAgICAgICAgICAgIDxJY29uIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIGNvbG9yPVwid2hpdGVcIiBpY29uPXtpY29ufSBzaXplPXszNn0gLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxCb3ggbWFyZ2luQm90dG9tPXszfSBwYWRkaW5nWD17NH0gbWF4V2lkdGg9ezM3Nn0gd2lkdGg9XCIxMDB2d1wiPlxuICAgICAgPEJveCBjb2xvcj17Y29sb3J9IGZpdCBwYWRkaW5nWD17OH0gcGFkZGluZ1k9ezV9IHNoYXBlPVwicGlsbFwiPlxuICAgICAgICB7Y29udGVudHN9XG4gICAgICA8L0JveD5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuVG9hc3QucHJvcFR5cGVzID0ge1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGFya0dyYXknLCAnb3JhbmdlJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoWydhcnJvdy1jaXJjbGUtZm9yd2FyZCddKSwgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICBdKS5pc1JlcXVpcmVkLFxuICB0aHVtYm5haWw6IFByb3BUeXBlcy5ub2RlLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcgLyogZGVmYXVsdCBtZCAqLyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb29sdGlwKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGNoaWxkcmVuLFxuICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgIG9uRGlzbWlzcyxcbiAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IgPSB0cnVlLFxuICAgIHNpemUgPSAnbWQnLFxuICB9ID0gcHJvcHM7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPENvbnRyb2xsZXJcbiAgICAgIGFuY2hvcj17YW5jaG9yfVxuICAgICAgYmdDb2xvcj1cImRhcmtHcmF5XCJcbiAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbERpcmVjdGlvbn1cbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj17cG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yfVxuICAgICAgb25EaXNtaXNzPXtvbkRpc21pc3N9XG4gICAgICBzaXplPXtzaXplfVxuICAgID5cbiAgICAgIDxCb3ggY29sdW1uPXsxMn0gcGFkZGluZz17M30+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQm94PlxuICAgIDwvQ29udHJvbGxlcj5cbiAgKTtcbn1cblxuVG9vbHRpcC5wcm9wVHlwZXMgPSB7XG4gIGFuY2hvcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjb250YWluczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1RvdWNoYWJsZS5jc3MnO1xuXG50eXBlIFNoYXBlID1cbiAgfCAnc3F1YXJlJ1xuICB8ICdyb3VuZGVkJ1xuICB8ICdwaWxsJ1xuICB8ICdjaXJjbGUnXG4gIHwgJ3JvdW5kZWRUb3AnXG4gIHwgJ3JvdW5kZWRCb3R0b20nXG4gIHwgJ3JvdW5kZWRMZWZ0J1xuICB8ICdyb3VuZGVkUmlnaHQnO1xuXG50eXBlIE1vdXNlQ3Vyc29yID1cbiAgfCAnY29weSdcbiAgfCAnZ3JhYidcbiAgfCAnZ3JhYmJpbmcnXG4gIHwgJ21vdmUnXG4gIHwgJ25vRHJvcCdcbiAgfCAncG9pbnRlcidcbiAgfCAnem9vbUluJ1xuICB8ICd6b29tT3V0JztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgZnVsbEhlaWdodD86IGJvb2xlYW4sXG4gIGZ1bGxXaWR0aD86IGJvb2xlYW4sXG4gIG1vdXNlQ3Vyc29yPzogTW91c2VDdXJzb3IsXG4gIG9uTW91c2VFbnRlcj86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25Ub3VjaD86ICh7XG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICB9KSA9PiB2b2lkLFxuICBzaGFwZT86IFNoYXBlLFxufH07XG5cbmNvbnN0IFNQQUNFX0NIQVJfQ09ERSA9IDMyO1xuY29uc3QgRU5URVJfQ0hBUl9DT0RFID0gMTM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBoYW5kbGVLZXlQcmVzcyA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVG91Y2ggfSA9IHRoaXMucHJvcHM7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHNwYWNlIG9yIGVudGVyIHdlcmUgcHJlc3NlZFxuICAgIGlmIChcbiAgICAgIG9uVG91Y2ggJiZcbiAgICAgIChldmVudC5jaGFyQ29kZSA9PT0gU1BBQ0VfQ0hBUl9DT0RFIHx8IGV2ZW50LmNoYXJDb2RlID09PSBFTlRFUl9DSEFSX0NPREUpXG4gICAgKSB7XG4gICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBzdG9wIHNjcm9sbGluZyB3aGVuIHNwYWNlIGlzIHByZXNzZWRcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvblRvdWNoKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1bGxXaWR0aCA9IHRydWUsXG4gICAgICBmdWxsSGVpZ2h0LFxuICAgICAgbW91c2VDdXJzb3IgPSAncG9pbnRlcicsXG4gICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICBvblRvdWNoLFxuICAgICAgc2hhcGUgPSAnc3F1YXJlJyxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnRvdWNoYWJsZSxcbiAgICAgIHN0eWxlc1ttb3VzZUN1cnNvcl0sXG4gICAgICBzdHlsZXNbc2hhcGVdLFxuICAgICAge1xuICAgICAgICBbc3R5bGVzLmZ1bGxIZWlnaHRdOiBmdWxsSGVpZ2h0LFxuICAgICAgICBbc3R5bGVzLmZ1bGxXaWR0aF06IGZ1bGxXaWR0aCxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICBvbkNsaWNrPXtldmVudCA9PiBvblRvdWNoICYmIG9uVG91Y2goeyBldmVudCB9KX1cbiAgICAgICAgb25Nb3VzZUVudGVyPXtldmVudCA9PiBvbk1vdXNlRW50ZXIgJiYgb25Nb3VzZUVudGVyKHsgZXZlbnQgfSl9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17ZXZlbnQgPT4gb25Nb3VzZUxlYXZlICYmIG9uTW91c2VMZWF2ZSh7IGV2ZW50IH0pfVxuICAgICAgICBvbktleVByZXNzPXt0aGlzLmhhbmRsZUtleVByZXNzfVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5Ub3VjaGFibGUucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGZ1bGxIZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuICBtb3VzZUN1cnNvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnY29weScsXG4gICAgJ2dyYWInLFxuICAgICdncmFiYmluZycsXG4gICAgJ21vdmUnLFxuICAgICdub0Ryb3AnLFxuICAgICdwb2ludGVyJyxcbiAgICAnem9vbUluJyxcbiAgICAnem9vbU91dCcsXG4gIF0pLFxuICBvblRvdWNoOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3NxdWFyZScsXG4gICAgJ3JvdW5kZWQnLFxuICAgICdwaWxsJyxcbiAgICAnY2lyY2xlJyxcbiAgICAncm91bmRlZFRvcCcsXG4gICAgJ3JvdW5kZWRCb3R0b20nLFxuICAgICdyb3VuZGVkTGVmdCcsXG4gICAgJ3JvdW5kZWRSaWdodCcsXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9WaWRlby5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgc2VlazogKHRpbWU6IG51bWJlcikgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgc2Vla2luZzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlb1BsYXloZWFkIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjdXJyZW50VGltZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc2VlazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBzZWVraW5nOiBmYWxzZSxcbiAgfTtcblxuICBzZXRQbGF5aGVhZFJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWhlYWQgPSByZWY7XG4gIH07XG5cbiAgc2VlayA9IChjbGllbnRYOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy5wbGF5aGVhZCkge1xuICAgICAgY29uc3QgeyBkdXJhdGlvbiwgc2VlayB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgbGVmdCwgd2lkdGggfSA9IHRoaXMucGxheWhlYWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oKGNsaWVudFggLSBsZWZ0KSAvIHdpZHRoLCAxKSk7XG4gICAgICBjb25zdCBuZXdUaW1lID0gcGVyY2VudCAqIGR1cmF0aW9uO1xuICAgICAgc2VlayhuZXdUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgc3RvcENsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgaGFuZGxlTW91c2VEb3duID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWVraW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuc2VlayhldmVudC5jbGllbnRYKTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBzZWVraW5nIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICB0aGlzLnNlZWsoZXZlbnQuY2xpZW50WCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlZWtpbmc6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHBsYXloZWFkOiA/SFRNTERpdkVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIGR1cmF0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHdpZHRoID0gYCR7TWF0aC5mbG9vcihjdXJyZW50VGltZSAqIDEwMDAwIC8gZHVyYXRpb24pIC8gMTAwfSVgO1xuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgIGZsZXg9XCJncm93XCJcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgIGhlaWdodD17MTZ9XG4gICAgICA+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBhcmlhLXZhbHVlbWF4PXtkdXJhdGlvbn1cbiAgICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgICAgYXJpYS12YWx1ZW5vdz17Y3VycmVudFRpbWV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMucGxheWhlYWR9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5zdG9wQ2xpY2t9XG4gICAgICAgICAgb25LZXlQcmVzcz17dGhpcy5zdG9wQ2xpY2t9XG4gICAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICAgIG9uTW91c2VNb3ZlPXt0aGlzLmhhbmRsZU1vdXNlTW92ZX1cbiAgICAgICAgICBvbk1vdXNlVXA9e3RoaXMuaGFuZGxlTW91c2VVcH1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0UGxheWhlYWRSZWZ9XG4gICAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgICAgICB0YWJJbmRleD1cIi0xXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIGxlZnRcbiAgICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIGNvbG9yPVwibGlnaHRHcmF5XCJcbiAgICAgICAgICAgIHNoYXBlPVwicm91bmRlZFwiXG4gICAgICAgICAgICBoZWlnaHQ9ezR9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveCBjb2xvcj1cIndoaXRlXCIgc2hhcGU9XCJyb3VuZGVkXCIgaGVpZ2h0PVwiMTAwJVwiIHdpZHRoPXt3aWR0aH0gLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIHNoYXBlPVwicm91bmRlZFwiXG4gICAgICAgICAgICBoZWlnaHQ9ezR9XG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgbGVmdDogd2lkdGggfSB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgICAgICAgICB3aWR0aD17MTZ9XG4gICAgICAgICAgICAgIGhlaWdodD17MTZ9XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0PXstMn1cbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IG1hcmdpblRvcDogLTYgfSB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBUb3VjaGFibGUgZnJvbSAnLi9Ub3VjaGFibGUuanMnO1xuaW1wb3J0IFZpZGVvUGxheWhlYWQgZnJvbSAnLi9WaWRlb1BsYXloZWFkLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9WaWRlby5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbDogc3RyaW5nLFxuICBjdXJyZW50VGltZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBmdWxsc2NyZWVuOiBib29sZWFuLFxuICBvbkZ1bGxzY3JlZW5DaGFuZ2U6ICgpID0+IHZvaWQsXG4gIG9uUGF1c2U6IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB2b2lkLFxuICBvblBsYXk6IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB2b2lkLFxuICBvblZvbHVtZUNoYW5nZTogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHZvaWQsXG4gIHBsYXlpbmc6IGJvb2xlYW4sXG4gIHNlZWs6ICh0aW1lOiBudW1iZXIpID0+IHZvaWQsXG4gIHZvbHVtZTogbnVtYmVyLFxufH07XG5cbmNvbnN0IGZ1bGxzY3JlZW5FbmFibGVkID0gKCkgPT5cbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVuYWJsZWQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZDtcblxuY29uc3QgdGltZVRvU3RyaW5nID0gKHRpbWU/OiBudW1iZXIpID0+IHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IodGltZSB8fCAwKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3Iocm91bmRlZCAvIDYwKTtcbiAgY29uc3Qgc2Vjb25kcyA9IHJvdW5kZWQgLSBtaW51dGVzICogNjA7XG4gIGNvbnN0IG1pbnV0ZXNTdHIgPSBtaW51dGVzIDwgMTAgPyBgMCR7bWludXRlc31gIDogbWludXRlcztcbiAgY29uc3Qgc2Vjb25kc1N0ciA9IHNlY29uZHMgPCAxMCA/IGAwJHtzZWNvbmRzfWAgOiBzZWNvbmRzO1xuICByZXR1cm4gYCR7bWludXRlc1N0cn06JHtzZWNvbmRzU3RyfWA7XG59O1xuXG5jbGFzcyBWaWRlb0NvbnRyb2xzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBjdXJyZW50VGltZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZnVsbHNjcmVlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb25QYXVzZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblBsYXk6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgb25Wb2x1bWVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgcGxheWluZzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgICBzZWVrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHZvbHVtZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSAoe1xuICAgIGV2ZW50LFxuICB9OiB7XG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICB9KSA9PiB7XG4gICAgY29uc3QgeyBvbkZ1bGxzY3JlZW5DaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgb25GdWxsc2NyZWVuQ2hhbmdlKCk7XG4gIH07XG5cbiAgaGFuZGxlUGxheWluZ0NoYW5nZSA9ICh7XG4gICAgZXZlbnQsXG4gIH06IHtcbiAgICBldmVudDpcbiAgICAgIHwgU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD5cbiAgICAgIHwgU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IHBsYXlpbmcsIG9uUGF1c2UsIG9uUGxheSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAocGxheWluZykge1xuICAgICAgb25QYXVzZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUGxheShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVZvbHVtZUNoYW5nZSA9ICh7XG4gICAgZXZlbnQsXG4gIH06IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlcyAqL1xuICAgIGV2ZW50OlxuICAgICAgfCBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgICAgfCBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzICovXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IG9uVm9sdW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uVm9sdW1lQ2hhbmdlKGV2ZW50KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWwsXG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZnVsbHNjcmVlbixcbiAgICAgIHBsYXlpbmcsXG4gICAgICBzZWVrLFxuICAgICAgdm9sdW1lLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG11dGVkID0gdm9sdW1lID09PSAwO1xuICAgIGNvbnN0IHNob3dGdWxsc2NyZWVuQnV0dG9uID1cbiAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFmdWxsc2NyZWVuRW5hYmxlZCgpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRyb2xzfT5cbiAgICAgICAgPEJveCBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VG91Y2hhYmxlIG9uVG91Y2g9e3RoaXMuaGFuZGxlUGxheWluZ0NoYW5nZX0gZnVsbFdpZHRoPXtmYWxzZX0+XG4gICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e1xuICAgICAgICAgICAgICAgIHBsYXlpbmcgPyBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbCA6IGFjY2Vzc2liaWxpdHlQbGF5TGFiZWxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgaWNvbj17cGxheWluZyA/ICdwYXVzZScgOiAncGxheSd9XG4gICAgICAgICAgICAgIHNpemU9ezIwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1RvdWNoYWJsZT5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxCb3ggd2lkdGg9ezUwfSBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgYWxpZ249XCJyaWdodFwiIHNpemU9XCJ4c1wiPlxuICAgICAgICAgICAge3RpbWVUb1N0cmluZyhjdXJyZW50VGltZSl9XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCBwYWRkaW5nPXsyfSBmbGV4PVwiZ3Jvd1wiPlxuICAgICAgICAgIDxWaWRlb1BsYXloZWFkXG4gICAgICAgICAgICBjdXJyZW50VGltZT17Y3VycmVudFRpbWV9XG4gICAgICAgICAgICBkdXJhdGlvbj17ZHVyYXRpb259XG4gICAgICAgICAgICBzZWVrPXtzZWVrfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94IHdpZHRoPXs1MH0gcGFkZGluZz17Mn0+XG4gICAgICAgICAgPFRleHQgY29sb3I9XCJ3aGl0ZVwiIGFsaWduPVwicmlnaHRcIiBzaXplPVwieHNcIj5cbiAgICAgICAgICAgIHt0aW1lVG9TdHJpbmcoZHVyYXRpb24pfVxuICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxCb3ggcGFkZGluZz17Mn0+XG4gICAgICAgICAgPFRvdWNoYWJsZSBvblRvdWNoPXt0aGlzLmhhbmRsZVZvbHVtZUNoYW5nZX0gZnVsbFdpZHRoPXtmYWxzZX0+XG4gICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e1xuICAgICAgICAgICAgICAgIG11dGVkID8gYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsIDogYWNjZXNzaWJpbGl0eU11dGVMYWJlbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBpY29uPXttdXRlZCA/ICdtdXRlJyA6ICdzb3VuZCd9XG4gICAgICAgICAgICAgIHNpemU9ezIwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1RvdWNoYWJsZT5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIHtzaG93RnVsbHNjcmVlbkJ1dHRvbiAmJiAoXG4gICAgICAgICAgPEJveCBwYWRkaW5nPXsyfT5cbiAgICAgICAgICAgIDxUb3VjaGFibGUgb25Ub3VjaD17dGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlfSBmdWxsV2lkdGg9e2ZhbHNlfT5cbiAgICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e1xuICAgICAgICAgICAgICAgICAgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICAgICA/IGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsXG4gICAgICAgICAgICAgICAgICAgIDogYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgICAgaWNvbj17ZnVsbHNjcmVlbiA/ICdtaW5pbWl6ZScgOiAnbWF4aW1pemUnfVxuICAgICAgICAgICAgICAgIHNpemU9ezIwfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9Ub3VjaGFibGU+XG4gICAgICAgICAgPC9Cb3g+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvQ29udHJvbHM7XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFZpZGVvQ29udHJvbHMgZnJvbSAnLi9WaWRlb0NvbnRyb2xzLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9WaWRlby5jc3MnO1xuXG50eXBlIFZpZGVvV2l0aENvbnRyb2xzID0ge3xcbiAgYWNjZXNzaWJpbGl0eU1heGltaXplTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5UGF1c2VMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbDogc3RyaW5nLFxuICBjb250cm9sczogYm9vbGVhbixcbnx9O1xuXG50eXBlIFZpZGVvTm9Db250cm9scyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsPzogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbD86IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbD86IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw/OiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw/OiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbD86IHN0cmluZyxcbiAgY29udHJvbHM/OiBudWxsLFxufH07XG5cbnR5cGUgQ29udHJvbHMgPSBWaWRlb1dpdGhDb250cm9scyB8IFZpZGVvTm9Db250cm9scztcblxudHlwZSBTb3VyY2UgPVxuICB8IHN0cmluZ1xuICB8IEFycmF5PHt8IHR5cGU6ICd2aWRlby9tM3U4JyB8ICd2aWRlby9tcDQnIHwgJ3ZpZGVvL29nZycsIHNyYzogc3RyaW5nIHx9PjtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFzcGVjdFJhdGlvOiBudW1iZXIsXG4gIGNhcHRpb25zOiBzdHJpbmcsXG4gIGxvb3A/OiBib29sZWFuLFxuICBvbkR1cmF0aW9uQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4sXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgb25FbmRlZD86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbkZ1bGxzY3JlZW5DaGFuZ2U/OiAoeyBldmVudDogRXZlbnQsIGZ1bGxzY3JlZW46IGJvb2xlYW4gfSkgPT4gdm9pZCxcbiAgb25Mb2FkZWRDaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PixcbiAgICBsb2FkZWQ6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgb25QbGF5PzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblBhdXNlPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblJlYWR5PzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uU2Vlaz86ICh7IGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvblRpbWVDaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PixcbiAgICB0aW1lOiBudW1iZXIsXG4gIH0pID0+IHZvaWQsXG4gIG9uVm9sdW1lQ2hhbmdlPzogKHtcbiAgICBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICAgIHZvbHVtZTogbnVtYmVyLFxuICB9KSA9PiB2b2lkLFxuICBwbGF5YmFja1JhdGU6IG51bWJlcixcbiAgcGxheWluZzogYm9vbGVhbixcbiAgcGxheXNJbmxpbmU/OiBib29sZWFuLFxuICBwb3N0ZXI/OiBzdHJpbmcsXG4gIHByZWxvYWQ6ICdhdXRvJyB8ICdtZXRhZGF0YScgfCAnbm9uZScsXG4gIHNyYzogU291cmNlLFxuICB2b2x1bWU6IG51bWJlcixcbiAgLi4uQ29udHJvbHMsXG58fTtcblxudHlwZSBTdGF0ZSA9IHt8XG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGZ1bGxzY3JlZW46IGJvb2xlYW4sXG58fTtcblxuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZnVsbHNjcmVlbiBhbmQgdmVuZG9yIHByZWZpeGVzIHNlZVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Z1bGxzY3JlZW5fQVBJXG5cbmNvbnN0IHJlcXVlc3RGdWxsc2NyZWVuID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSA9PiB7XG4gIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfVxufTtcblxuY29uc3QgZXhpdEZ1bGxzY3JlZW4gPSAoKSA9PiB7XG4gIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICB9XG59O1xuXG4vLyBOb3JtYWxseSBkb2N1bWVudC5mdWxsc2NyZWVuIHN1ZmZpY2VzIGhlcmUgYXMgYSBmbGFnLCBidXQgSUUxMSBkb2VzIG5vdFxuLy8gaGF2ZSBhIHZlbmRvciBzcGVjaWZpYyB2ZXJzaW9uIHNvIHdlIG11c3QgaW5zdGVhZCB1c2UgdGhlIGFjdHVhbCBlbGVtZW50XG5jb25zdCBpc0Z1bGxzY3JlZW4gPSAoKSA9PlxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50O1xuXG5jb25zdCBhZGRGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciA9IChsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcikgPT4ge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCByZW1vdmVGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciA9IChsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcikgPT4ge1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgbGlzdGVuZXIpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBsaXN0ZW5lcik7XG59O1xuXG5jb25zdCBpc05ld1NvdXJjZSA9IChvbGRTb3VyY2U6IFNvdXJjZSwgbmV3U291cmNlOiBTb3VyY2UpOiBib29sZWFuID0+IHtcbiAgaWYgKHR5cGVvZiBvbGRTb3VyY2UgIT09IHR5cGVvZiBuZXdTb3VyY2UpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIHR5cGUgY2hhbmdlZCBmcm9tIHN0cmluZyB0byBBcnJheVxuICAgIC8vIG9yIHZpY2UgdmVyc2EsIHdlIGhhdmUgYSBuZXcgc291cmNlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV3U291cmNlKSkge1xuICAgIGlmIChvbGRTb3VyY2UubGVuZ3RoICE9PSBuZXdTb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBJZiB0aGUgc291cmNlcyBhcmUgYm90aCBhbiBBcnJheSwgYW5kIHRoZSBsZW5ndGhzXG4gICAgICAvLyBkbyBub3QgbWF0Y2ggd2UgZXZhbHVhdGUgYXMgYSBuZXcgc291cmNlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHNvdXJjZXMgYXJlIGJvdGggYW4gQXJyYXkgYW5kIHRoZSBzYW1lIGxlbmd0aCxcbiAgICAvLyB2ZXJpZnkgZXZlcnkgZWxlbWVudCBzdGF5ZWQgdGhlIHNhbWVcbiAgICByZXR1cm4gbmV3U291cmNlLnNvbWUoXG4gICAgICAoc291cmNlLCBpbmRleCkgPT5cbiAgICAgICAgIUFycmF5LmlzQXJyYXkob2xkU291cmNlKSB8fFxuICAgICAgICBzb3VyY2UudHlwZSAhPT0gb2xkU291cmNlW2luZGV4XS50eXBlIHx8XG4gICAgICAgIHNvdXJjZS5zcmMgIT09IG9sZFNvdXJjZVtpbmRleF0uc3JjXG4gICAgKTtcbiAgfVxuICAvLyBJZiB0aGUgc291cmNlcyBhcmUgYm90aCBhIHN0cmluZywgc2ltcGx5IGNvbXBhcmVcbiAgLy8gdGhlIG5ldyB3aXRoIHRoZSBvbGRcbiAgcmV0dXJuIG5ld1NvdXJjZSAhPT0gb2xkU291cmNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW8gZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlNdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBjYXB0aW9uczogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNvbnRyb2xzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsb29wOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkVuZGVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZGVkQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBsYXk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUGF1c2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uU2VlazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25UaW1lQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblZvbHVtZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxheWJhY2tSYXRlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHBsYXlpbmc6IFByb3BUeXBlcy5ib29sLFxuICAgIHBsYXlzSW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwb3N0ZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJlbG9hZDogUHJvcFR5cGVzLm9uZU9mKFsnYXV0bycsICdtZXRhZGF0YScsICdub25lJ10pLFxuICAgIHNyYzogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsndmlkZW8vbTN1OCcsICd2aWRlby9tcDQnLCAndmlkZW8vb2dnJ10pXG4gICAgICAgICAgICAuaXNSZXF1aXJlZCxcbiAgICAgICAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgXSkuaXNSZXF1aXJlZCxcbiAgICB2b2x1bWU6IFByb3BUeXBlcy5udW1iZXIsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBwbGF5YmFja1JhdGU6IDEsXG4gICAgcGxheWluZzogZmFsc2UsXG4gICAgcHJlbG9hZDogJ2F1dG8nLFxuICAgIHZvbHVtZTogMSxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBjdXJyZW50VGltZTogMCxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBmdWxsc2NyZWVuOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogUmVhY3QgbGlmZWN5Y2xlIGhvb2tzIHBlcnRpbmVudCB0byBWaWRlb1xuICAgKi9cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IHBsYXliYWNrUmF0ZSwgcGxheWluZywgdm9sdW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnMgdG8gY2F0Y2ggYmFja2Rvb3JzIGluIGZ1bGxzY3JlZW5cbiAgICAvLyBjaGFuZ2VzIHN1Y2ggYXMgdXNpbmcgdGhlIEVTQyBrZXkgdG8gZXhpdFxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhZGRGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lcih0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgIH1cbiAgICAvLyBMb2FkIHRoZSB2aWRlbyB0byBoeWRyYXRlIHRoZSBET00gYWZ0ZXIgYSBzZXJ2ZXIgcmVuZGVyXG4gICAgdGhpcy5sb2FkKCk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHZvbHVtZVxuICAgIHRoaXMuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLnNldFBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpO1xuICAgIC8vIFNpbXVsYXRlIGFuIGF1dG9wbGF5IGVmZmVjdCBpZiB0aGUgY29tcG9uZW50XG4gICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzKSB7XG4gICAgLy8gSWYgdGhlIHZpZGVvIHNvdXJjZSBjaGFuZ2VkLCByZWxvYWQgdGhlIHZpZGVvXG4gICAgaWYgKGlzTmV3U291cmNlKHByZXZQcm9wcy5zcmMsIHRoaXMucHJvcHMuc3JjKSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB2b2x1bWUgY2hhbmdlZCwgc2V0IHRoZSBuZXcgdm9sdW1lXG4gICAgaWYgKHByZXZQcm9wcy52b2x1bWUgIT09IHRoaXMucHJvcHMudm9sdW1lKSB7XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLnByb3BzLnZvbHVtZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwbGF5YmFjayByYXRlIGNoYW5nZWQsIHNldCB0aGUgbmV3IHJhdGVcbiAgICBpZiAocHJldlByb3BzLnBsYXliYWNrUmF0ZSAhPT0gdGhpcy5wcm9wcy5wbGF5YmFja1JhdGUpIHtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucHJvcHMucGxheWJhY2tSYXRlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHBsYXliYWNrIGNoYW5nZWQsIHBsYXkgb3IgcGF1c2UgdGhlIHZpZGVvXG4gICAgaWYgKHByZXZQcm9wcy5wbGF5aW5nICE9PSB0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgcmVtb3ZlRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIodGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBET00gcmVmZXJlbmNlIGhvdXNla2VlcGluZyB0aGF0IGlzIG5lZWRlZCBmb3IgZnVuY3Rpb25hbGl0eVxuICAgKi9cblxuICAvLyBUaGUgcGxheWVyIGVsZW1lbnQgZW5jYXBzdWxhdGVzIHRoZSBhY3R1YWwgdmlkZW8gRE9NXG4gIC8vIGVsZW1lbnQgYXMgd2VsbCBhcyB0aGUgY29udHJvbHMgdG8gYnJpbmcgYm90aCBmdWxsc2NyZWVuXG4gIHNldFBsYXllclJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWVyID0gcmVmO1xuICB9O1xuXG4gIC8vIFRoZSBhY3R1YWwgcmVmZXJlbmNlIHRvIHRoZSB2aWRlbyBIVE1MIERPTSBlbGVtZW50XG4gIHNldFZpZGVvUmVmID0gKHJlZjogP0hUTUxWaWRlb0VsZW1lbnQpID0+IHtcbiAgICB0aGlzLnZpZGVvID0gcmVmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbnMgdGhhdCBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBIVE1MIHZpZGVvIGVsZW1lbnRcbiAgICovXG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCBwbGF5YmFjayByYXRlOiAxIChub3JtYWwpXG4gIHNldFBsYXliYWNrUmF0ZSA9IChwbGF5YmFja1JhdGU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2V0IHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCB2b2x1bWU6IDAgKG11dGVkKSAtPiAxIChtYXgpXG4gIHNldFZvbHVtZSA9ICh2b2x1bWU6IG51bWJlcikgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnZvbHVtZSA9IHZvbHVtZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hhbmdlIHRoZSB2aWRlbyBzb3VyY2UgYW5kIHJlLWxvYWQgdGhlIHZpZGVvXG4gIGxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ubG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXVzZSB0aGUgdmlkZW9cbiAgcGF1c2UgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGxheSB0aGUgdmlkZW9cbiAgcGxheSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlZWsgdGhlIHZpZGVvIHRvIHRoZSBkZXNpcmVkIHRpbWVcbiAgc2VlayA9ICh0aW1lOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVudGVyL2V4aXQgZnVsbHNjcmVlbiB2aWRlbyBwbGF5ZXIgbW9kZVxuICB0b2dnbGVGdWxsc2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChpc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICByZXF1ZXN0RnVsbHNjcmVlbih0aGlzLnBsYXllcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVycyBmb3IgdmFyaW91cyBtZWRpYSBldmVudHMgb24gdGhlIHZpZGVvXG4gICAqL1xuXG4gIC8vIFNlbnQgd2hlbiBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgdGhhdCB0aGUgbWVkaWEgY2FuIGJlIHBsYXllZFxuICBoYW5kbGVDYW5QbGF5ID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25SZWFkeSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblJlYWR5KSB7XG4gICAgICBvblJlYWR5KHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBtZXRhZGF0YSBoYXMgbG9hZGVkIG9yIGNoYW5nZWQsIGluZGljYXRpbmcgYSBjaGFuZ2UgaW5cbiAgLy8gZHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gIGhhbmRsZUR1cmF0aW9uQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25EdXJhdGlvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkdXJhdGlvbiA9ICh0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8uZHVyYXRpb24pIHx8IDA7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGR1cmF0aW9uIH0pO1xuXG4gICAgaWYgKG9uRHVyYXRpb25DaGFuZ2UpIHtcbiAgICAgIG9uRHVyYXRpb25DaGFuZ2UoeyBldmVudCwgZHVyYXRpb24gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBjb21wbGV0ZXMuXG4gIGhhbmRsZUVuZGVkID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25FbmRlZCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvbkVuZGVkKSB7XG4gICAgICBvbkVuZGVkKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgdmlkZW8gaXMgc3dpdGNoZWQgdG8vb3V0LW9mIGZ1bGxzY3JlZW4gbW9kZVxuICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25GdWxsc2NyZWVuQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZ1bGxzY3JlZW4gPSAhIWlzRnVsbHNjcmVlbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmdWxsc2NyZWVuIH0pO1xuXG4gICAgaWYgKG9uRnVsbHNjcmVlbkNoYW5nZSkge1xuICAgICAgb25GdWxsc2NyZWVuQ2hhbmdlKHsgZXZlbnQsIGZ1bGxzY3JlZW4gfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBvZiB0aGUgbWVkaWEgc3RhcnRzIGFmdGVyIGhhdmluZyBiZWVuIHBhdXNlZC5cbiAgaGFuZGxlUGxheSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblBsYXkgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25QbGF5KSB7XG4gICAgICBvblBsYXkoeyBldmVudCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgaGFuZGxlUGF1c2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25QYXVzZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblBhdXNlKSB7XG4gICAgICBvblBhdXNlKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgcGVyaW9kaWNhbGx5IHRvIGluZm9ybSBpbnRlcmVzdGVkIHBhcnRpZXMgb2YgcHJvZ3Jlc3MgZG93bmxvYWRpbmcgdGhlIG1lZGlhXG4gIGhhbmRsZVByb2dyZXNzID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25Mb2FkZWRDaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBidWZmZXJlZCB9ID0gdGhpcy52aWRlbyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWQgPVxuICAgICAgYnVmZmVyZWQgJiYgYnVmZmVyZWQubGVuZ3RoID4gMCA/IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSA6IDA7XG5cbiAgICBpZiAob25Mb2FkZWRDaGFuZ2UpIHtcbiAgICAgIG9uTG9hZGVkQ2hhbmdlKHsgZXZlbnQsIGxvYWRlZCB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VudCB3aGVuIGEgc2VlayBvcGVyYXRpb24gY29tcGxldGVzLlxuICBoYW5kbGVTZWVrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25TZWVrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG9uU2Vlaykge1xuICAgICAgb25TZWVrKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSB0aW1lIGluZGljYXRlZCBieSB0aGUgZWxlbWVudCdzIGN1cnJlbnRUaW1lIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZFxuICBoYW5kbGVUaW1lVXBkYXRlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25UaW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5jdXJyZW50VGltZSkgfHwgMDtcbiAgICB0aGlzLnNldFN0YXRlKHsgY3VycmVudFRpbWUgfSk7XG5cbiAgICBpZiAob25UaW1lQ2hhbmdlKSB7XG4gICAgICBvblRpbWVDaGFuZ2UoeyBldmVudCwgdGltZTogY3VycmVudFRpbWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiB0aGUgYXVkaW8gdm9sdW1lIGNoYW5nZXNcbiAgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVm9sdW1lQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG11dGVkID0gKHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5tdXRlZCkgfHwgZmFsc2U7XG5cbiAgICBpZiAob25Wb2x1bWVDaGFuZ2UpIHtcbiAgICAgIG9uVm9sdW1lQ2hhbmdlKHsgZXZlbnQsIHZvbHVtZTogbXV0ZWQgPyAxIDogMCB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmlkZW86ID9IVE1MVmlkZW9FbGVtZW50O1xuXG4gIHBsYXllcjogP0hUTUxEaXZFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIGNhcHRpb25zLFxuICAgICAgbG9vcCxcbiAgICAgIHBsYXlpbmcsXG4gICAgICBwbGF5c0lubGluZSxcbiAgICAgIHBvc3RlcixcbiAgICAgIHByZWxvYWQsXG4gICAgICBzcmMsXG4gICAgICB2b2x1bWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBjdXJyZW50VGltZSwgZHVyYXRpb24sIGZ1bGxzY3JlZW4gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gKGZ1bGxzY3JlZW4gJiYgJzAnKSB8fCBgJHsxIC8gYXNwZWN0UmF0aW8gKiAxMDB9JWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e3RoaXMuc2V0UGxheWVyUmVmfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5wbGF5ZXJ9XG4gICAgICAgIHN0eWxlPXt7IHBhZGRpbmdCb3R0b20sIGhlaWdodDogZnVsbHNjcmVlbiA/ICcxMDAlJyA6IDAgfX1cbiAgICAgID5cbiAgICAgICAgPHZpZGVvXG4gICAgICAgICAgYXV0b1BsYXk9e3BsYXlpbmd9XG4gICAgICAgICAgbG9vcD17bG9vcH1cbiAgICAgICAgICBtdXRlZD17dm9sdW1lID09PSAwfVxuICAgICAgICAgIHBsYXlzSW5saW5lPXtwbGF5c0lubGluZX1cbiAgICAgICAgICBwb3N0ZXI9e3Bvc3Rlcn1cbiAgICAgICAgICBwcmVsb2FkPXtwcmVsb2FkfVxuICAgICAgICAgIHNyYz17dHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiB1bmRlZmluZWR9XG4gICAgICAgICAgcmVmPXt0aGlzLnNldFZpZGVvUmVmfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZpZGVvfVxuICAgICAgICAgIG9uQ2FuUGxheT17dGhpcy5oYW5kbGVDYW5QbGF5fVxuICAgICAgICAgIG9uRHVyYXRpb25DaGFuZ2U9e3RoaXMuaGFuZGxlRHVyYXRpb25DaGFuZ2V9XG4gICAgICAgICAgb25FbmRlZD17dGhpcy5oYW5kbGVFbmRlZH1cbiAgICAgICAgICBvblNlZWtlZD17dGhpcy5oYW5kbGVTZWVrfVxuICAgICAgICAgIG9uVGltZVVwZGF0ZT17dGhpcy5oYW5kbGVUaW1lVXBkYXRlfVxuICAgICAgICAgIG9uUHJvZ3Jlc3M9e3RoaXMuaGFuZGxlUHJvZ3Jlc3N9XG4gICAgICAgID5cbiAgICAgICAgICB7QXJyYXkuaXNBcnJheShzcmMpICYmXG4gICAgICAgICAgICBzcmMubWFwKHNvdXJjZSA9PiAoXG4gICAgICAgICAgICAgIDxzb3VyY2Uga2V5PXtzb3VyY2Uuc3JjfSBzcmM9e3NvdXJjZS5zcmN9IHR5cGU9e3NvdXJjZS50eXBlfSAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPHRyYWNrIGtpbmQ9XCJjYXB0aW9uc1wiIHNyYz17Y2FwdGlvbnN9IC8+XG4gICAgICAgIDwvdmlkZW8+XG4gICAgICAgIHsvKiBOZWVkIHRvIHVzZSBmdWxsIHBhdGggZm9yIHRoZXNlIHByb3BzIHNvIEZsb3cgY2FuIGluZmVyIGNvcnJlY3Qgc3VidHlwZSAqL31cbiAgICAgICAge3RoaXMucHJvcHMuY29udHJvbHMgJiYgKFxuICAgICAgICAgIDxWaWRlb0NvbnRyb2xzXG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlQbGF5TGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsfVxuICAgICAgICAgICAgY3VycmVudFRpbWU9e2N1cnJlbnRUaW1lfVxuICAgICAgICAgICAgZHVyYXRpb249e2R1cmF0aW9ufVxuICAgICAgICAgICAgZnVsbHNjcmVlbj17ZnVsbHNjcmVlbn1cbiAgICAgICAgICAgIG9uUGxheT17dGhpcy5oYW5kbGVQbGF5fVxuICAgICAgICAgICAgb25QYXVzZT17dGhpcy5oYW5kbGVQYXVzZX1cbiAgICAgICAgICAgIG9uRnVsbHNjcmVlbkNoYW5nZT17dGhpcy50b2dnbGVGdWxsc2NyZWVufVxuICAgICAgICAgICAgb25Wb2x1bWVDaGFuZ2U9e3RoaXMuaGFuZGxlVm9sdW1lQ2hhbmdlfVxuICAgICAgICAgICAgcGxheWluZz17cGxheWluZ31cbiAgICAgICAgICAgIHNlZWs9e3RoaXMuc2Vla31cbiAgICAgICAgICAgIHZvbHVtZT17dm9sdW1lfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiaWRlbnRpdHkiLCJTZXQiLCJmcm9tQ2xhc3NOYW1lIiwiY2xhc3NOYW1lcyIsImZyb21JbmxpbmVTdHlsZSIsImlubGluZVN0eWxlIiwiY29uY2F0Iiwic3R5bGVzIiwicmVkdWNlIiwiY2xhc3NOYW1lQSIsImNsYXNzTmFtZSIsImlubGluZVN0eWxlQSIsImNsYXNzTmFtZUIiLCJpbmxpbmVTdHlsZUIiLCJtYXBDbGFzc05hbWUiLCJmbiIsIkFycmF5IiwiZnJvbSIsIm1hcCIsInRvUHJvcHMiLCJwcm9wcyIsInNpemUiLCJzb3J0Iiwiam9pbiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzdHlsZSIsInRvZ2dsZSIsInZhbCIsIm1hcHBpbmciLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyYW5nZSIsInNjYWxlIiwibiIsIk1hdGgiLCJhYnMiLCJyYW5nZVdpdGhvdXRaZXJvIiwiYmluZCIsInNjb3BlIiwibmFtZSIsInVuaW9uIiwiZm5zIiwibWFyZ2luU3RhcnQiLCJ3aGl0ZXNwYWNlIiwibWFyZ2luRW5kIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luIiwic21NYXJnaW5Ub3AiLCJzbU1hcmdpblJpZ2h0Iiwic21NYXJnaW5Cb3R0b20iLCJzbU1hcmdpbkxlZnQiLCJzbU1hcmdpbiIsIm1kTWFyZ2luVG9wIiwibWRNYXJnaW5SaWdodCIsIm1kTWFyZ2luQm90dG9tIiwibWRNYXJnaW5MZWZ0IiwibWRNYXJnaW4iLCJsZ01hcmdpblRvcCIsImxnTWFyZ2luUmlnaHQiLCJsZ01hcmdpbkJvdHRvbSIsImxnTWFyZ2luTGVmdCIsImxnTWFyZ2luIiwicGFkZGluZ1giLCJwYWRkaW5nWSIsInBhZGRpbmciLCJzbVBhZGRpbmdYIiwic21QYWRkaW5nWSIsInNtUGFkZGluZyIsIm1kUGFkZGluZ1giLCJtZFBhZGRpbmdZIiwibWRQYWRkaW5nIiwibGdQYWRkaW5nWCIsImxnUGFkZGluZ1kiLCJsZ1BhZGRpbmciLCJwcmVmaXgiLCJwcmUiLCJkaXNwbGF5IiwidmFsdWUiLCJjb2x1bW4iLCJmb3JtYXRJbnRCb2ludCIsIngiLCJ0b1N0cmluZyIsInByb3BUb0ZuIiwiYyIsInhzRGlzcGxheU5vbmUiLCJ4c0Rpc3BsYXlGbGV4IiwieHNEaXNwbGF5QmxvY2siLCJ4c0Rpc3BsYXlJbmxpbmVCbG9jayIsInhzRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwieHNEaXJlY3Rpb25Sb3ciLCJ4c0RpcmVjdGlvbkNvbHVtbiIsInNtRGlzcGxheU5vbmUiLCJzbURpc3BsYXlGbGV4Iiwic21EaXNwbGF5QmxvY2siLCJzbURpc3BsYXlJbmxpbmVCbG9jayIsInNtRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwic21EaXJlY3Rpb25Sb3ciLCJzbURpcmVjdGlvbkNvbHVtbiIsIm1kRGlzcGxheU5vbmUiLCJtZERpc3BsYXlGbGV4IiwibWREaXNwbGF5QmxvY2siLCJtZERpc3BsYXlJbmxpbmVCbG9jayIsIm1kRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwibWREaXJlY3Rpb25Sb3ciLCJtZERpcmVjdGlvbkNvbHVtbiIsImxnRGlzcGxheU5vbmUiLCJsZ0Rpc3BsYXlGbGV4IiwibGdEaXNwbGF5QmxvY2siLCJsZ0Rpc3BsYXlJbmxpbmVCbG9jayIsImxnRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwibGdEaXJlY3Rpb25Sb3ciLCJsZ0RpcmVjdGlvbkNvbHVtbiIsImxheW91dCIsImNvbnRlbnRTdGFydCIsImNvbnRlbnRFbmQiLCJjb250ZW50Q2VudGVyIiwiY29udGVudEJldHdlZW4iLCJjb250ZW50QXJvdW5kIiwiaXRlbXNTdGFydCIsIml0ZW1zRW5kIiwiaXRlbXNDZW50ZXIiLCJpdGVtc0Jhc2VsaW5lIiwic2VsZlN0YXJ0Iiwic2VsZkVuZCIsInNlbGZDZW50ZXIiLCJzZWxmQmFzZWxpbmUiLCJzZWxmU3RyZXRjaCIsImJvdHRvbTAiLCJjb2xvcnMiLCJibHVlQmciLCJkYXJrR3JheUJnIiwicGluZUJnIiwiZ3JheUJnIiwicmVkQmciLCJvbGl2ZUJnIiwibGlnaHRHcmF5QmciLCJ3aGl0ZUJnIiwib3JhbmdlQmciLCJncmVlbkJnIiwibmF2eUJnIiwibWlkbmlnaHRCZyIsInB1cnBsZUJnIiwib3JjaGlkQmciLCJlZ2dwbGFudEJnIiwibWFyb29uQmciLCJ3YXRlcm1lbG9uQmciLCJsaWdodFdhc2hCZyIsImRhcmtXYXNoQmciLCJmaXQiLCJmbGV4R3JvdyIsImZsZXhOb25lIiwiaGVpZ2h0IiwianVzdGlmeUVuZCIsImp1c3RpZnlDZW50ZXIiLCJqdXN0aWZ5QmV0d2VlbiIsImp1c3RpZnlBcm91bmQiLCJsZWZ0MCIsIm10IiwibWIiLCJtbCIsIm1yIiwid2hpdGVzcGFjZUxlZ2FjeSIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJtbEF1dG8iLCJyaWdodCIsIm1yQXV0byIsIm1heEhlaWdodCIsIm1heFdpZHRoIiwibWluSGVpZ2h0IiwibWluV2lkdGgiLCJvdmVyZmxvd0hpZGRlbiIsIm92ZXJmbG93U2Nyb2xsIiwib3ZlcmZsb3dBdXRvIiwib3ZlcmZsb3dTY3JvbGxYIiwib3ZlcmZsb3dTY3JvbGxZIiwieSIsImFic29sdXRlIiwicmVsYXRpdmUiLCJmaXhlZCIsInJpZ2h0MCIsImJvcmRlcnMiLCJjaXJjbGUiLCJwaWxsIiwicm91bmRlZCIsInJvdW5kZWRCb3R0b20iLCJyb3VuZGVkTGVmdCIsInJvdW5kZWRSaWdodCIsInJvdW5kZWRUb3AiLCJ0b3AwIiwid2lkdGgiLCJmbGV4V3JhcCIsIl9fc3R5bGUiLCJjb250YWlucyIsImtleSIsImFyciIsImluZGV4T2YiLCJvbWl0Iiwib2JqIiwiYWNjIiwiayIsIkJveCIsImNoaWxkcmVuIiwiYmxhY2tsaXN0IiwicyIsImJveCIsInByb3AiLCJSZWFjdC5jcmVhdGVFbGVtZW50IiwiQ29sdW1uUHJvcFR5cGUiLCJQcm9wVHlwZXMiLCJvbmVPZiIsIk1hcmdpblByb3BUeXBlIiwiUGFkZGluZ1Byb3BUeXBlIiwicHJvcFR5cGVzIiwibm9kZSIsImV4YWN0Iiwib2JqZWN0Iiwib25lT2ZUeXBlIiwiYm9vbCIsIm51bWJlciIsInNoYXBlIiwic3RyaW5nIiwiYWRkQ2lyY2xlIiwiYWRkUGluIiwiYW5nbGVkUGluIiwiYXJyb3dCYWNrIiwiYXJyb3dDaXJjbGVEb3duIiwiYXJyb3dDaXJjbGVGb3J3YXJkIiwiYXJyb3dEb3duIiwiYXJyb3dGb3J3YXJkIiwiYXJyb3dVcCIsImFycm93VXBSaWdodCIsImNoZWNrQ2lyY2xlIiwiY2lyY2xlT3V0bGluZSIsImVsbGlwc2lzQ2lyY2xlT3V0bGluZSIsImZhY2VIYXBweSIsImZhY2VTYWQiLCJmYWNlU21pbGV5IiwiZ2xvYmVDaGVja2VkIiwiZ29vZ2xlUGx1cyIsImdyYXBoQmFyIiwiaGFuZFBvaW50aW5nIiwiaGVhcnRCcm9rZW4iLCJwZXJzb25BZGQiLCJwaW5IaWRlIiwicXVlc3Rpb25NYXJrIiwic2hvcHBpbmdCYWciLCJzbWlsZXlPdXRsaW5lIiwic3BlZWNoRWxsaXBzaXMiLCJ2aWV3VHlwZURlZmF1bHQiLCJ2aWV3VHlwZURlbnNlIiwidmlld1R5cGVMaXN0IiwiSWNvbk5hbWVzIiwiaWNvbnMiLCJJY29uIiwiYWNjZXNzaWJpbGl0eUxhYmVsIiwiY29sb3IiLCJpY29uIiwiaW5saW5lIiwiZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoIiwiY3MiLCJjbGFzc25hbWVzIiwiaWNvbkJsb2NrIiwicGF0aCIsIl9fcGF0aCIsInVuZGVmaW5lZCIsImFyaWFIaWRkZW4iLCJpc1JlcXVpcmVkIiwic2hvdWxkU2NhbGVJbWFnZSIsIkltYWdlIiwiaGFuZGxlTG9hZCIsIm9uTG9hZCIsImhhbmRsZUVycm9yIiwib25FcnJvciIsImxvYWRJbWFnZSIsInByZXZQcm9wcyIsInNyYyIsIndpbmRvdyIsImltYWdlIiwib25sb2FkIiwib25lcnJvciIsImFsdCIsIm5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsV2lkdGgiLCJzaXplcyIsInNyY1NldCIsImlzU2NhbGVkSW1hZ2UiLCJjaGlsZENvbnRlbnQiLCJpbWciLCJSZWFjdCIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJNYXNrIiwid2FzaCIsImN4IiwiU3F1YXJlIiwicGFkZGluZ0JvdHRvbSIsIkRlZmF1bHRBdmF0YXIiLCJmaXJzdEluaXRpYWwiLCJ0b1VwcGVyQ2FzZSIsInR5cG9ncmFwaHkiLCJhbnRpYWxpYXNlZCIsInNhbnNTZXJpZiIsImxlYWRpbmdTbWFsbCIsImZvbnRXZWlnaHRCb2xkIiwiQXZhdGFyIiwic3RhdGUiLCJoYW5kbGVJbWFnZUVycm9yIiwic2V0U3RhdGUiLCJpc0ltYWdlTG9hZGVkIiwib3V0bGluZSIsInZlcmlmaWVkIiwiU0laRV9TQ0FMRSIsIlRleHQiLCJhbGlnbiIsImJvbGQiLCJpdGFsaWMiLCJvdmVyZmxvdyIsInNtU2l6ZSIsIm1kU2l6ZSIsImxnU2l6ZSIsImxlYWRpbmciLCJ0cnVuY2F0ZSIsIl9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQiLCJzbVNjYWxlIiwibWRTY2FsZSIsImxnU2NhbGUiLCJibHVlIiwiZGFya0dyYXkiLCJlZ2dwbGFudCIsImdyYXkiLCJncmVlbiIsImxpZ2h0R3JheSIsIm1hcm9vbiIsIm1pZG5pZ2h0IiwibmF2eSIsIm9saXZlIiwib3JhbmdlIiwib3JjaGlkIiwicGluZSIsInB1cnBsZSIsInJlZCIsIndhdGVybWVsb24iLCJ3aGl0ZSIsImxlYWRpbmdTaG9ydCIsImxlYWRpbmdUYWxsIiwiYWxpZ25DZW50ZXIiLCJhbGlnbkp1c3RpZnkiLCJhbGlnbkxlZnQiLCJhbGlnblJpZ2h0IiwiYnJlYWtXb3JkIiwiZm9udFN0eWxlSXRhbGljIiwiZm9udFN0eWxlTm9ybWFsIiwiZm9udFdlaWdodE5vcm1hbCIsIlRhZyIsInRpdGxlIiwiQnV0dG9uIiwiYWNjZXNzaWJpbGl0eUV4cGFuZGVkIiwiYWNjZXNzaWJpbGl0eUhhc3BvcHVwIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwidGV4dCIsInR5cGUiLCJ0ZXh0Q29sb3IiLCJjbGFzc2VzIiwiYnV0dG9uIiwic20iLCJtZCIsImxnIiwic29saWQiLCJlbmFibGVkIiwiYmxvY2siLCJldmVudCIsIkNhcmQiLCJoYW5kbGVNb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwiaG92ZXJlZCIsImhhbmRsZU1vdXNlTGVhdmUiLCJvbk1vdXNlTGVhdmUiLCJhY3RpdmUiLCJjYXJkIiwiaG92ZXIiLCJDaGVja2JveCIsImhhbmRsZUNoYW5nZSIsImNoZWNrZWQiLCJ0YXJnZXQiLCJvbkNoYW5nZSIsImhhbmRsZUJsdXIiLCJmb2N1c2VkIiwiaGFuZGxlRm9jdXMiLCJpbmRldGVybWluYXRlIiwic2V0SW5kZXRlcm1pbmF0ZSIsInByZXZpb3VzUHJvcHMiLCJpbnB1dCIsImhhc0Vycm9yIiwiaWQiLCJib3JkZXJTdHlsZSIsImJvcmRlciIsImJvcmRlckRhcmsiLCJib3JkZXJFcnJvciIsImlucHV0RW5hYmxlZCIsImlucHV0U20iLCJpbnB1dE1kIiwiZWwiLCJjaGVjayIsImNoZWNrRW5hYmxlZCIsImNoZWNrRm9jdXNlZCIsImNoZWNrTWQiLCJjaGVja1NtIiwiQ29sbGVjdGlvbiIsIkl0ZW0iLCJ2aWV3cG9ydFRvcCIsInZpZXdwb3J0TGVmdCIsIm1heCIsIml0ZW0iLCJ2aWV3cG9ydFdpZHRoIiwidmlld3BvcnRIZWlnaHQiLCJpdGVtcyIsInBvc2l0aW9uIiwiaWR4IiwicHVzaCIsImxheW91dFN0eWxlcyIsImFueSIsImFycmF5T2YiLCJVUCIsIkRPV04iLCJNSUQiLCJjb2x1bW5MYXlvdXQiLCJudW1PZkNvbHVtbnMiLCJwYWRkaW5nQWxsIiwiZ3V0dGVyIiwicG9zaXRpb25zIiwibWluZGV4IiwibWluSW5kZXgiLCJpIiwiY29sdW1uc0ZvckNvbGxhZ2VXaXRoQ292ZXIiLCJnZXRDb2xsYWdlTGF5b3V0IiwiY292ZXIiLCJudW1Db2xzIiwiY29sdW1ucyIsImgiLCJ3IiwibGF5b3V0S2V5IiwiZ3JpZENvbHMiLCJsYXlvdXRJZHgiLCJjb2xIZWlnaHRzIiwiZmlsbCIsImNvbENvdW50cyIsImNvbCIsImNvbElkeCIsIml0ZW1IZWlnaHQiLCJjb3ZlckltYWdlV2lkdGgiLCJjZWlsIiwidW5zaGlmdCIsIkNvbGxhZ2UiLCJyZW5kZXJJbWFnZSIsImluZGV4IiwiQ29sdW1uIiwieHMiLCJkZXByZWNhdGVkQ29sdW1uIiwic3BhbiIsInNtU3BhbiIsIm1kU3BhbiIsImxnU3BhbiIsIkNvbnRhaW5lciIsIkRpdmlkZXIiLCJkaXZpZGVyIiwiQ2FyZXQiLCJkaXJlY3Rpb24iLCJTUEFDRVNfSU5ERVhfTUFQIiwiRElSX0lOREVYX01BUCIsIk1BUkdJTiIsIkNBUkVUX0hFSUdIVCIsIkNBUkVUX09GRlNFVF9GUk9NX1NJREUiLCJCT1JERVJfUkFESVVTIiwiZ2V0TWFpbkRpciIsImZseW91dFNpemUiLCJpZGVhbERpcmVjdGlvbiIsInRyaWdnZXJSZWN0Iiwid2luZG93U2l6ZSIsInVwIiwiZG93biIsInNwYWNlcyIsIm1haW5EaXIiLCJnZXRTdWJEaXIiLCJvZmZzZXQiLCJ0cmlnZ2VyTWlkIiwid2luZG93U3BhY2VBdmFpbGFibGUiLCJhYm92ZU9yTGVmdCIsImJlbG93T3JSaWdodCIsInN1YkRpciIsImNhbGNFZGdlU2hpZnRzIiwiZmx5b3V0VmVydGljYWxTaGlmdCIsImZseW91dEhvcml6b250YWxTaGlmdCIsImNhcmV0VmVydGljYWxTaGlmdCIsImNhcmV0SG9yaXpvbnRhbFNoaWZ0IiwiaXNDbG9zZVZlcnRpY2FsbHkiLCJpc0Nsb3NlSG9yaXpvbnRhbGx5IiwiYWRqdXN0T2Zmc2V0cyIsImJhc2UiLCJlZGdlU2hpZnQiLCJmbHlvdXRMZWZ0IiwiZmx5b3V0VG9wIiwiY2FyZXRUb3AiLCJjYXJldFJpZ2h0IiwiY2FyZXRCb3R0b20iLCJjYXJldExlZnQiLCJmbHlvdXQiLCJjYXJldCIsImJhc2VPZmZzZXRzIiwicmVsYXRpdmVPZmZzZXQiLCJIQUxGX0NBUkVUIiwic2Nyb2xsWSIsInNjcm9sbFgiLCJDb250ZW50cyIsInNldEZseW91dFBvc2l0aW9uIiwicG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yIiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsImNsaWVudEhlaWdodCIsImVkZ2VTaGlmdHMiLCJmbHlvdXRPZmZzZXQiLCJjYXJldE9mZnNldCIsInNob3VsZEZvY3VzIiwiZm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwib25SZXNpemUiLCJvbktleURvd24iLCJuZXh0UHJvcHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYmdDb2xvciIsInZpc2liaWxpdHkiLCJiYWNrZ3JvdW5kIiwic3Ryb2tlIiwiYm9yZGVyQ29sb3IiLCJjb250YWluZXIiLCJkaW1lbnNpb25zIiwiY29udGVudHMiLCJpbm5lckNvbnRlbnRzIiwiT3V0c2lkZUV2ZW50QmVoYXZpb3IiLCJoYW5kbGVDbGlja0V2ZW50IiwiZmluZERPTU5vZGUiLCJOb2RlIiwiU0laRV9XSURUSF9NQVAiLCJFU0NBUEVfS0VZX0NPREUiLCJDb250cm9sbGVyIiwiaGFuZGxlS2V5RG93biIsImtleUNvZGUiLCJvbkRpc21pc3MiLCJoYW5kbGVQYWdlQ2xpY2siLCJhbmNob3IiLCJoYW5kbGVSZXNpemUiLCJ1cGRhdGVUcmlnZ2VyUmVjdCIsInRyaWdnZXJCb3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiRmx5b3V0IiwiemlwIiwiYSIsImIiLCJCT1JERVJfV0lEVEgiLCJBVkFUQVJfU0laRVMiLCJhdmF0YXJMYXlvdXQiLCJ0ZXh0TGF5b3V0IiwiZGVnVG9SYWQiLCJkZWciLCJQSSIsInF1YXJ0ZXJQYWRkaW5nIiwic2luIiwiaW5pdGlhbCIsIkdyb3VwQXZhdGFyIiwiY29sbGFib3JhdG9ycyIsImF2YXRhcldpZHRoIiwiYXZhdGFySGVpZ2h0IiwiYm94U2hhZG93IiwiY29sbGFib3JhdG9yIiwiZGVmYXVsdEhlYWRpbmdMZXZlbHMiLCJIZWFkaW5nIiwiYWNjZXNzaWJpbGl0eUxldmVsIiwiaGVhZGluZ0xldmVsIiwiU0laRV9OQU1FX1RPX1BJWEVMIiwiZGVmYXVsdEljb25CdXR0b25JY29uQ29sb3JzIiwiUG9nIiwiaWNvbkNvbG9yIiwiaWNvblNpemUiLCJwb2ciLCJJY29uQnV0dG9uIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlTW91c2VVcCIsIkxhYmVsIiwiaHRtbEZvciIsImxhYmVsIiwiTGF5ZXIiLCJjcmVhdGVFbGVtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVQb3J0YWwiLCJhc3BlY3RSYXRpbyIsIkxldHRlcmJveCIsImNvbnRlbnRBc3BlY3RSYXRpbyIsInZpZXdwb3J0QXNwZWN0UmF0aW8iLCJjb250ZW50SGVpZ2h0IiwiY29udGVudFdpZHRoIiwiVEFCX0tFWV9DT0RFIiwiTGluayIsImhhbmRsZUNsaWNrIiwiaHJlZiIsImVuYWJsZUZvY3VzU3R5bGVzIiwiaGFuZGxlS2V5VXAiLCJyZWwiLCJsaW5rVGFyZ2V0IiwibGluayIsImFjY2Vzc2libGVGb2N1c1N0eWxlIiwiRmV0Y2hJdGVtcyIsImNvbnRhaW5lckhlaWdodCIsImlzQXRFbmQiLCJpc0ZldGNoaW5nIiwiZmV0Y2hNb3JlIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsQnVmZmVyIiwiTWVhc3VyZW1lbnRTdG9yZSIsIldlYWtNYXAiLCJnZXQiLCJoYXMiLCJzZXQiLCJkZWJvdW5jZSIsInRocmVzaGhvbGQiLCJkZWZlclRpbWVyIiwiZGVib3VuY2VkIiwiYXJncyIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRTY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXIiLCJTY3JvbGxDb250YWluZXIiLCJnZXRTY3JvbGxDb250YWluZXJSZWYiLCJoYW5kbGVTY3JvbGwiLCJvblNjcm9sbCIsInVwZGF0ZVNjcm9sbENvbnRhaW5lciIsIm5leHRTY3JvbGxDb250YWluZXIiLCJvbmx5IiwidGhyb3R0bGUiLCJsYXN0IiwidGhyb3R0bGVkIiwibm93IiwiRGF0ZSIsImdldEVsZW1lbnRIZWlnaHQiLCJlbGVtZW50IiwiZ2V0V2luZG93U2Nyb2xsUG9zIiwiZ2V0UmVsYXRpdmVTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRTY3JvbGxQb3MiLCJEZWZhdWx0TGF5b3V0U3ltYm9sIiwiU3ltYm9sIiwiVW5pZm9ybVJvd0xheW91dFN5bWJvbCIsIm9mZnNjcmVlbiIsIkluZmluaXR5IiwiY2FjaGUiLCJjb2x1bW5XaWR0aCIsIm1pbkNvbHMiLCJjb2x1bW5XaWR0aEFuZEd1dHRlciIsImNvbHVtbkNvdW50IiwiZmxvb3IiLCJoZWlnaHRzIiwiY2VudGVyT2Zmc2V0IiwiaGVpZ2h0QW5kR3V0dGVyIiwicm93Iiwic2xpY2UiLCJzdW0iLCJpZGVhbENvbHVtbldpZHRoIiwiY29sZ3Vlc3MiLCJNYXNvbnJ5TGF5b3V0IiwiVW5pZm9ybVJvd0xheW91dCIsIlJFU0laRV9ERUJPVU5DRSIsIlZJUlRVQUxfQlVGRkVSX0ZBQ1RPUiIsImxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uIiwibGF5b3V0Q2xhc3MiLCJmbGV4aWJsZSIsImd1dHRlcldpZHRoIiwibWVhc3VyZW1lbnRTdG9yZSIsImZ1bGxXaWR0aExheW91dCIsIkxlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQiLCJ1bmlmb3JtUm93TGF5b3V0IiwiZGVmYXVsdExheW91dCIsInN0YXRlc0ZvclJlbmRlcmluZyIsIml0ZW1zVG9SZW5kZXIiLCJmaWx0ZXIiLCJyZW5kZXJQb3NpdGlvbnMiLCJwb3MiLCJpdGVtc1RvTWVhc3VyZSIsIm1lYXN1cmluZ1Bvc2l0aW9ucyIsIk1hc29ucnkiLCJncmlkV3JhcHBlciIsImNsaWVudFdpZHRoIiwidXBkYXRlU2Nyb2xsUG9zaXRpb24iLCJoYW5kbGVWaXJ0dWFsaXphdGlvbldpbmRvd1VwZGF0ZSIsIm1lYXN1cmVDb250YWluZXJBc3luYyIsIm1lYXN1cmVDb250YWluZXIiLCJzZXRHcmlkV3JhcHBlclJlZiIsInJlZiIsInNldFNjcm9sbENvbnRhaW5lclJlZiIsIm9uVmlydHVhbGl6YXRpb25XaW5kb3dVcGRhdGUiLCJ2aWV3cG9ydCIsImNvbnRlbnQiLCJjb250YWluZXJPZmZzZXQiLCJoYW5kbGVPbkF1dG9NZWFzdXJpbmdVcGRhdGUiLCJvbkF1dG9NZWFzdXJpbmdVcGRhdGUiLCJyZW5kZXJNYXNvbnJ5Q29tcG9uZW50IiwiaXRlbURhdGEiLCJDb21wb25lbnQiLCJjb21wIiwidmlydHVhbGl6ZSIsInZpcnR1YWxCb3VuZHNUb3AiLCJ2aXJ0dWFsQm91bmRzQm90dG9tIiwiaXNWaXNpYmxlIiwidmlydHVhbEJ1ZmZlciIsIm9mZnNldFNjcm9sbFBvcyIsInZpZXdwb3J0Qm90dG9tIiwiaXRlbUNvbXBvbmVudCIsIk1hc29ucnlfX0l0ZW0iLCJNYXNvbnJ5X19JdGVtX19Nb3VudGVkIiwic29tZSIsInByZXZTdGF0ZSIsImhhc1BlbmRpbmdNZWFzdXJlbWVudHMiLCJyZXNldCIsImluc2VydEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyaW5nU3RhdGVzIiwic2Nyb2xsQ29udGFpbmVyUmVmIiwiSFRNTEVsZW1lbnQiLCJyZWxhdGl2ZVNjcm9sbFRvcCIsImZvcmNlVXBkYXRlIiwiZ3JpZEJvZHkiLCJkYXRhIiwibWVhc3VyZW1lbnRJbmRleCIsImluc3RhbmNlT2YiLCJMZWdhY3lNYXNvbnJ5TGF5b3V0Iiwic3ltYm9sIiwiTWFzb25yeUluZmluaXRlIiwic2V0UmVmIiwiZ3JpZFJlZiIsImxvYWRJdGVtcyIsInJlZmxvdyIsIk5vU2Nyb2xsQmVoYXZpb3IiLCJwcmV2T3ZlcmZsb3ciLCJxdWVyeUZvY3VzYWJsZUFsbCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImZvY3VzRWxlbWVudCIsIlRyYXBGb2N1c0JlaGF2aW9yIiwic2V0RWxSZWYiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImZvY3VzRmlyc3RDaGlsZCIsInByZXZpb3VzbHlGb2N1c2VkRWwiLCJhY3RpdmVFbGVtZW50IiwiQmFja2Ryb3AiLCJNb2RhbCIsImhhbmRsZU91dHNpZGVDbGljayIsImhhbmRsZUNsb3NlQ2xpY2siLCJhY2Nlc3NpYmlsaXR5Q2xvc2VMYWJlbCIsImFjY2Vzc2liaWxpdHlNb2RhbExhYmVsIiwiZm9vdGVyIiwiaGVhZGluZyIsInJvbGUiLCJ3cmFwcGVyIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJQdWxzYXIiLCJwYXVzZWQiLCJpbm5lckNpcmNsZSIsIm91dGVyQ2lyY2xlIiwiUmFkaW9CdXR0b24iLCJSYWRpb0J1dHRvbklzRm9jdXNlZCIsIlJhZGlvQnV0dG9uU20iLCJSYWRpb0J1dHRvbk1kIiwiUmFkaW9CdXR0b25XaGl0ZUJnIiwiUmFkaW9CdXR0b25MaWdodEdyYXlCZyIsIklucHV0IiwiSW5wdXRFbmFibGVkIiwiSW5wdXRTbSIsIklucHV0TWQiLCJDaGVjayIsIkNoZWNrU20iLCJDaGVja01kIiwiQ2hlY2tFbmFibGVkIiwiQ2hlY2tEaXNhYmxlZCIsIlNjcm9sbEZldGNoIiwidXBkYXRlUG9zaXRpb24iLCJnZXRTY3JvbGxTdGF0ZSIsInJlbmRlckhlaWdodCIsIlNlYXJjaEZpZWxkIiwiY3VycmVudFRhcmdldCIsImhhbmRsZUNsZWFyIiwib25Gb2N1cyIsIm9uQmx1ciIsInBsYWNlaG9sZGVyIiwic2hvd0NsZWFyIiwiY2xlYXIiLCJTZWdtZW50ZWRDb250cm9sIiwic2VsZWN0ZWRJdGVtSW5kZXgiLCJpc1NlbGVjdGVkIiwiaXRlbUlzTm90U2VsZWN0ZWQiLCJpdGVtSXNTZWxlY3RlZCIsImUiLCJhY3RpdmVJbmRleCIsIlNlbGVjdExpc3QiLCJoYW5kbGVPbkNoYW5nZSIsIkhUTUxTZWxlY3RFbGVtZW50IiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JJc09wZW4iLCJpZGVhbEVycm9yRGlyZWN0aW9uIiwib3B0aW9ucyIsInNlbGVjdCIsImVycm9yZWQiLCJub3JtYWwiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nVG9wIiwib3B0aW9uIiwiU0laRSIsIlNwaW5uZXIiLCJzaG93IiwiU3RpY2t5IiwiZGFuZ2Vyb3VzbHlTZXRaSW5kZXgiLCJfX3pJbmRleCIsInN0aWNreSIsIlN3aXRjaCIsInN3aXRjaGVkIiwic3dpdGNoU3R5bGVzIiwic3dpdGNoIiwic3dpdGNoR3JheSIsInN3aXRjaExpZ2h0R3JheSIsInN3aXRjaERhcmtHcmF5Iiwic3dpdGNoV2hpdGUiLCJzbGlkZXJTdHlsZXMiLCJzbGlkZXIiLCJzbGlkZXJSaWdodCIsInNsaWRlckxlZnQiLCJzbGlkZXJEYXJrIiwic2xpZGVyTGlnaHQiLCJpbnB1dFN0eWxlcyIsImNoZWNrYm94IiwiY2hlY2tib3hFbmFibGVkIiwiVGFicyIsImhhbmRsZVRhYkNsaWNrIiwiYWN0aXZlVGFiSW5kZXgiLCJoYW5kbGVUYWJGb2N1cyIsImZvY3VzZWRUYWJJbmRleCIsImhhbmRsZVRhYkJsdXIiLCJoYW5kbGVUYWJNb3VzZUVudGVyIiwiaG92ZXJlZFRhYkluZGV4IiwiaGFuZGxlVGFiTW91c2VMZWF2ZSIsInRhYnMiLCJpc0FjdGl2ZSIsImlzSG92ZXJlZCIsImlzRm9jdXNlZCIsInRhYiIsInRhYklzTm90QWN0aXZlIiwidGFiSXNBY3RpdmUiLCJUZXh0QXJlYSIsInJvd3MiLCJ0ZXh0QXJlYSIsInRleHRhcmVhIiwiVGV4dEZpZWxkIiwiYXV0b0NvbXBsZXRlIiwidGV4dEZpZWxkIiwicGF0dGVybiIsInRleHRmaWVsZCIsIlRvYXN0IiwidGh1bWJuYWlsIiwiZm9udFdlaWdodCIsIlRvb2x0aXAiLCJTUEFDRV9DSEFSX0NPREUiLCJFTlRFUl9DSEFSX0NPREUiLCJUb3VjaGFibGUiLCJoYW5kbGVLZXlQcmVzcyIsIm9uVG91Y2giLCJjaGFyQ29kZSIsImZ1bGxXaWR0aCIsImZ1bGxIZWlnaHQiLCJtb3VzZUN1cnNvciIsInRvdWNoYWJsZSIsIlZpZGVvUGxheWhlYWQiLCJzZXRQbGF5aGVhZFJlZiIsInBsYXloZWFkIiwic2VlayIsImNsaWVudFgiLCJkdXJhdGlvbiIsInBlcmNlbnQiLCJtaW4iLCJuZXdUaW1lIiwic3RvcENsaWNrIiwic2Vla2luZyIsImhhbmRsZU1vdXNlTW92ZSIsImN1cnJlbnRUaW1lIiwiZnVsbHNjcmVlbkVuYWJsZWQiLCJ3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCIsIm1vekZ1bGxTY3JlZW5FbmFibGVkIiwibXNGdWxsc2NyZWVuRW5hYmxlZCIsInRpbWVUb1N0cmluZyIsInRpbWUiLCJtaW51dGVzIiwic2Vjb25kcyIsIm1pbnV0ZXNTdHIiLCJzZWNvbmRzU3RyIiwiVmlkZW9Db250cm9scyIsImhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UiLCJvbkZ1bGxzY3JlZW5DaGFuZ2UiLCJoYW5kbGVQbGF5aW5nQ2hhbmdlIiwicGxheWluZyIsIm9uUGF1c2UiLCJvblBsYXkiLCJoYW5kbGVWb2x1bWVDaGFuZ2UiLCJvblZvbHVtZUNoYW5nZSIsImFjY2Vzc2liaWxpdHlNYXhpbWl6ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWwiLCJhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWwiLCJhY2Nlc3NpYmlsaXR5UGxheUxhYmVsIiwiYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsIiwiZnVsbHNjcmVlbiIsInZvbHVtZSIsIm11dGVkIiwic2hvd0Z1bGxzY3JlZW5CdXR0b24iLCJjb250cm9scyIsInJlcXVlc3RGdWxsc2NyZWVuIiwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4iLCJtb3pSZXF1ZXN0RnVsbFNjcmVlbiIsIm1zUmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsIndlYmtpdEV4aXRGdWxsc2NyZWVuIiwibW96Q2FuY2VsRnVsbFNjcmVlbiIsIm1zRXhpdEZ1bGxzY3JlZW4iLCJpc0Z1bGxzY3JlZW4iLCJmdWxsc2NyZWVuRWxlbWVudCIsIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IiwibW96RnVsbFNjcmVlbkVsZW1lbnQiLCJtc0Z1bGxzY3JlZW5FbGVtZW50IiwiYWRkRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsInJlbW92ZUZ1bGxzY3JlZW5FdmVudExpc3RlbmVyIiwiaXNOZXdTb3VyY2UiLCJvbGRTb3VyY2UiLCJuZXdTb3VyY2UiLCJpc0FycmF5Iiwic291cmNlIiwiVmlkZW8iLCJzZXRQbGF5ZXJSZWYiLCJwbGF5ZXIiLCJzZXRWaWRlb1JlZiIsInZpZGVvIiwic2V0UGxheWJhY2tSYXRlIiwicGxheWJhY2tSYXRlIiwic2V0Vm9sdW1lIiwibG9hZCIsInBhdXNlIiwicGxheSIsInRvZ2dsZUZ1bGxzY3JlZW4iLCJoYW5kbGVDYW5QbGF5Iiwib25SZWFkeSIsImhhbmRsZUR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZSIsImhhbmRsZUVuZGVkIiwib25FbmRlZCIsImhhbmRsZVBsYXkiLCJoYW5kbGVQYXVzZSIsImhhbmRsZVByb2dyZXNzIiwib25Mb2FkZWRDaGFuZ2UiLCJidWZmZXJlZCIsImxvYWRlZCIsImVuZCIsImhhbmRsZVNlZWsiLCJvblNlZWsiLCJoYW5kbGVUaW1lVXBkYXRlIiwib25UaW1lQ2hhbmdlIiwiY2FwdGlvbnMiLCJsb29wIiwicGxheXNJbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEFBQU8sSUFBTUEsV0FBVyxTQUFYQSxRQUFXO1NBQWM7ZUFDekIsSUFBSUMsR0FBSixFQUR5QjtpQkFFdkI7R0FGUztDQUFqQjs7Ozs7O0FBS1AsQUFBTyxJQUFNQyxnQkFBZ0IsU0FBaEJBLGFBQWdCO29DQUFJQyxVQUFKO2NBQUE7OztTQUEwQztlQUMxRCxJQUFJRixHQUFKLENBQVFFLFVBQVIsQ0FEMEQ7aUJBRXhEO0dBRmM7Q0FBdEI7O0FBS1AsQUFBTyxJQUFNQyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQUNDLFdBQUQ7U0FBc0M7ZUFDeEQsSUFBSUosR0FBSixFQUR3RDs7R0FBdEM7Q0FBeEI7O0FBS1AsQUFBTyxJQUFNSyxTQUFTLFNBQVRBLE1BQVMsQ0FBQ0MsTUFBRDtTQUNwQkEsT0FBT0MsTUFBUCxDQUNFO1FBQ2VDLFVBRGYsUUFDSUMsU0FESjtRQUN3Q0MsWUFEeEMsUUFDMkJOLFdBRDNCO1FBRWVPLFVBRmYsU0FFSUYsU0FGSjtRQUV3Q0csWUFGeEMsU0FFMkJSLFdBRjNCO1dBR007aUJBQ08sSUFBSUosR0FBSiw2QkFBWVEsVUFBWixxQkFBMkJHLFVBQTNCLEdBRFA7Z0NBRWNELFlBQWxCLEVBQW1DRSxZQUFuQztLQUxGO0dBREYsRUFRRWIsVUFSRixDQURvQjtDQUFmOztBQVlQLEFBQU8sSUFBTWMsZUFBZSxTQUFmQSxZQUFlLENBQUNDLEVBQUQ7U0FBK0I7UUFDekRMLFNBRHlELFNBQ3pEQSxTQUR5RDtRQUV6REwsV0FGeUQsU0FFekRBLFdBRnlEO1dBR3RDO2lCQUNSLElBQUlKLEdBQUosQ0FBUWUsTUFBTUMsSUFBTixDQUFXUCxTQUFYLEVBQXNCUSxHQUF0QixDQUEwQkgsRUFBMUIsQ0FBUixDQURROztLQUhzQztHQUEvQjtDQUFyQjs7QUFRUCxBQUFPLElBQU1JLFVBQVUsU0FBVkEsT0FBVSxRQUdpQztNQUZ0RFQsU0FFc0QsU0FGdERBLFNBRXNEO01BRHRETCxXQUNzRCxTQUR0REEsV0FDc0Q7O01BQ2hEZSxRQUFRLEVBQWQ7O01BRUlWLFVBQVVXLElBQVYsR0FBaUIsQ0FBckIsRUFBd0I7Ozs7VUFJaEJYLFNBQU4sR0FBa0JNLE1BQU1DLElBQU4sQ0FBV1AsU0FBWCxFQUNmWSxJQURlLEdBRWZDLElBRmUsQ0FFVixHQUZVLENBQWxCOzs7TUFLRUMsT0FBT0MsSUFBUCxDQUFZcEIsV0FBWixFQUF5QnFCLE1BQXpCLEdBQWtDLENBQXRDLEVBQXlDO1VBQ2pDQyxLQUFOLEdBQWN0QixXQUFkOzs7U0FHS2UsS0FBUDtDQW5CSzs7QUNwRFA7Ozs7Ozs7Ozs7OztBQWNBLEFBQU8sSUFBTVEsU0FBUyxTQUFUQSxNQUFTO29DQUFJekIsVUFBSjtjQUFBOzs7U0FBa0MsVUFBQzBCLEdBQUQ7V0FDdERBLE1BQU0zQiwrQkFBaUJDLFVBQWpCLENBQU4sR0FBcUNILFVBRGlCO0dBQWxDO0NBQWY7Ozs7OztBQU9QLEFBQU8sSUFBTThCLFVBQVUsU0FBVkEsT0FBVSxDQUFDWixHQUFEO1NBQW9DLFVBQUNXLEdBQUQ7V0FDekRMLE9BQU9PLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ2YsR0FBckMsRUFBMENXLEdBQTFDLElBQ0kzQixjQUFjZ0IsSUFBSVcsR0FBSixDQUFkLENBREosR0FFSTdCLFVBSHFEO0dBQXBDO0NBQWhCOzs7Ozs7QUFTUCxBQUFPLElBQU1rQyxRQUFRLFNBQVJBLEtBQVEsQ0FBQ0MsS0FBRDtTQUFtQixVQUFDQyxDQUFEO1dBQ3RDbEMsbUJBQWlCaUMsS0FBakIsSUFBeUJDLElBQUksQ0FBSixTQUFZQyxLQUFLQyxHQUFMLENBQVNGLENBQVQsQ0FBWixHQUE0QkEsQ0FBckQsRUFEc0M7R0FBbkI7Q0FBZDs7Ozs7O0FBT1AsQUFBTyxJQUFNRyxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFDSixLQUFEO1NBQW1CLFVBQUNDLENBQUQ7V0FDakRBLE1BQU0sQ0FBTixHQUFVcEMsVUFBVixHQUF1QmtDLE1BQU1DLEtBQU4sRUFBYUMsQ0FBYixDQUQwQjtHQUFuQjtDQUF6Qjs7Ozs7QUFNUCxBQUFPLElBQU1JLE9BQU8sU0FBUEEsSUFBTyxDQUFDekIsRUFBRCxFQUFjMEIsS0FBZDtTQUFtRCxVQUNyRVosR0FEcUU7V0FFbEVmLGFBQWE7YUFBUTJCLE1BQU1DLElBQU4sQ0FBUjtLQUFiLEVBQWtDM0IsR0FBR2MsR0FBSCxDQUFsQyxDQUZrRTtHQUFuRDtDQUFiOzs7O0FBTVAsQUFBTyxJQUFNYyxRQUFRLFNBQVJBLEtBQVE7cUNBQUlDLEdBQUo7T0FBQTs7O1NBQTRCLFVBQUNmLEdBQUQ7V0FDL0N2QixPQUFPc0MsSUFBSTFCLEdBQUosQ0FBUTthQUFNSCxHQUFHYyxHQUFILENBQU47S0FBUixDQUFQLENBRCtDO0dBQTVCO0NBQWQ7O0FDakJQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBMQSxJQUFNZ0IsY0FBY0wsS0FBS0QsaUJBQWlCLGFBQWpCLENBQUwsRUFBc0NPLFVBQXRDLENBQXBCO0FBQ0EsSUFBTUMsWUFBWVAsS0FBS0QsaUJBQWlCLFdBQWpCLENBQUwsRUFBb0NPLFVBQXBDLENBQWxCO0FBQ0EsSUFBTUUsWUFBWVIsS0FBS0QsaUJBQWlCLFdBQWpCLENBQUwsRUFBb0NPLFVBQXBDLENBQWxCO0FBQ0EsSUFBTUcsY0FBY1QsS0FBS0QsaUJBQWlCLGFBQWpCLENBQUwsRUFBc0NPLFVBQXRDLENBQXBCO0FBQ0EsSUFBTUksZUFBZVYsS0FBS0QsaUJBQWlCLGNBQWpCLENBQUwsRUFBdUNPLFVBQXZDLENBQXJCO0FBQ0EsSUFBTUssYUFBYVgsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTU0sU0FBU1QsTUFBTUssU0FBTixFQUFpQkUsWUFBakIsRUFBK0JDLFVBQS9CLEVBQTJDRixXQUEzQyxDQUFmOztBQUVBLElBQU1JLGNBQWNiLEtBQUtELGlCQUFpQixhQUFqQixDQUFMLEVBQXNDTyxVQUF0QyxDQUFwQjtBQUNBLElBQU1RLGdCQUFnQmQsS0FBS0QsaUJBQWlCLGVBQWpCLENBQUwsRUFBd0NPLFVBQXhDLENBQXRCO0FBQ0EsSUFBTVMsaUJBQWlCZixLQUFLRCxpQkFBaUIsZ0JBQWpCLENBQUwsRUFBeUNPLFVBQXpDLENBQXZCO0FBQ0EsSUFBTVUsZUFBZWhCLEtBQUtELGlCQUFpQixjQUFqQixDQUFMLEVBQXVDTyxVQUF2QyxDQUFyQjtBQUNBLElBQU1XLFdBQVdkLE1BQ2ZVLFdBRGUsRUFFZkUsY0FGZSxFQUdmQyxZQUhlLEVBSWZGLGFBSmUsQ0FBakI7O0FBT0EsSUFBTUksY0FBY2xCLEtBQUtELGlCQUFpQixhQUFqQixDQUFMLEVBQXNDTyxVQUF0QyxDQUFwQjtBQUNBLElBQU1hLGdCQUFnQm5CLEtBQUtELGlCQUFpQixlQUFqQixDQUFMLEVBQXdDTyxVQUF4QyxDQUF0QjtBQUNBLElBQU1jLGlCQUFpQnBCLEtBQUtELGlCQUFpQixnQkFBakIsQ0FBTCxFQUF5Q08sVUFBekMsQ0FBdkI7QUFDQSxJQUFNZSxlQUFlckIsS0FBS0QsaUJBQWlCLGNBQWpCLENBQUwsRUFBdUNPLFVBQXZDLENBQXJCO0FBQ0EsSUFBTWdCLFdBQVduQixNQUNmZSxXQURlLEVBRWZFLGNBRmUsRUFHZkMsWUFIZSxFQUlmRixhQUplLENBQWpCOztBQU9BLElBQU1JLGNBQWN2QixLQUFLRCxpQkFBaUIsYUFBakIsQ0FBTCxFQUFzQ08sVUFBdEMsQ0FBcEI7QUFDQSxJQUFNa0IsZ0JBQWdCeEIsS0FBS0QsaUJBQWlCLGVBQWpCLENBQUwsRUFBd0NPLFVBQXhDLENBQXRCO0FBQ0EsSUFBTW1CLGlCQUFpQnpCLEtBQUtELGlCQUFpQixnQkFBakIsQ0FBTCxFQUF5Q08sVUFBekMsQ0FBdkI7QUFDQSxJQUFNb0IsZUFBZTFCLEtBQUtELGlCQUFpQixjQUFqQixDQUFMLEVBQXVDTyxVQUF2QyxDQUFyQjtBQUNBLElBQU1xQixXQUFXeEIsTUFDZm9CLFdBRGUsRUFFZkUsY0FGZSxFQUdmQyxZQUhlLEVBSWZGLGFBSmUsQ0FBakI7O0FBT0EsSUFBTUksV0FBVzVCLEtBQUtELGlCQUFpQixVQUFqQixDQUFMLEVBQW1DTyxVQUFuQyxDQUFqQjtBQUNBLElBQU11QixXQUFXN0IsS0FBS0QsaUJBQWlCLFVBQWpCLENBQUwsRUFBbUNPLFVBQW5DLENBQWpCO0FBQ0EsSUFBTXdCLFVBQVUzQixNQUFNeUIsUUFBTixFQUFnQkMsUUFBaEIsQ0FBaEI7O0FBRUEsSUFBTUUsYUFBYS9CLEtBQUtELGlCQUFpQixZQUFqQixDQUFMLEVBQXFDTyxVQUFyQyxDQUFuQjtBQUNBLElBQU0wQixhQUFhaEMsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTTJCLFlBQVk5QixNQUFNNEIsVUFBTixFQUFrQkMsVUFBbEIsQ0FBbEI7O0FBRUEsSUFBTUUsYUFBYWxDLEtBQUtELGlCQUFpQixZQUFqQixDQUFMLEVBQXFDTyxVQUFyQyxDQUFuQjtBQUNBLElBQU02QixhQUFhbkMsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTThCLFlBQVlqQyxNQUFNK0IsVUFBTixFQUFrQkMsVUFBbEIsQ0FBbEI7O0FBRUEsSUFBTUUsYUFBYXJDLEtBQUtELGlCQUFpQixZQUFqQixDQUFMLEVBQXFDTyxVQUFyQyxDQUFuQjtBQUNBLElBQU1nQyxhQUFhdEMsS0FBS0QsaUJBQWlCLFlBQWpCLENBQUwsRUFBcUNPLFVBQXJDLENBQW5CO0FBQ0EsSUFBTWlDLFlBQVlwQyxNQUFNa0MsVUFBTixFQUFrQkMsVUFBbEIsQ0FBbEI7Ozs7Ozs7O0FBUUEsSUFBTUUsU0FBUyxTQUFUQSxNQUFTLENBQUNDLEdBQUQ7U0FBaUJuRSxhQUFhO2dCQUFXbUUsR0FBWCxHQUFpQnZDLElBQWpCO0dBQWIsQ0FBakI7Q0FBZjtBQUNBLElBQU13QyxVQUFVLFNBQVZBLE9BQVUsUUFBUztVQUNmQyxLQUFSO1NBQ08sTUFBTDthQUNTakYsY0FBYyxhQUFkLEVBQTZCLGNBQTdCLENBQVA7U0FDRyxZQUFMO2FBQ1NBLGNBQWMsYUFBZCxFQUE2QixpQkFBN0IsQ0FBUDtTQUNHLGFBQUw7YUFDU0EsY0FBYyxvQkFBZCxDQUFQO1NBQ0csZ0JBQUw7YUFDU0EsY0FBYyx1QkFBZCxDQUFQO1NBQ0csS0FBTDthQUNTQSxjQUFjLGFBQWQsQ0FBUDs7O2FBR09BLGNBQWMsY0FBZCxDQUFQOztDQWROO0FBaUJBLElBQU1rRixTQUFTbEQsTUFBTSxLQUFOLENBQWY7O0FBRUEsSUFBTW1ELGlCQUFpQixTQUFqQkEsY0FBaUI7U0FBTUMsSUFBSSxDQUFKLFNBQVlqRCxLQUFLQyxHQUFMLENBQVNnRCxDQUFULENBQVosR0FBNEJBLEVBQUVDLFFBQUYsRUFBbEM7Q0FBdkI7Ozs7Ozs7O0FBUUEsSUFBTUMsV0FBVztNQUNYLG1CQUFTO1FBQ1AsQ0FBQ0wsS0FBTCxFQUFZO2FBQ0huRixVQUFQOztXQUVLYyxhQUFhO2FBQUtQLE9BQU9rRixDQUFQLENBQUw7S0FBYixFQUNMVCxPQUFPLElBQVAsRUFDRTFFLE9BQU8sQ0FDTDZFLE1BQU1DLE1BQU4sR0FBZUEsT0FBT0QsTUFBTUMsTUFBYixDQUFmLEdBQXNDcEYsVUFEakMsRUFFTCxPQUFPbUYsTUFBTUQsT0FBYixLQUF5QixXQUF6QixHQUNJQSxRQUFRQyxNQUFNRCxPQUFkLENBREosR0FFSWxGLFVBSkMsQ0FBUCxDQURGLENBREssQ0FBUDtHQUxhO01BZ0JYLG1CQUFTO1FBQ1AsQ0FBQ21GLEtBQUwsRUFBWTthQUNIbkYsVUFBUDs7V0FFS2MsYUFBYTthQUFLUCxPQUFPa0YsQ0FBUCxDQUFMO0tBQWIsRUFDTFQsT0FBTyxJQUFQLEVBQ0UxRSxPQUFPLENBQ0w2RSxNQUFNQyxNQUFOLEdBQWVBLE9BQU9ELE1BQU1DLE1BQWIsQ0FBZixHQUFzQ3BGLFVBRGpDLEVBRUwsT0FBT21GLE1BQU1ELE9BQWIsS0FBeUIsV0FBekIsR0FDSUEsUUFBUUMsTUFBTUQsT0FBZCxDQURKLEdBRUlsRixVQUpDLENBQVAsQ0FERixDQURLLENBQVA7R0FwQmE7TUErQlgsbUJBQVM7UUFDUCxDQUFDbUYsS0FBTCxFQUFZO2FBQ0huRixVQUFQOztXQUVLYyxhQUFhO2FBQUtQLE9BQU9rRixDQUFQLENBQUw7S0FBYixFQUNMVCxPQUFPLElBQVAsRUFDRTFFLE9BQU8sQ0FDTDZFLE1BQU1DLE1BQU4sR0FBZUEsT0FBT0QsTUFBTUMsTUFBYixDQUFmLEdBQXNDcEYsVUFEakMsRUFFTCxPQUFPbUYsTUFBTUQsT0FBYixLQUF5QixXQUF6QixHQUNJQSxRQUFRQyxNQUFNRCxPQUFkLENBREosR0FFSWxGLFVBSkMsQ0FBUCxDQURGLENBREssQ0FBUDtHQW5DYTtNQThDWCxtQkFBUztRQUNQLENBQUNtRixLQUFMLEVBQVk7YUFDSG5GLFVBQVA7O1dBRUtjLGFBQWE7YUFBS1AsT0FBT2tGLENBQVAsQ0FBTDtLQUFiLEVBQ0xULE9BQU8sSUFBUCxFQUNFMUUsT0FBTyxDQUNMNkUsTUFBTUMsTUFBTixHQUFlQSxPQUFPRCxNQUFNQyxNQUFiLENBQWYsR0FBc0NwRixVQURqQyxFQUVMLE9BQU9tRixNQUFNRCxPQUFiLEtBQXlCLFdBQXpCLEdBQ0lBLFFBQVFDLE1BQU1ELE9BQWQsQ0FESixHQUVJbEYsVUFKQyxDQUFQLENBREYsQ0FESyxDQUFQO0dBbERhOztXQThETjhCLFFBQVE7VUFDVHZCLE9BQU9tRixhQURFO1VBRVRuRixPQUFPb0YsYUFGRTtXQUdScEYsT0FBT3FGLGNBSEM7aUJBSUZyRixPQUFPc0Ysb0JBSkw7b0JBS0N0RixPQUFPdUY7R0FMaEIsQ0E5RE07VUFxRVB0RCxLQUFLTixNQUFNLE9BQU4sQ0FBTCxFQUFxQjNCLE1BQXJCLENBckVPO2FBc0VKdUIsUUFBUTtTQUNadkIsT0FBT3dGLGNBREs7WUFFVHhGLE9BQU95RjtHQUZOLENBdEVJOzthQTJFSmxFLFFBQVE7VUFDWHZCLE9BQU8wRixhQURJO1VBRVgxRixPQUFPMkYsYUFGSTtXQUdWM0YsT0FBTzRGLGNBSEc7aUJBSUo1RixPQUFPNkYsb0JBSkg7b0JBS0Q3RixPQUFPOEY7R0FMZCxDQTNFSTtZQWtGTDdELEtBQUtOLE1BQU0sT0FBTixDQUFMLEVBQXFCM0IsTUFBckIsQ0FsRks7ZUFtRkZ1QixRQUFRO1NBQ2R2QixPQUFPK0YsY0FETztZQUVYL0YsT0FBT2dHO0dBRkosQ0FuRkU7O2FBd0ZKekUsUUFBUTtVQUNYdkIsT0FBT2lHLGFBREk7VUFFWGpHLE9BQU9rRyxhQUZJO1dBR1ZsRyxPQUFPbUcsY0FIRztpQkFJSm5HLE9BQU9vRyxvQkFKSDtvQkFLRHBHLE9BQU9xRztHQUxkLENBeEZJO1lBK0ZMcEUsS0FBS04sTUFBTSxPQUFOLENBQUwsRUFBcUIzQixNQUFyQixDQS9GSztlQWdHRnVCLFFBQVE7U0FDZHZCLE9BQU9zRyxjQURPO1lBRVh0RyxPQUFPdUc7R0FGSixDQWhHRTs7YUFxR0poRixRQUFRO1VBQ1h2QixPQUFPd0csYUFESTtVQUVYeEcsT0FBT3lHLGFBRkk7V0FHVnpHLE9BQU8wRyxjQUhHO2lCQUlKMUcsT0FBTzJHLG9CQUpIO29CQUtEM0csT0FBTzRHO0dBTGQsQ0FyR0k7WUE0R0wzRSxLQUFLTixNQUFNLE9BQU4sQ0FBTCxFQUFxQjNCLE1BQXJCLENBNUdLO2VBNkdGdUIsUUFBUTtTQUNkdkIsT0FBTzZHLGNBRE87WUFFWDdHLE9BQU84RztHQUZKLENBN0dFOztnQkFrSER2RixRQUFRO1dBQ2J3RixPQUFPQyxZQURNO1NBRWZELE9BQU9FLFVBRlE7WUFHWkYsT0FBT0csYUFISzthQUlYSCxPQUFPSSxjQUpJO1lBS1pKLE9BQU9LOztHQUxILENBbEhDO2NBMEhIN0YsUUFBUTtXQUNYd0YsT0FBT00sVUFESTtTQUViTixPQUFPTyxRQUZNO1lBR1ZQLE9BQU9RLFdBSEc7Y0FJUlIsT0FBT1M7O0dBSlAsQ0ExSEc7YUFpSUpqRyxRQUFRO1dBQ1Z3RixPQUFPVSxTQURHO1NBRVpWLE9BQU9XLE9BRks7WUFHVFgsT0FBT1ksVUFIRTtjQUlQWixPQUFPYSxZQUpBO2FBS1JiLE9BQU9jOztHQUxQLENBaklJO1VBeUlQeEcsT0FBTzBGLE9BQU9lLE9BQWQsQ0F6SU87U0EwSVJ2RyxRQUFRO1VBQ1B3RyxPQUFPQyxNQURBO2NBRUhELE9BQU9FLFVBRko7VUFHUEYsT0FBT0csTUFIQTtVQUlQSCxPQUFPSSxNQUpBO1NBS1JKLE9BQU9LLEtBTEM7V0FNTkwsT0FBT00sT0FORDtlQU9GTixPQUFPTyxXQVBMO1dBUU5QLE9BQU9RLE9BUkQ7WUFTTFIsT0FBT1MsUUFURjtXQVVOVCxPQUFPVSxPQVZEO1VBV1BWLE9BQU9XLE1BWEE7Y0FZSFgsT0FBT1ksVUFaSjtZQWFMWixPQUFPYSxRQWJGO1lBY0xiLE9BQU9jLFFBZEY7Y0FlSGQsT0FBT2UsVUFmSjtZQWdCTGYsT0FBT2dCLFFBaEJGO2dCQWlCRGhCLE9BQU9pQixZQWpCTjtlQWtCRmpCLE9BQU9rQixXQWxCTDtjQW1CSGxCLE9BQU9tQjs7R0FuQlosQ0ExSVE7T0FnS1Y3SCxPQUFPMEYsT0FBT29DLEdBQWQsQ0FoS1U7UUFpS1Q1SCxRQUFRO1VBQ053RixPQUFPcUMsUUFERDtVQUVOckMsT0FBT3NDOztHQUZULENBaktTOzs7Ozs7Ozs7OztJQXNLUDtXQUFVeEosZ0JBQWdCLEVBQUV5SixjQUFGLEVBQWhCLENBQVY7R0FBUixDQXRLZTtrQkF1S0MvSCxRQUFRO1NBQ2pCd0YsT0FBT3dDLFVBRFU7WUFFZHhDLE9BQU95QyxhQUZPO2FBR2J6QyxPQUFPMEMsY0FITTtZQUlkMUMsT0FBTzJDOztHQUpELENBdktEO1FBOEtUckksT0FBTzBGLE9BQU80QyxLQUFkLENBOUtTO29CQStLRyxpQ0FBUztRQUNyQkMsS0FBS25LLFVBQVQ7UUFDSW9LLEtBQUtwSyxVQUFUO1FBQ0lxSyxLQUFLckssVUFBVDtRQUNJc0ssS0FBS3RLLFVBQVQ7bUJBQ2VtRixLQUFmLHlDQUFlQSxLQUFmO1dBQ08sUUFBTDtlQUNTakYsY0FBY3FLLHVCQUFxQmxGLGVBQWVGLEtBQWYsQ0FBckIsQ0FBZCxDQUFQO1dBQ0csUUFBTDtZQUNNQSxNQUFNcUYsR0FBVixFQUFlO2VBQ1J0SyxjQUNIcUssd0JBQXNCbEYsZUFBZUYsTUFBTXFGLEdBQXJCLENBQXRCLENBREcsQ0FBTDs7O1lBS0VyRixNQUFNc0YsTUFBVixFQUFrQjtlQUNYdkssY0FDSHFLLHdCQUFzQmxGLGVBQWVGLE1BQU1zRixNQUFyQixDQUF0QixDQURHLENBQUw7OztZQUtFdEYsTUFBTXVGLElBQVYsRUFBZ0I7ZUFDVHhLLGNBQ0hpRixNQUFNdUYsSUFBTixLQUFlLE1BQWYsR0FDSUgsaUJBQWlCSSxNQURyQixHQUVJSix3QkFBc0JsRixlQUFlRixNQUFNdUYsSUFBckIsQ0FBdEIsQ0FIRCxDQUFMOzs7WUFPRXZGLE1BQU15RixLQUFWLEVBQWlCO2VBQ1YxSyxjQUNIaUYsTUFBTXlGLEtBQU4sS0FBZ0IsTUFBaEIsR0FDSUwsaUJBQWlCTSxNQURyQixHQUVJTix3QkFBc0JsRixlQUFlRixNQUFNeUYsS0FBckIsQ0FBdEIsQ0FIRCxDQUFMOztlQU1LdEssT0FBTyxDQUFDNkosRUFBRCxFQUFLQyxFQUFMLEVBQVNDLEVBQVQsRUFBYUMsRUFBYixDQUFQLENBQVA7O2VBRU90SyxVQUFQOztHQXJOUzswQkFBQTtzQkFBQTtnQkFBQTtzQkFBQTswQkFBQTs0QkFBQTt3QkFBQTtvQkFBQTswQkFBQTs4QkFBQTtnQ0FBQTs0QkFBQTtvQkFBQTswQkFBQTs4QkFBQTtnQ0FBQTs0QkFBQTtvQkFBQTswQkFBQTs4QkFBQTtnQ0FBQTs0QkFBQTs7Ozs7Ozs7Ozs7SUE4T0o7V0FBYUksZ0JBQWdCLEVBQUUwSyxvQkFBRixFQUFoQixDQUFiO0dBQVgsQ0E5T2U7Ozs7Ozs7Ozs7O0lBK09MO1dBQVkxSyxnQkFBZ0IsRUFBRTJLLGtCQUFGLEVBQWhCLENBQVo7R0FBVixDQS9PZTs7Ozs7Ozs7Ozs7SUFnUEo7V0FBYTNLLGdCQUFnQixFQUFFNEssb0JBQUYsRUFBaEIsQ0FBYjtHQUFYLENBaFBlOzs7Ozs7Ozs7OztJQWlQTDtXQUFZNUssZ0JBQWdCLEVBQUU2SyxrQkFBRixFQUFoQixDQUFaO0dBQVYsQ0FqUGU7WUFrUExuSixRQUFRO1lBQ1J3RixPQUFPNEQsY0FEQztZQUVSNUQsT0FBTzZELGNBRkM7VUFHVjdELE9BQU84RCxZQUhHO2FBSVA5RCxPQUFPK0QsZUFKQTthQUtQL0QsT0FBT2dFOztHQUxSLENBbFBLO3FCQTBQSSxrQ0FBUzttQkFDWG5HLEtBQWYseUNBQWVBLEtBQWY7V0FDTyxRQUFMO2VBQ1NqRixjQUFjcUssdUJBQXFCcEYsS0FBckIsQ0FBZCxDQUFQO1dBQ0csUUFBTDtlQUNTN0UsT0FBTyxDQUNaNkUsTUFBTUcsQ0FBTixHQUNJcEYsY0FBY3FLLHdCQUFzQnBGLE1BQU1HLENBQTVCLENBQWQsQ0FESixHQUVJdEYsVUFIUSxFQUlabUYsTUFBTW9HLENBQU4sR0FDSXJMLGNBQWNxSyx3QkFBc0JwRixNQUFNb0csQ0FBNUIsQ0FBZCxDQURKLEdBRUl2TCxVQU5RLENBQVAsQ0FBUDs7ZUFTT0EsVUFBUDs7R0F4UVM7a0JBQUE7b0JBQUE7b0JBQUE7c0JBQUE7d0JBQUE7d0JBQUE7c0JBQUE7d0JBQUE7d0JBQUE7c0JBQUE7d0JBQUE7d0JBQUE7WUF1Ukw4QixRQUFRO2NBQ053RixPQUFPa0UsUUFERDtjQUVObEUsT0FBT21FLFFBRkQ7V0FHVG5FLE9BQU9vRTs7R0FITixDQXZSSztTQTZSUjlKLE9BQU8wRixPQUFPcUUsTUFBZCxDQTdSUTtTQThSUjdKLFFBQVE7WUFDTDhKLFFBQVFDLE1BREg7VUFFUEQsUUFBUUUsSUFGRDthQUdKRixRQUFRRyxPQUhKO21CQUlFSCxRQUFRSSxhQUpWO2lCQUtBSixRQUFRSyxXQUxSO2tCQU1DTCxRQUFRTSxZQU5UO2dCQU9ETixRQUFRTzs7R0FQZixDQTlSUTtPQXdTVnZLLE9BQU8wRixPQUFPOEUsSUFBZCxDQXhTVTs7Ozs7Ozs7Ozs7SUF5U1I7V0FBU2hNLGdCQUFnQixFQUFFaU0sWUFBRixFQUFoQixDQUFUO0dBQVAsQ0F6U2U7UUEwU1R6SyxPQUFPMEYsT0FBT2dGLFFBQWQsQ0ExU1M7NkJBMlNZOzs7ZUFFaEJuSCxNQUFNb0gsT0FBZixHQUF5Qm5NLGdCQUFnQitFLE1BQU1vSCxPQUF0QixDQUF6QixHQUEwRHZNOzs7Q0E3UzlEOzs7Ozs7OztBQXNUQSxJQUFNd00sV0FBVyxTQUFYQSxRQUFXLENBQUNDLEdBQUQsRUFBTUMsR0FBTjtTQUFjQSxJQUFJQyxPQUFKLENBQVlGLEdBQVosS0FBb0IsQ0FBbEM7Q0FBakI7QUFDQSxJQUFNRyxPQUFPLFNBQVBBLElBQU8sQ0FBQ25MLElBQUQsRUFBT29MLEdBQVA7U0FDWHJMLE9BQU9DLElBQVAsQ0FBWW9MLEdBQVosRUFBaUJyTSxNQUFqQixDQUF3QixVQUFDc00sR0FBRCxFQUFNQyxDQUFOLEVBQVk7UUFDOUJQLFNBQVNPLENBQVQsRUFBWXRMLElBQVosQ0FBSixFQUF1QjthQUNkcUwsR0FBUDs7d0JBR0dBLEdBREwscUJBRUdDLENBRkgsRUFFT0YsSUFBSUUsQ0FBSixDQUZQO0dBSkYsRUFRRyxFQVJILENBRFc7Q0FBYjs7QUFXQSxBQUFlLFNBQVNDLEdBQVQsT0FBK0M7TUFBaENDLFFBQWdDLFFBQWhDQSxRQUFnQztNQUFuQjdMLEtBQW1COzs7Ozs7Ozs7O01BU3hEOEwsWUFBWSxDQUFDLFNBQUQsRUFBWSxXQUFaLEVBQXlCLE9BQXpCLENBQWhCOzs7O01BSUlDLElBQUlqTixjQUFjSyxPQUFPNk0sR0FBckIsQ0FBUjs7Ozs7Ozs7Ozs7O09BWUssSUFBTUMsSUFBWCxJQUFtQmpNLEtBQW5CLEVBQTBCO1FBQ3BCSSxPQUFPTyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUN1RCxRQUFyQyxFQUErQzZILElBQS9DLENBQUosRUFBMEQ7VUFDbER0TSxLQUFLeUUsU0FBUzZILElBQVQsQ0FBWDtVQUNNbEksUUFBUS9ELE1BQU1pTSxJQUFOLENBQWQ7a0JBQ1lILFVBQVU1TSxNQUFWLENBQWlCK00sSUFBakIsQ0FBWjtVQUNJL00sT0FBTyxDQUFDNk0sQ0FBRCxFQUFJcE0sR0FBR29FLEtBQUgsQ0FBSixDQUFQLENBQUo7Ozs7O1NBTUZtSTs7aUJBQVNWLEtBQUtNLFNBQUwsRUFBZ0I5TCxLQUFoQixDQUFULEVBQXFDRCxRQUFRZ00sQ0FBUixDQUFyQzs7R0FERjs7Ozs7Ozs7Ozs7QUFlRixJQUFNSSxpQkFBaUJDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckMsQ0FEcUMsRUFFckMsQ0FGcUMsRUFHckMsQ0FIcUMsRUFJckMsQ0FKcUMsRUFLckMsQ0FMcUMsRUFNckMsQ0FOcUMsRUFPckMsQ0FQcUMsRUFRckMsQ0FScUMsRUFTckMsQ0FUcUMsRUFVckMsQ0FWcUMsRUFXckMsRUFYcUMsRUFZckMsRUFacUMsRUFhckMsRUFicUMsQ0FBaEIsQ0FBdkI7O0FBZ0JBLElBQU1DLGlCQUFpQkYsVUFBVUMsS0FBVixDQUFnQixDQUNyQyxDQUFDLEVBRG9DLEVBRXJDLENBQUMsRUFGb0MsRUFHckMsQ0FBQyxFQUhvQyxFQUlyQyxDQUFDLENBSm9DLEVBS3JDLENBQUMsQ0FMb0MsRUFNckMsQ0FBQyxDQU5vQyxFQU9yQyxDQUFDLENBUG9DLEVBUXJDLENBQUMsQ0FSb0MsRUFTckMsQ0FBQyxDQVRvQyxFQVVyQyxDQUFDLENBVm9DLEVBV3JDLENBQUMsQ0FYb0MsRUFZckMsQ0FBQyxDQVpvQyxFQWFyQyxDQWJxQyxFQWNyQyxDQWRxQyxFQWVyQyxDQWZxQyxFQWdCckMsQ0FoQnFDLEVBaUJyQyxDQWpCcUMsRUFrQnJDLENBbEJxQyxFQW1CckMsQ0FuQnFDLEVBb0JyQyxDQXBCcUMsRUFxQnJDLENBckJxQyxFQXNCckMsQ0F0QnFDLEVBdUJyQyxFQXZCcUMsRUF3QnJDLEVBeEJxQyxFQXlCckMsRUF6QnFDLENBQWhCLENBQXZCOztBQTRCQSxJQUFNRSxrQkFBa0JILFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDdEMsQ0FEc0MsRUFFdEMsQ0FGc0MsRUFHdEMsQ0FIc0MsRUFJdEMsQ0FKc0MsRUFLdEMsQ0FMc0MsRUFNdEMsQ0FOc0MsRUFPdEMsQ0FQc0MsRUFRdEMsQ0FSc0MsRUFTdEMsQ0FUc0MsRUFVdEMsQ0FWc0MsRUFXdEMsRUFYc0MsRUFZdEMsRUFac0MsRUFhdEMsRUFic0MsQ0FBaEIsQ0FBeEI7O0FBZ0JBVCxJQUFJWSxTQUFKLEdBQWdCO1lBQ0pKLFVBQVVLLElBRE47NkJBRWFMLFVBQVVNLEtBQVYsQ0FBZ0I7YUFDaENOLFVBQVVPO0dBRE0sQ0FGYjs7TUFNVlAsVUFBVU0sS0FBVixDQUFnQjthQUNUTixVQUFVUSxTQUFWLENBQW9CLENBQzNCUixVQUFVUyxJQURpQixFQUUzQlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGFBQXZCLENBQWhCLENBRjJCLENBQXBCLENBRFM7WUFLVkQsVUFBVVU7R0FMaEIsQ0FOVTtNQWFWVixVQUFVTSxLQUFWLENBQWdCO2FBQ1ROLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDM0JSLFVBQVVTLElBRGlCLEVBRTNCVCxVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUIsYUFBdkIsQ0FBaEIsQ0FGMkIsQ0FBcEIsQ0FEUztZQUtWRCxVQUFVVTtHQUxoQixDQWJVO01Bb0JWVixVQUFVTSxLQUFWLENBQWdCO2FBQ1ROLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDM0JSLFVBQVVTLElBRGlCLEVBRTNCVCxVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFlBQVQsRUFBdUIsYUFBdkIsQ0FBaEIsQ0FGMkIsQ0FBcEIsQ0FEUztZQUtWRCxVQUFVVTtHQUxoQixDQXBCVTtNQTJCVlYsVUFBVU0sS0FBVixDQUFnQjthQUNUTixVQUFVUSxTQUFWLENBQW9CLENBQzNCUixVQUFVUyxJQURpQixFQUUzQlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGFBQXZCLENBQWhCLENBRjJCLENBQXBCLENBRFM7WUFLVkQsVUFBVVU7R0FMaEIsQ0EzQlU7b0JBa0NJVixVQUFVUSxTQUFWLENBQW9CLENBQ3BDUixVQUFVVSxNQUQwQixFQUVwQ1YsVUFBVVcsS0FBVixDQUFnQjtTQUNUWCxVQUFVVSxNQUREO1lBRU5WLFVBQVVVLE1BRko7VUFHUlYsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxDQUFoQixDQUFuQixDQUFwQixDQUhRO1dBSVBELFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsQ0FBaEIsQ0FBbkIsQ0FBcEI7R0FKVCxDQUZvQyxDQUFwQixDQWxDSjtxQkEyQ0tELFVBQVVRLFNBQVYsQ0FBb0IsQ0FDckNSLFVBQVVVLE1BRDJCLEVBRXJDVixVQUFVVyxLQUFWLENBQWdCO09BQ1hYLFVBQVVVLE1BREM7T0FFWFYsVUFBVVU7R0FGZixDQUZxQyxDQUFwQixDQTNDTDs7V0FtRExWLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDdkIsTUFEdUIsRUFFdkIsTUFGdUIsRUFHdkIsT0FIdUIsRUFJdkIsYUFKdUIsRUFLdkIsZ0JBTHVCLENBQWhCLENBbkRLO2FBMERIRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBaEIsQ0ExREc7VUEyRE5GLGNBM0RNOzthQTZESEMsVUFBVUMsS0FBVixDQUFnQixDQUN6QixNQUR5QixFQUV6QixNQUZ5QixFQUd6QixPQUh5QixFQUl6QixhQUp5QixFQUt6QixnQkFMeUIsQ0FBaEIsQ0E3REc7ZUFvRURELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxLQUFELEVBQVEsUUFBUixDQUFoQixDQXBFQztZQXFFSkYsY0FyRUk7O2FBdUVIQyxVQUFVQyxLQUFWLENBQWdCLENBQ3pCLE1BRHlCLEVBRXpCLE1BRnlCLEVBR3pCLE9BSHlCLEVBSXpCLGFBSnlCLEVBS3pCLGdCQUx5QixDQUFoQixDQXZFRztlQThFREQsVUFBVUMsS0FBVixDQUFnQixDQUFDLEtBQUQsRUFBUSxRQUFSLENBQWhCLENBOUVDO1lBK0VKRixjQS9FSTs7YUFpRkhDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDekIsTUFEeUIsRUFFekIsTUFGeUIsRUFHekIsT0FIeUIsRUFJekIsYUFKeUIsRUFLekIsZ0JBTHlCLENBQWhCLENBakZHO2VBd0ZERCxVQUFVQyxLQUFWLENBQWdCLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBaEIsQ0F4RkM7WUF5RkpGLGNBekZJOztnQkEyRkFDLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDNUIsT0FENEIsRUFFNUIsS0FGNEIsRUFHNUIsUUFINEIsRUFJNUIsU0FKNEIsRUFLNUIsUUFMNEIsRUFNNUIsU0FONEIsQ0FBaEIsQ0EzRkE7Y0FtR0ZELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDMUIsT0FEMEIsRUFFMUIsS0FGMEIsRUFHMUIsUUFIMEIsRUFJMUIsVUFKMEIsRUFLMUIsU0FMMEIsQ0FBaEIsQ0FuR0U7YUEwR0hELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDekIsTUFEeUIsRUFFekIsT0FGeUIsRUFHekIsS0FIeUIsRUFJekIsUUFKeUIsRUFLekIsVUFMeUIsRUFNekIsU0FOeUIsQ0FBaEIsQ0ExR0c7VUFrSE5ELFVBQVVTLElBbEhKO1NBbUhQVCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLE1BRHFCLEVBRXJCLFVBRnFCLEVBR3JCLFVBSHFCLEVBSXJCLFVBSnFCLEVBS3JCLE1BTHFCLEVBTXJCLE9BTnFCLEVBT3JCLFdBUHFCLEVBUXJCLFdBUnFCLEVBU3JCLFFBVHFCLEVBVXJCLFVBVnFCLEVBV3JCLE1BWHFCLEVBWXJCLE9BWnFCLEVBYXJCLFFBYnFCLEVBY3JCLFFBZHFCLEVBZXJCLE1BZnFCLEVBZ0JyQixRQWhCcUIsRUFpQnJCLEtBakJxQixFQWtCckIsYUFsQnFCLEVBbUJyQixZQW5CcUIsRUFvQnJCLE9BcEJxQixDQUFoQixDQW5ITztPQXlJVEQsVUFBVVMsSUF6SUQ7UUEwSVJULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixNQUFuQixDQUFoQixDQTFJUTtRQTJJUkQsVUFBVVMsSUEzSUY7VUE0SU5ULFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEIsQ0E1SU07a0JBNklFWixVQUFVQyxLQUFWLENBQWdCLENBQzlCLE9BRDhCLEVBRTlCLEtBRjhCLEVBRzlCLFFBSDhCLEVBSTlCLFNBSjhCLEVBSzlCLFFBTDhCLENBQWhCLENBN0lGO1FBb0pSRCxVQUFVUyxJQXBKRjs7ZUFzSkRQLGNBdEpDO2FBdUpIQSxjQXZKRzs7VUF5Sk5BLGNBekpNO2FBMEpIQSxjQTFKRztlQTJKREEsY0EzSkM7Z0JBNEpBQSxjQTVKQTtjQTZKRkEsY0E3SkU7O1lBK0pKQSxjQS9KSTtlQWdLREEsY0FoS0M7aUJBaUtDQSxjQWpLRDtrQkFrS0VBLGNBbEtGO2dCQW1LQUEsY0FuS0E7O1lBcUtKQSxjQXJLSTtlQXNLREEsY0F0S0M7aUJBdUtDQSxjQXZLRDtrQkF3S0VBLGNBeEtGO2dCQXlLQUEsY0F6S0E7O1lBMktKQSxjQTNLSTtlQTRLREEsY0E1S0M7aUJBNktDQSxjQTdLRDtrQkE4S0VBLGNBOUtGO2dCQStLQUEsY0EvS0E7O2FBaUxIRixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBakxHO1lBa0xKWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBbExJO2FBbUxIWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBbkxHO1lBb0xKWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBcExJOztZQXNMSlosVUFBVUMsS0FBVixDQUFnQixDQUN4QixTQUR3QixFQUV4QixRQUZ3QixFQUd4QixRQUh3QixFQUl4QixTQUp3QixFQUt4QixTQUx3QixFQU14QixNQU53QixDQUFoQixDQXRMSTs7V0ErTExFLGVBL0xLO1lBZ01KQSxlQWhNSTtZQWlNSkEsZUFqTUk7O2FBbU1IQSxlQW5NRztjQW9NRkEsZUFwTUU7Y0FxTUZBLGVBck1FOzthQXVNSEEsZUF2TUc7Y0F3TUZBLGVBeE1FO2NBeU1GQSxlQXpNRTs7YUEyTUhBLGVBM01HO2NBNE1GQSxlQTVNRTtjQTZNRkEsZUE3TUU7O1lBK01KSCxVQUFVQyxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsVUFBdkIsRUFBbUMsT0FBbkMsQ0FBaEIsQ0EvTUk7U0FnTlBELFVBQVVTLElBaE5IO1NBaU5QVCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLFFBRHFCLEVBRXJCLFNBRnFCLEVBR3JCLE1BSHFCLEVBSXJCLFFBSnFCLEVBS3JCLFlBTHFCLEVBTXJCLGVBTnFCLEVBT3JCLGFBUHFCLEVBUXJCLGNBUnFCLENBQWhCLENBak5PO09BMk5URCxVQUFVUyxJQTNORDtTQTROUFQsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQTVOTztRQTZOUlosVUFBVVM7Q0E3TmxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdwQkEsWUFBZTtVQUFBO2dCQUVDSSxTQUZEO2FBR0ZDLE1BSEU7Z0JBSUNDLFNBSkQ7Z0JBS0NDLFNBTEQ7dUJBTVFDLGVBTlI7MEJBT1dDLGtCQVBYO2dCQVFDQyxTQVJEO21CQVNJQyxZQVRKO2NBVURDLE9BVkM7b0JBV0tDLFlBWEw7WUFBQTtnQkFBQTtnQkFBQTtjQUFBO2tCQWdCR0MsV0FoQkg7b0JBaUJLQyxhQWpCTDtjQUFBO2NBQUE7VUFBQTtrQkFBQTtZQUFBO1lBQUE7b0JBQUE7NkJBeUJjQyxxQkF6QmQ7b0JBQUE7VUFBQTtvQkFBQTtnQkE2QkNDLFNBN0JEO2NBOEJEQyxPQTlCQztpQkErQkVDLFVBL0JGO2dCQUFBO1lBQUE7d0JBQUE7VUFBQTtjQUFBO21CQXFDSUMsWUFyQ0o7Y0FBQTtpQkF1Q0VDLFVBdkNGO2VBd0NBQyxRQXhDQTtnQkFBQTttQkEwQ0lDLFlBMUNKO2NBQUE7a0JBNENHQyxXQTVDSDtjQUFBO3NCQUFBO1lBQUE7b0JBQUE7WUFBQTtvQkFBQTtzQkFBQTtZQUFBO29CQUFBO1lBQUE7WUFBQTtjQUFBO2dCQUFBO2dCQUFBO2dCQTJEQ0MsU0EzREQ7VUFBQTtjQTZEREMsT0E3REM7c0JBQUE7WUFBQTttQkFnRUlDLFlBaEVKO2dCQUFBO2dCQUFBO2dCQUFBO2tCQW9FR0MsV0FwRUg7Z0JBQUE7b0JBc0VLQyxhQXRFTDtZQUFBO2NBQUE7Y0FBQTtnQkFBQTtxQkEyRU1DLGNBM0VOO1VBQUE7a0JBQUE7dUJBOEVRQyxlQTlFUjtxQkErRU1DLGFBL0VOO29CQWdGS0M7Q0FoRnBCOztBQ3RDQSxJQUFNQyxZQUFZM08sT0FBT0MsSUFBUCxDQUFZMk8sS0FBWixDQUFsQjs7QUFFQSxBQUFlLFNBQVNDLElBQVQsQ0FBY2pQLEtBQWQsRUFBNEI7TUFFdkNrUCxrQkFGdUMsR0FRckNsUCxLQVJxQyxDQUV2Q2tQLGtCQUZ1QztxQkFRckNsUCxLQVJxQyxDQUd2Q21QLEtBSHVDO01BR3ZDQSxLQUh1QyxnQ0FHL0IsTUFIK0I7TUFJdkNDLElBSnVDLEdBUXJDcFAsS0FScUMsQ0FJdkNvUCxJQUp1QztNQUt2Q0MsTUFMdUMsR0FRckNyUCxLQVJxQyxDQUt2Q3FQLE1BTHVDO29CQVFyQ3JQLEtBUnFDLENBTXZDQyxJQU51QztNQU12Q0EsSUFOdUMsK0JBTWhDLEVBTmdDO01BT3ZDcVAscUJBUHVDLEdBUXJDdFAsS0FScUMsQ0FPdkNzUCxxQkFQdUM7OztNQVVuQ0MsS0FBS0MsV0FBV3JRLFNBQU9pUSxJQUFsQixFQUF3QmxJLE9BQU9pSSxLQUFQLENBQXhCLHFCQUNSaFEsU0FBT3NRLFNBREMsRUFDVyxDQUFDSixNQURaLEVBQVg7O01BSU1LLE9BQ0hOLFFBQVFKLE1BQU1JLElBQU4sQ0FBVDs7MkJBRTBCRSxzQkFBc0JLLE1BRmhELElBR0FDLFNBSkY7O01BTU1DLGFBQWFYLHVCQUF1QixFQUF2QixHQUE0QixJQUE1QixHQUFtQyxJQUF0RDs7U0FHRWhEOzs7aUJBQ2FxRCxFQURiO2NBRVV0UCxJQUZWO2FBR1NBLElBSFQ7ZUFJVSxXQUpWO3FCQUtlNFAsVUFMZjtvQkFNY1gsa0JBTmQ7WUFPTzs7Ozs7O0tBUFA7a0NBVVEsR0FBR1EsSUFBVDtHQVhKOzs7QUFnQkZULEtBQUtELEtBQUwsR0FBYUQsU0FBYjs7QUFFQUUsS0FBS3pDLFNBQUwsR0FBaUI7c0JBQ0tKLFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUR0QjtTQUVSMUQsVUFBVUMsS0FBVixDQUFnQixDQUNyQixNQURxQixFQUVyQixVQUZxQixFQUdyQixVQUhxQixFQUlyQixNQUpxQixFQUtyQixPQUxxQixFQU1yQixXQU5xQixFQU9yQixRQVBxQixFQVFyQixVQVJxQixFQVNyQixNQVRxQixFQVVyQixPQVZxQixFQVdyQixRQVhxQixFQVlyQixRQVpxQixFQWFyQixNQWJxQixFQWNyQixRQWRxQixFQWVyQixLQWZxQixFQWdCckIsWUFoQnFCLEVBaUJyQixPQWpCcUIsQ0FBaEIsQ0FGUTt5QkFxQlFELFVBQVVXLEtBQVYsQ0FBZ0I7WUFDN0JYLFVBQVVZO0dBREcsQ0FyQlI7UUF3QlRaLFVBQVVDLEtBQVYsQ0FBZ0IwQyxTQUFoQixDQXhCUztVQXlCUDNDLFVBQVVTLElBekJIO1FBMEJUVCxVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCO0NBMUJSOzs7O0FDaEZBLElBQU0rQyxtQkFBbUIsU0FBbkJBLGdCQUFtQjtTQUFPekgsUUFBUSxPQUFSLElBQW1CQSxRQUFRLFNBQWxDO0NBQXpCOztJQWdCcUIwSDs7Ozs7Ozs7Ozs7Ozs7bUxBaUNuQkMsYUFBYSxZQUFNO1VBQ2IsTUFBS2pRLEtBQUwsQ0FBV2tRLE1BQWYsRUFBdUI7Y0FDaEJsUSxLQUFMLENBQVdrUSxNQUFYOzthQUlKQyxjQUFjLFlBQU07VUFDZCxNQUFLblEsS0FBTCxDQUFXb1EsT0FBZixFQUF3QjtjQUNqQnBRLEtBQUwsQ0FBV29RLE9BQVg7Ozs7Ozs7d0NBckJnQjtVQUNkTCxpQkFBaUIsS0FBSy9QLEtBQUwsQ0FBV3NJLEdBQTVCLENBQUosRUFBc0M7YUFDL0IrSCxTQUFMOzs7Ozt1Q0FJZUMsV0FBa0I7bUJBQ2QsS0FBS3RRLEtBRFM7VUFDM0JzSSxHQUQyQixVQUMzQkEsR0FEMkI7VUFDdEJpSSxHQURzQixVQUN0QkEsR0FEc0I7O1VBRS9CUixpQkFBaUJ6SCxHQUFqQixLQUF5QmdJLFVBQVVDLEdBQVYsS0FBa0JBLEdBQS9DLEVBQW9EO2FBQzdDRixTQUFMOzs7OztnQ0FnQlE7VUFDTixPQUFPRyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO1lBQzNCQyxRQUFRLElBQUlELE9BQU9SLEtBQVgsRUFBZDtjQUNNVSxNQUFOLEdBQWUsS0FBS1QsVUFBcEI7Y0FDTVUsT0FBTixHQUFnQixLQUFLUixXQUFyQjtjQUNNSSxHQUFOLEdBQVksS0FBS3ZRLEtBQUwsQ0FBV3VRLEdBQXZCOzs7Ozs2QkFJSztvQkFXSCxLQUFLdlEsS0FYRjtVQUVMNFEsR0FGSyxXQUVMQSxHQUZLO1VBR0x6QixLQUhLLFdBR0xBLEtBSEs7VUFJTHRELFFBSkssV0FJTEEsUUFKSztVQUtMdkQsR0FMSyxXQUtMQSxHQUxLO1VBTUx1SSxhQU5LLFdBTUxBLGFBTks7VUFPTEMsWUFQSyxXQU9MQSxZQVBLO1VBUUxDLEtBUkssV0FRTEEsS0FSSztVQVNMUixHQVRLLFdBU0xBLEdBVEs7VUFVTFMsTUFWSyxXQVVMQSxNQVZLOzs7VUFhREMsZ0JBQWdCbEIsaUJBQWlCekgsR0FBakIsQ0FBdEI7VUFDTTRJLGVBQWVyRixXQUNuQks7V0FBQTtVQUFLLFVBQVMsVUFBZCxFQUF5QixTQUF6QixFQUE2QixVQUE3QixFQUFrQyxZQUFsQyxFQUF5QyxXQUF6QyxFQUErQyxVQUFTLFFBQXhEOztPQURtQixHQUlqQixJQUpKOzthQU1PK0UsZ0JBQ0wvRTs7O3dCQUNjMEUsR0FEZDtxQkFFYXpSLFNBQU9tSixHQUFQLENBRmI7aUJBR1M7NkJBQ1k2RyxLQURaO3dDQUVvQm9CLEdBQXpCO1dBTEo7Z0JBT087OztPQVJGLEdBYUxyRTtXQUFBOztvQkFDVyxVQURYO3FDQUU2QjtxQkFDaEI7K0JBQ1VpRCxLQURWOzZCQUVXMEIsZ0JBQWdCQyxZQUFoQixHQUErQixHQUFqRDs7Ozs7ZUFLR0YsR0FEUDtxQkFFYXpSLFNBQU9nUyxHQUZwQjttQkFHVyxLQUFLaEIsV0FIaEI7a0JBSVUsS0FBS0YsVUFKZjtpQkFLU2MsS0FMVDtlQU1PUixHQU5QO2tCQU9VUztVQWhCWjs7T0FiRjs7OztFQTFFK0JJOztBQUFkcEIsTUFDWnhELFlBQVk7T0FDWkosVUFBVVksTUFBVixDQUFpQjhDLFVBREw7WUFFUDFELFVBQVVLLElBRkg7U0FHVkwsVUFBVVksTUFIQTtPQUlaWixVQUFVQyxLQUFWLENBQWdCLENBQUMsU0FBRCxFQUFZLE9BQVosRUFBcUIsTUFBckIsQ0FBaEIsQ0FKWTtpQkFLRkQsVUFBVVUsTUFBVixDQUFpQmdELFVBTGY7Z0JBTUgxRCxVQUFVVSxNQUFWLENBQWlCZ0QsVUFOZDtXQU9SMUQsVUFBVWlGLElBUEY7VUFRVGpGLFVBQVVpRixJQVJEO1NBU1ZqRixVQUFVWSxNQVRBO09BVVpaLFVBQVVZLE1BQVYsQ0FBaUI4QyxVQVZMO1VBV1QxRCxVQUFVWTs7QUFaRGdELE1BZVpzQixlQUFlO1NBQ2IsYUFEYTtPQUVmOzs7OztBQ3pCTSxTQUFTQyxJQUFULENBQWN2UixLQUFkLEVBQTRCO01BQ2pDNkwsUUFEaUMsR0FDMkI3TCxLQUQzQixDQUNqQzZMLFFBRGlDO3FCQUMyQjdMLEtBRDNCLENBQ3ZCK00sS0FEdUI7TUFDdkJBLEtBRHVCLGdDQUNmLFFBRGU7TUFDTDlCLEtBREssR0FDMkJqTCxLQUQzQixDQUNMaUwsS0FESztNQUNFeEMsTUFERixHQUMyQnpJLEtBRDNCLENBQ0V5SSxNQURGO29CQUMyQnpJLEtBRDNCLENBQ1V3UixJQURWO01BQ1VBLElBRFYsK0JBQ2lCLEtBRGpCOztTQUd2Q3RGOztNQUFLLFdBQVd1RixXQUFHdFMsU0FBT29TLElBQVYsRUFBZ0JwUyxTQUFPNE4sS0FBUCxDQUFoQixDQUFoQixFQUFnRCxPQUFPLEVBQUU5QixZQUFGLEVBQVN4QyxjQUFULEVBQXZEO1lBQUE7WUFFV3lELDZCQUFLLFdBQVcvTSxTQUFPcVMsSUFBdkI7R0FIYjs7O0FBUUZELEtBQUsvRSxTQUFMLEdBQWlCO1lBQ0xKLFVBQVVLLElBREw7VUFFUEwsVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQUZPO1NBR1JaLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsU0FBWCxFQUFzQixRQUF0QixDQUFoQixDQUhRO1NBSVJELFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEIsQ0FKUTtRQUtUWixVQUFVUztDQUxsQjs7OztBQ2ZBLElBQU02RSxTQUFTLFNBQVRBLE1BQVMsQ0FBQzFSLEtBQUQ7U0FDYmtNO09BQUE7aUJBQVNsTSxLQUFULElBQWdCLFVBQVMsVUFBekI7d0JBQ0csR0FBRDtpQ0FDNkIsRUFBRW1MLFNBQVMsRUFBRXdHLGVBQWUsTUFBakIsRUFBWCxFQUQ3QjtnQkFFVztNQUhiOztTQUtFO1FBQUssVUFBUyxVQUFkLEVBQXlCLFNBQXpCLEVBQTZCLFVBQTdCLEVBQWtDLFlBQWxDLEVBQXlDLFdBQXpDO1lBQ1M5Rjs7R0FQRTtDQUFmOztBQVlBLElBQU0rRixnQkFBZ0IsU0FBaEJBLGFBQWdCLE9BQWdDO01BQTdCdFEsSUFBNkIsUUFBN0JBLElBQTZCOztNQUM5Q3VRLGVBQWV2USxPQUFPLDRCQUFJQSxJQUFKLEdBQVUsQ0FBVixFQUFhd1EsV0FBYixFQUFQLEdBQW9DLEVBQXpEO1NBRUU1RjtVQUFBO01BQVEsT0FBTSxNQUFkLEVBQXFCLE9BQU0sUUFBM0I7b0JBRUlBOzs7ZUFDUSxNQURSO2lCQUVVLGlCQUZWO2lCQUdVLEtBSFY7NkJBSXNCLGVBSnRCO2VBS1E7Ozs7OztPQUxSOzs7O29CQVNhLE1BRFg7Z0JBRU8sTUFGUDs0QkFHbUIsU0FIbkI7c0JBSWEsUUFKYjtxQkFLYSxDQUNUNkYsV0FBV0MsV0FERixFQUVURCxXQUFXRSxTQUZGLEVBR1RGLFdBQVdHLFlBSEYsRUFJVEgsV0FBV0ksY0FKRixFQUtUaFMsSUFMUyxDQUtKLEdBTEk7Ozs7O0dBaEJyQjtDQUZGOztBQTJDQSxJQUFNNFEsUUFBUTtNQUNSLEVBRFE7TUFFUixFQUZRO01BR1I7Q0FITjs7SUFNcUJxQjs7Ozs7Ozs7Ozs7Ozs7dUxBU25CQyxRQUFRO3FCQUNTO2FBR2pCQyxtQkFBbUI7YUFBTSxNQUFLQyxRQUFMLENBQWMsRUFBRUMsZUFBZSxLQUFqQixFQUFkLENBQU47Ozs7Ozs2QkFFVjttQkFDd0MsS0FBS3hTLEtBRDdDO1VBQ0NzQixJQURELFVBQ0NBLElBREQ7VUFDT21SLE9BRFAsVUFDT0EsT0FEUDtVQUNnQnhTLElBRGhCLFVBQ2dCQSxJQURoQjtVQUNzQnNRLEdBRHRCLFVBQ3NCQSxHQUR0QjtVQUMyQm1DLFFBRDNCLFVBQzJCQSxRQUQzQjtVQUVDRixhQUZELEdBRW1CLEtBQUtILEtBRnhCLENBRUNHLGFBRkQ7O1VBR0R2SCxRQUFRaEwsT0FBTzhRLE1BQU05USxJQUFOLENBQVAsR0FBcUIsTUFBbkM7VUFDTXdJLFNBQVN4SSxPQUFPOFEsTUFBTTlRLElBQU4sQ0FBUCxHQUFxQixFQUFwQzthQUVFaU07V0FBQTs7aUJBQ1E7V0FDRHVHLFVBQ0Q7cUNBQzZCO3FCQUNoQjt5QkFDSTs7O1NBSmhCLEdBUUQsRUFWTjtpQkFXU3hILEtBWFQ7a0JBWVV4QyxNQVpWO29CQWFXLFVBYlg7aUJBY1E7O2VBRUUrSixhQUFQLEdBQ0N0RztjQUFBO1lBQU0sT0FBTSxRQUFaLEVBQXFCLFVBQXJCOzhCQUNHLEtBQUQ7aUJBQ081SyxJQURQO21CQUVRLFNBRlI7MkJBR2lCLENBSGpCOzBCQUlnQixDQUpoQjtpQkFLT2lQLEdBTFA7cUJBTVcsS0FBSytCOztTQVJuQixHQVlDcEcsb0JBQUMsYUFBRCxJQUFlLE1BQU01SyxJQUFyQixHQTVCSjtvQkErQkk0SzthQUFBOztzQkFDVyxVQURYO21CQUVRLEtBRlI7b0JBR1MsS0FIVDtzQkFJWSxDQUpaO3VCQUthLENBTGI7dUNBTTZCO3VCQUNoQjt3QkFDQyxJQUREO3VCQUVBOzs7OztlQUlYOztxQkFDUSxPQURSO3FCQUVRLE1BRlI7c0JBR1MsTUFIVDtxQkFJUSxRQUpSO3lDQUs2Qjt5QkFDaEI7NkJBQ0k7Ozs7Z0NBSWQsSUFBRDtxQkFDUSxLQURSO29CQUVPLGNBRlA7a0NBR3FCLEVBSHJCO29CQUlPOzs7O09BNURqQjs7OztFQXBCZ0NrRjs7QUFBZmdCLE9BQ1o1RixZQUFZO1FBQ1hKLFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUROO1dBRVIxRCxVQUFVUyxJQUZGO09BR1pULFVBQVVZLE1BSEU7UUFJWFosVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFoQixDQUpXO1lBS1BELFVBQVVTOzs7Ozs7O0FDbkV4QixJQUFNOEYsYUFBMEM7TUFDMUMsQ0FEMEM7TUFFMUMsQ0FGMEM7TUFHMUMsQ0FIMEM7TUFJMUMsQ0FKMEM7TUFLMUM7Q0FMTjs7QUEwQ0EsQUFBZSxTQUFTQyxJQUFULE9BZUw7d0JBZFJDLEtBY1E7TUFkUkEsS0FjUSw4QkFkQSxNQWNBO3VCQWJSQyxJQWFRO01BYlJBLElBYVEsNkJBYkQsS0FhQztNQVpSakgsUUFZUSxRQVpSQSxRQVlRO3dCQVhSc0QsS0FXUTtNQVhSQSxLQVdRLDhCQVhBLFVBV0E7eUJBVlJFLE1BVVE7TUFWUkEsTUFVUSwrQkFWQyxLQVVEO3lCQVRSMEQsTUFTUTtNQVRSQSxNQVNRLCtCQVRDLEtBU0Q7MkJBUlJDLFFBUVE7TUFSUkEsUUFRUSxpQ0FSRyxXQVFIO3VCQVBSL1MsSUFPUTtNQVBSQSxJQU9RLDZCQVBELElBT0M7TUFOUmdULE1BTVEsUUFOUkEsTUFNUTtNQUxSQyxNQUtRLFFBTFJBLE1BS1E7TUFKUkMsTUFJUSxRQUpSQSxNQUlROzBCQUhSQyxPQUdRO01BSFJBLE9BR1EsZ0NBSEUsT0FHRjsyQkFGUkMsUUFFUTtNQUZSQSxRQUVRLGlDQUZHLEtBRUg7bUNBRFJDLCtCQUNRO01BRFJBLCtCQUNRLHlDQUQwQixLQUMxQjs7TUFDRnZTLFFBQVE0UixXQUFXMVMsSUFBWCxDQUFkO01BQ01zVCxVQUFVWixXQUFXTSxNQUFYLENBQWhCO01BQ01PLFVBQVViLFdBQVdPLE1BQVgsQ0FBaEI7TUFDTU8sVUFBVWQsV0FBV1EsTUFBWCxDQUFoQjs7TUFFTTVELEtBQUtrQyxXQUNUdFMsU0FBT3lULElBREUsRUFFVHpULHNCQUFrQjRCLEtBQWxCLENBRlMsRUFHVG9TLFVBQVVoVSx3QkFBb0JzVSxPQUFwQixDQUhELEVBSVRQLFVBQVUvVCx3QkFBb0JxVSxPQUFwQixDQUpELEVBS1RQLFVBQVU5VCx3QkFBb0JvVSxPQUFwQixDQUxELEVBTVRwRSxVQUFVLE1BQVYsSUFBb0JqSSxPQUFPd00sSUFObEIsRUFPVHZFLFVBQVUsVUFBVixJQUF3QmpJLE9BQU95TSxRQVB0QixFQVFUeEUsVUFBVSxVQUFWLElBQXdCakksT0FBTzBNLFFBUnRCLEVBU1R6RSxVQUFVLE1BQVYsSUFBb0JqSSxPQUFPMk0sSUFUbEIsRUFVVDFFLFVBQVUsT0FBVixJQUFxQmpJLE9BQU80TSxLQVZuQixFQVdUM0UsVUFBVSxXQUFWLElBQXlCakksT0FBTzZNLFNBWHZCLEVBWVQ1RSxVQUFVLFFBQVYsSUFBc0JqSSxPQUFPOE0sTUFacEIsRUFhVDdFLFVBQVUsVUFBVixJQUF3QmpJLE9BQU8rTSxRQWJ0QixFQWNUOUUsVUFBVSxNQUFWLElBQW9CakksT0FBT2dOLElBZGxCLEVBZVQvRSxVQUFVLE9BQVYsSUFBcUJqSSxPQUFPaU4sS0FmbkIsRUFnQlRoRixVQUFVLFFBQVYsSUFBc0JqSSxPQUFPa04sTUFoQnBCLEVBaUJUakYsVUFBVSxRQUFWLElBQXNCakksT0FBT21OLE1BakJwQixFQWtCVGxGLFVBQVUsTUFBVixJQUFvQmpJLE9BQU9vTixJQWxCbEIsRUFtQlRuRixVQUFVLFFBQVYsSUFBc0JqSSxPQUFPcU4sTUFuQnBCLEVBb0JUcEYsVUFBVSxLQUFWLElBQW1CakksT0FBT3NOLEdBcEJqQixFQXFCVHJGLFVBQVUsWUFBVixJQUEwQmpJLE9BQU91TixVQXJCeEIsRUFzQlR0RixVQUFVLE9BQVYsSUFBcUJqSSxPQUFPd04sS0F0Qm5CLEVBdUJUdEIsWUFBWSxPQUFaLElBQXVCckIsV0FBVzRDLFlBdkJ6QixFQXdCVCxDQUFDdkIsWUFBWSxNQUFaLElBQXNCRSwrQkFBdkIsS0FDRXZCLFdBQVc2QyxXQXpCSixFQTBCVC9CLFVBQVUsUUFBVixJQUFzQmQsV0FBVzhDLFdBMUJ4QixFQTJCVGhDLFVBQVUsU0FBVixJQUF1QmQsV0FBVytDLFlBM0J6QixFQTRCVGpDLFVBQVUsTUFBVixJQUFvQmQsV0FBV2dELFNBNUJ0QixFQTZCVGxDLFVBQVUsT0FBVixJQUFxQmQsV0FBV2lELFVBN0J2QixFQThCVGhDLGFBQWEsV0FBYixJQUE0QmpCLFdBQVdrRCxTQTlCOUIsRUErQlRsQyxVQUFVaEIsV0FBV21ELGVBL0JaLEVBZ0NULENBQUNuQyxNQUFELElBQVdoQixXQUFXb0QsZUFoQ2IsRUFpQ1RyQyxRQUFRZixXQUFXSSxjQWpDVixFQWtDVCxDQUFDVyxJQUFELElBQVNmLFdBQVdxRCxnQkFsQ1gsRUFtQ1QvQixZQUFZdEIsV0FBV3NCLFFBbkNkLENBQVg7TUFxQ01nQyxNQUFNaEcsU0FBUyxNQUFULEdBQWtCLEtBQTlCOztTQUdFbkQ7T0FBQTs7aUJBQ2FxRDtPQUNOOEQsWUFBWSxPQUFPeEgsUUFBUCxLQUFvQixRQUFoQyxHQUNELEVBQUV5SixPQUFPekosUUFBVCxFQURDLEdBRUQsSUFKTjs7R0FERjs7O0FBWUYrRyxLQUFLcEcsU0FBTCxHQUFpQjttQ0FDa0JKLFVBQVVTLElBRDVCO1NBRVJULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixTQUE1QixDQUFoQixDQUZRO1FBR1RELFVBQVVTLElBSEQ7WUFJTFQsVUFBVUssSUFKTDtTQUtSTCxVQUFVQyxLQUFWLENBQWdCLENBQ3JCLE9BRHFCLEVBRXJCLE1BRnFCLEVBR3JCLE9BSHFCLEVBSXJCLE1BSnFCLEVBS3JCLE1BTHFCLEVBTXJCLFVBTnFCLEVBT3JCLFFBUHFCLEVBUXJCLFFBUnFCLEVBU3JCLFVBVHFCLEVBVXJCLFFBVnFCLEVBV3JCLFlBWHFCLEVBWXJCLFFBWnFCLEVBYXJCLFVBYnFCLEVBY3JCLE1BZHFCLEVBZXJCLFdBZnFCLEVBZ0JyQixLQWhCcUIsRUFpQnJCLE9BakJxQixDQUFoQixDQUxRO1VBd0JQRCxVQUFVUyxJQXhCSDtVQXlCUFQsVUFBVVMsSUF6Qkg7V0EwQk5ULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxDQUFoQixDQTFCTTtVQTJCUEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTNCTztVQTRCUEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTVCTztZQTZCTEQsVUFBVUMsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxXQUFYLENBQWhCLENBN0JLO1FBOEJURCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhCLENBOUJTO1VBK0JQRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhCLENBL0JPO1lBZ0NMRCxVQUFVUztDQWhDdEI7O0FDdEdlLFNBQVMwSSxNQUFULENBQWdCdlYsS0FBaEIsRUFBOEI7OztNQUV6Q3dWLHFCQUZ5QyxHQWF2Q3hWLEtBYnVDLENBRXpDd1YscUJBRnlDO01BR3pDQyxxQkFIeUMsR0FhdkN6VixLQWJ1QyxDQUd6Q3lWLHFCQUh5QztNQUl6Q3ZHLGtCQUp5QyxHQWF2Q2xQLEtBYnVDLENBSXpDa1Asa0JBSnlDO3FCQWF2Q2xQLEtBYnVDLENBS3pDbVAsS0FMeUM7TUFLekNBLEtBTHlDLGdDQUtqQyxNQUxpQzt3QkFhdkNuUCxLQWJ1QyxDQU16QzBWLFFBTnlDO01BTXpDQSxRQU55QyxtQ0FNOUIsS0FOOEI7c0JBYXZDMVYsS0FidUMsQ0FPekNxUCxNQVB5QztNQU96Q0EsTUFQeUMsaUNBT2hDLEtBUGdDO01BUXpDL04sSUFSeUMsR0FhdkN0QixLQWJ1QyxDQVF6Q3NCLElBUnlDO01BU3pDcVUsT0FUeUMsR0FhdkMzVixLQWJ1QyxDQVN6QzJWLE9BVHlDO29CQWF2QzNWLEtBYnVDLENBVXpDQyxJQVZ5QztNQVV6Q0EsSUFWeUMsK0JBVWxDLElBVmtDO01BV3pDMlYsSUFYeUMsR0FhdkM1VixLQWJ1QyxDQVd6QzRWLElBWHlDO29CQWF2QzVWLEtBYnVDLENBWXpDNlYsSUFaeUM7TUFZekNBLElBWnlDLCtCQVlsQyxRQVprQzs7O01BZXJDQyxZQUFZO1VBQ1YsT0FEVTtVQUVWLFVBRlU7U0FHWCxPQUhXO2lCQUlILE9BSkc7V0FLVDtHQUxUOztNQVFNQyxVQUFVdkcsV0FBV3JRLFNBQU82VyxNQUFsQixpREFDYjdXLFNBQU84VyxFQURNLEVBQ0RoVyxTQUFTLElBRFIsK0JBRWJkLFNBQU8rVyxFQUZNLEVBRURqVyxTQUFTLElBRlIsK0JBR2JkLFNBQU9nWCxFQUhNLEVBR0RsVyxTQUFTLElBSFIsK0JBSWJkLFNBQU9pWCxLQUpNLEVBSUVqSCxVQUFVLGFBSlosK0JBS2JoUSxTQUFPZ1EsS0FBUCxDQUxhLEVBS0csQ0FBQ3VHLFFBTEosK0JBTWJ2VyxTQUFPdVcsUUFOTSxFQU1LQSxRQU5MLCtCQU9idlcsU0FBT2tYLE9BUE0sRUFPSSxDQUFDWCxRQVBMLCtCQVFidlcsU0FBT2tRLE1BUk0sRUFRR0EsTUFSSCwrQkFTYmxRLFNBQU9tWCxLQVRNLEVBU0UsQ0FBQ2pILE1BVEgsZ0JBQWhCOzs7U0FjRW5EOzs7dUJBQ2lCc0oscUJBRGpCO3VCQUVpQkMscUJBRmpCO29CQUdjdkcsa0JBSGQ7aUJBSWE2RyxPQUpiO2dCQUtZTCxRQUxaO1lBTVFwVSxJQU5SOzs7Ozs7Ozs7OztRQU9XO2VBQVNxVSxXQUFXQSxRQUFRLEVBQUVZLFlBQUYsRUFBUixDQUFwQjtPQUFULENBUEY7WUFRUVY7OztVQUVOOztlQUNRLFFBRFI7a0JBQUE7ZUFHU0gsV0FBVyxNQUFYLEdBQW9CSSxVQUFVM0csS0FBVixDQUg3QjtrQkFJVyxRQUpYO2NBS1FsUDs7OztHQWhCWjs7OztBQXlCRnNWLE9BQU8vSSxTQUFQLEdBQW1CO3lCQUNNSixVQUFVUyxJQURoQjt5QkFFTVQsVUFBVVMsSUFGaEI7c0JBR0dULFVBQVVZLE1BSGI7U0FJVlosVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLEtBQWpCLEVBQXdCLGFBQXhCLEVBQXVDLE9BQXZDLENBQWhCLENBSlU7WUFLUEQsVUFBVVMsSUFMSDtVQU1UVCxVQUFVUyxJQU5EO1FBT1hULFVBQVVZLE1BUEM7V0FRUlosVUFBVWlGLElBUkY7UUFTWGpGLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsQ0FBaEIsQ0FUVztRQVVYRCxVQUFVWSxNQUFWLENBQWlCOEMsVUFWTjtRQVdYMUQsVUFBVUMsS0FBVixDQUFnQixDQUFDLFFBQUQsRUFBVyxRQUFYLENBQWhCO0NBWFI7Ozs7SUMvRHFCbUs7Ozs7Ozs7Ozs7Ozs7O2lMQVNuQm5FLFFBQWU7ZUFDSjthQUdYb0UsbUJBQW1CLFVBQUNGLEtBQUQsRUFBZ0Q7VUFDekRHLFlBRHlELEdBQ3hDLE1BQUsxVyxLQURtQyxDQUN6RDBXLFlBRHlEOztZQUU1RG5FLFFBQUwsQ0FDRSxFQUFFb0UsU0FBUyxJQUFYLEVBREYsRUFFRUQsZ0JBQWlCO2VBQU1BLGFBQWEsRUFBRUgsWUFBRixFQUFiLENBQU47T0FGbkI7YUFNRkssbUJBQW1CLFVBQUNMLEtBQUQsRUFBZ0Q7VUFDekRNLFlBRHlELEdBQ3hDLE1BQUs3VyxLQURtQyxDQUN6RDZXLFlBRHlEOztZQUU1RHRFLFFBQUwsQ0FDRSxFQUFFb0UsU0FBUyxLQUFYLEVBREYsRUFFRUUsZ0JBQWlCO2VBQU1BLGFBQWEsRUFBRU4sWUFBRixFQUFiLENBQU47T0FGbkI7Ozs7Ozs2QkFNTzttQkFDNkIsS0FBS3ZXLEtBRGxDO1VBQ0M4VyxNQURELFVBQ0NBLE1BREQ7VUFDU2pMLFFBRFQsVUFDU0EsUUFEVDtVQUNtQjRFLEtBRG5CLFVBQ21CQSxLQURuQjtVQUVDa0csT0FGRCxHQUVhLEtBQUt0RSxLQUZsQixDQUVDc0UsT0FGRDs7O1VBSURaLFVBQVV2RyxXQUFXclEsU0FBTzRYLElBQWxCLHFCQUdiNVgsU0FBTzZYLEtBSE0sRUFHRUYsVUFBV0EsVUFBVSxJQUFWLElBQWtCSCxPQUgvQixFQUFoQjs7YUFPRXpLO1dBQUE7O3dCQUNnQixLQUFLdUssZ0JBRHJCO3dCQUVnQixLQUFLRyxnQkFGckI7b0JBR1c7O2lCQUVDMUs7YUFBQTtZQUFLLGNBQWMsQ0FBbkI7O1NBTFo7O2FBTUU7OztTQU5GO3FDQU9PLFdBQVc2SixPQUFoQjtPQVJKOzs7O0VBdkM4QjNFOztBQUFib0YsS0FDWmhLLFlBQVk7VUFDVEosVUFBVVMsSUFERDtZQUVQVCxVQUFVSyxJQUZIO1NBR1ZMLFVBQVVLLElBSEE7Z0JBSUhMLFVBQVVpRixJQUpQO2dCQUtIakYsVUFBVWlGOzs7OztJQ0RQNEY7Ozs7Ozs7Ozs7Ozs7O3lMQW9CbkI1RSxRQUFRO2VBQ0c7YUFxQlg2RSxlQUFlLFVBQUNYLEtBQUQsRUFBa0M7VUFDdkNZLE9BRHVDLEdBQzNCWixNQUFNYSxNQURxQixDQUN2Q0QsT0FEdUM7O1lBRTFDblgsS0FBTCxDQUFXcVgsUUFBWCxDQUFvQixFQUFFZCxZQUFGLEVBQVNZLGdCQUFULEVBQXBCO2FBR0ZHLGFBQWE7YUFBTSxNQUFLL0UsUUFBTCxDQUFjLEVBQUVnRixTQUFTLEtBQVgsRUFBZCxDQUFOO2FBRWJDLGNBQWM7YUFBTSxNQUFLakYsUUFBTCxDQUFjLEVBQUVnRixTQUFTLElBQVgsRUFBZCxDQUFOOzs7Ozs7d0NBekJNO1VBQ2QsS0FBS3ZYLEtBQUwsQ0FBV3lYLGFBQWYsRUFBOEI7YUFDdkJDLGdCQUFMLENBQXNCLENBQUMsQ0FBQyxLQUFLMVgsS0FBTCxDQUFXeVgsYUFBbkM7Ozs7O3VDQUllRSxlQUFzQjtVQUNuQ0EsY0FBY0YsYUFBZCxLQUFnQyxLQUFLelgsS0FBTCxDQUFXeVgsYUFBL0MsRUFBOEQ7YUFDdkRDLGdCQUFMLENBQXNCLENBQUMsQ0FBQyxLQUFLMVgsS0FBTCxDQUFXeVgsYUFBbkM7Ozs7O3FDQUlhQSxlQUF3QjtVQUNuQyxLQUFLRyxLQUFULEVBQWdCO2FBQ1RBLEtBQUwsQ0FBV0gsYUFBWCxHQUEyQkEsYUFBM0I7Ozs7OzZCQWVLOzs7OzttQkFTSCxLQUFLelgsS0FURjtVQUVMbVgsT0FGSyxVQUVMQSxPQUZLO1VBR0x6QixRQUhLLFVBR0xBLFFBSEs7VUFJTG1DLFFBSkssVUFJTEEsUUFKSztVQUtMQyxFQUxLLFVBS0xBLEVBTEs7VUFNTEwsYUFOSyxVQU1MQSxhQU5LO1VBT0xuVyxJQVBLLFVBT0xBLElBUEs7VUFRTHJCLElBUkssVUFRTEEsSUFSSzs7O1VBV0g4WCxjQUFjNVksU0FBTzZZLE1BQXpCO1VBQ0ksQ0FBQ3RDLFFBQUQsS0FBY3lCLFdBQVdNLGFBQXpCLENBQUosRUFBNkM7c0JBQzdCdFksU0FBTzhZLFVBQXJCO09BREYsTUFFTyxJQUFJSixRQUFKLEVBQWM7c0JBQ0wxWSxTQUFPK1ksV0FBckI7OzthQUlBaE07V0FBQTtVQUFLLFVBQVMsVUFBZDs7bUJBRWFpTCxPQURYO3FCQUVhM0gsV0FBV3JRLFNBQU95WSxLQUFsQixpREFDUnpZLFNBQU9nWixZQURDLEVBQ2MsQ0FBQ3pDLFFBRGYsK0JBRVJ2VyxTQUFPc1ksYUFGQyxFQUVlQSxhQUZmLCtCQUdSdFksU0FBT2laLE9BSEMsRUFHU25ZLFNBQVMsSUFIbEIsK0JBSVJkLFNBQU9rWixPQUpDLEVBSVNwWSxTQUFTLElBSmxCLGdCQUZiO29CQVFZeVYsUUFSWjtjQVNNb0MsRUFUTjtnQkFVUXhXLElBVlI7a0JBV1UsS0FBS2dXLFVBWGY7b0JBWVksS0FBS0osWUFaakI7bUJBYVcsS0FBS00sV0FiaEI7ZUFjTyxpQkFBTTttQkFDSkksS0FBTCxHQUFhVSxFQUFiO1dBZko7Z0JBaUJPO1VBbEJUOzs7O3VCQXFCZTlJLFdBQ1R1SSxXQURTLEVBRVQ1WSxTQUFPb1osS0FGRTs7dUJBS0xwQixXQUFXTSxhQUFYLEdBQTJCdlEsT0FBT0ksTUFBbEMsR0FBMkNKLE9BQU9PLFdBRHRELEdBRUkwUCxXQUFXTSxhQUFYLEdBQTJCdlEsT0FBT0UsVUFBbEMsR0FBK0NGLE9BQU9RLE9BTmpELG1EQVFOdkksU0FBT3FaLFlBUkQsRUFRZ0IsQ0FBQzlDLFFBUmpCLGdDQVNOdlcsU0FBT3NaLFlBVEQsRUFTZ0IsS0FBS3BHLEtBQUwsQ0FBV2tGLE9BVDNCLGdDQVVOcFksU0FBT3VaLE9BVkQsRUFVV3pZLFNBQVMsSUFWcEIsZ0NBV05kLFNBQU93WixPQVhELEVBV1cxWSxTQUFTLElBWHBCOztXQWVUa1gsV0FBV00sYUFBWixLQUNDdkwsb0JBQUMsSUFBRDtnQ0FDcUIsRUFEckI7bUJBRVEsT0FGUjtrQkFHUXVMLGdCQUFnQixNQUFoQixHQUF5QixPQUhqQztrQkFJUXhYLFNBQVMsSUFBVCxHQUFnQixDQUFoQixHQUFvQjs7O09BMUNwQzs7OztFQXZFa0NtUjs7QUFBakI2RixTQUNaekssWUFBWTtXQUNSSixVQUFVUyxJQURGO1lBRVBULFVBQVVTLElBRkg7WUFHUFQsVUFBVVMsSUFISDtNQUliVCxVQUFVWSxNQUFWLENBQWlCOEMsVUFKSjtpQkFLRjFELFVBQVVTLElBTFI7UUFNWFQsVUFBVVksTUFOQztZQU9QWixVQUFVaUYsSUFBVixDQUFldkIsVUFQUjtRQVFYMUQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLENBQWhCOztBQVRXNEssU0FZWjNGLGVBQWU7V0FDWCxLQURXO1lBRVYsS0FGVTtZQUdWLEtBSFU7aUJBSUwsS0FKSztRQUtkOzs7SUNrQldzSDs7Ozs7Ozs7Ozs2QkF3QlY7bUJBQ3FELEtBQUs1WSxLQUQxRDtVQUNDNlksSUFERCxVQUNDQSxJQUREO1VBQ08zUyxTQURQLFVBQ09BLE1BRFA7c0NBQ2U0UyxXQURmO1VBQ2VBLFdBRGYsc0NBQzZCLENBRDdCO3VDQUNnQ0MsWUFEaEM7VUFDZ0NBLFlBRGhDLHVDQUMrQyxDQUQvQzs7OztVQUlEOU4sUUFBUWhLLEtBQUsrWCxHQUFMLCtCQUFZOVMsVUFBT3BHLEdBQVAsQ0FBVztlQUFRbVosS0FBSzNQLElBQUwsR0FBWTJQLEtBQUtoTyxLQUF6QjtPQUFYLENBQVosRUFBZDtVQUNNeEMsU0FBU3hILEtBQUsrWCxHQUFMLCtCQUFZOVMsVUFBT3BHLEdBQVAsQ0FBVztlQUFRbVosS0FBSzdQLEdBQUwsR0FBVzZQLEtBQUt4USxNQUF4QjtPQUFYLENBQVosRUFBZjs7O29CQUcyRCxLQUFLekksS0FSekQ7MENBUUNrWixhQVJEO1VBUUNBLGFBUkQseUNBUWlCak8sS0FSakI7MENBUXdCa08sY0FSeEI7VUFRd0JBLGNBUnhCLHlDQVF5QzFRLE1BUnpDOzs7OztVQVlEMlEsUUFBUWxULFVBQU85RyxNQUFQLENBQWMsVUFBQ3NNLEdBQUQsRUFBTTJOLFFBQU4sRUFBZ0JDLEdBQWhCLEVBQXdCO1lBRWhERCxTQUFTalEsR0FBVCxHQUFlaVEsU0FBUzVRLE1BQXhCLEdBQWlDcVEsV0FBakMsSUFDQU8sU0FBU2pRLEdBQVQsR0FBZStQLGlCQUFpQkwsV0FEaEMsSUFFQU8sU0FBUy9QLElBQVQsR0FBZ0I0UCxnQkFBZ0JILFlBRmhDLElBR0FNLFNBQVMvUCxJQUFULEdBQWdCK1AsU0FBU3BPLEtBQXpCLEdBQWlDOE4sWUFKbkMsRUFLRTtjQUNJUSxJQUFKLFlBQVdELFFBQVgsSUFBbUJELFFBQW5COztlQUVLM04sR0FBUDtPQVRZLEVBVVgsRUFWVyxDQUFkOzthQWFFUTs7VUFBSyxXQUFXc04sT0FBYW5QLFFBQTdCLEVBQXVDLE9BQU8sRUFBRVksWUFBRixFQUFTeEMsY0FBVCxFQUE5QztjQUNTM0ksR0FBTixDQUFVO2NBQUd3WixHQUFILFFBQUdBLEdBQUg7Y0FBVy9ZLEtBQVg7aUJBQ1QyTDs7Y0FBSyxLQUFLb04sR0FBVixFQUFlLFdBQVdFLE9BQWFwUCxRQUF2QyxFQUFpRCxPQUFPN0osS0FBeEQ7Z0NBQ0csSUFBRCxJQUFNLEtBQUsrWSxHQUFYO1dBRk87U0FBVjtPQUZMOzs7O0VBaERvQ2xJOztBQUFuQndILFdBQ1pwTSxZQUFZOztRQUVYSixVQUFVcU4sR0FGQztVQUdUck4sVUFBVXNOLE9BQVYsQ0FDTnROLFVBQVVNLEtBQVYsQ0FBZ0I7U0FDVE4sVUFBVVUsTUFBVixDQUFpQmdELFVBRFI7VUFFUjFELFVBQVVVLE1BQVYsQ0FBaUJnRCxVQUZUO1dBR1AxRCxVQUFVVSxNQUFWLENBQWlCZ0QsVUFIVjtZQUlOMUQsVUFBVVUsTUFBVixDQUFpQmdEO0dBSjNCLEVBS0dBLFVBTkcsQ0FIUztrQkFXRDFELFVBQVVVLE1BWFQ7Z0JBWUhWLFVBQVVVLE1BWlA7ZUFhSlYsVUFBVVUsTUFiTjtpQkFjRlYsVUFBVVU7O0FBZlI4TCxXQWtCWnRILGVBQWU7VUFDWixFQURZO2dCQUVOLENBRk07ZUFHUDs7O0FDekVqQjs7Ozs7Ozs7Ozs7O0FBWUEsSUFBTXFJLEtBQUssQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFYO0FBQ0EsSUFBTUMsT0FBTyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQWI7QUFDQSxJQUFNQyxNQUFNLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBWjtBQUNBLElBQU1DLGVBQWUsU0FBZkEsWUFBZSxDQUFDQyxZQUFELEVBQThCO1VBQ3pDQSxZQUFSO1NBQ08sQ0FBTDthQUNTLENBQUMsQ0FBQ0YsR0FBRCxDQUFELEVBQVEsQ0FBQ0YsRUFBRCxDQUFSLEVBQWMsQ0FBQ0MsSUFBRCxDQUFkLENBQVA7U0FDRyxDQUFMO2FBQ1MsQ0FBQyxDQUFDRCxFQUFELEVBQUtFLEdBQUwsQ0FBRCxFQUFZLENBQUNELElBQUQsRUFBT0MsR0FBUCxDQUFaLEVBQXlCLENBQUNBLEdBQUQsRUFBTUYsRUFBTixDQUF6QixFQUFvQyxDQUFDRSxHQUFELEVBQU1ELElBQU4sQ0FBcEMsQ0FBUDtTQUNHLENBQUw7YUFDUyxDQUNMLENBQUNDLEdBQUQsRUFBTUYsRUFBTixFQUFVRSxHQUFWLEVBQWVBLEdBQWYsQ0FESyxFQUVMLENBQUNBLEdBQUQsRUFBTUQsSUFBTixFQUFZQyxHQUFaLEVBQWlCQSxHQUFqQixDQUZLLEVBR0wsQ0FBQ0EsR0FBRCxFQUFNQSxHQUFOLEVBQVdGLEVBQVgsRUFBZUUsR0FBZixDQUhLLEVBSUwsQ0FBQ0EsR0FBRCxFQUFNQSxHQUFOLEVBQVdELElBQVgsRUFBaUJDLEdBQWpCLENBSkssRUFLTCxDQUFDQSxHQUFELEVBQU1GLEVBQU4sRUFBVUUsR0FBVixFQUFlRCxJQUFmLENBTEssRUFNTCxDQUFDQyxHQUFELEVBQU1ELElBQU4sRUFBWUMsR0FBWixFQUFpQkYsRUFBakIsQ0FOSyxDQUFQO1NBUUcsQ0FBTDs7YUFFUyxDQUNMLENBQUNFLEdBQUQsRUFBTUYsRUFBTixFQUFVRSxHQUFWLENBREssRUFFTCxDQUFDQSxHQUFELEVBQU1ELElBQU4sRUFBWUMsR0FBWixDQUZLLEVBR0wsQ0FBQ0EsR0FBRCxFQUFNQSxHQUFOLEVBQVdGLEVBQVgsQ0FISyxFQUlMLENBQUNFLEdBQUQsRUFBTUEsR0FBTixFQUFXRCxJQUFYLENBSkssQ0FBUDs7Q0FqQk47O0FBMEJBLElBQU1JLGFBQWEsU0FBYkEsVUFBYSxDQUFDQyxNQUFELEVBQVNDLFNBQVQ7U0FDakJBLFVBQVVwYSxHQUFWLENBQWM7UUFBR3NKLEdBQUgsUUFBR0EsR0FBSDtRQUFRRSxJQUFSLFFBQVFBLElBQVI7UUFBYzJCLEtBQWQsUUFBY0EsS0FBZDtRQUFxQnhDLE1BQXJCLFFBQXFCQSxNQUFyQjtXQUFtQztjQUFBO2dCQUFBO2FBR3hDd0MsUUFBUWdQLE1BSGdDO2NBSXZDeFIsU0FBU3dSO0tBSkw7R0FBZCxDQURpQjtDQUFuQjs7QUFRQSxJQUFNRSxTQUFTLFNBQVRBLE1BQVM7U0FDYjdPLElBQUlsTSxNQUFKLENBQVcsVUFBQ2diLFFBQUQsRUFBV25CLElBQVgsRUFBaUJvQixDQUFqQjtXQUF3QnBCLE9BQU8zTixJQUFJOE8sUUFBSixDQUFQLEdBQXVCQyxDQUF2QixHQUEyQkQsUUFBbkQ7R0FBWCxFQUF5RSxDQUF6RSxDQURhO0NBQWY7O0FBR0EsSUFBTUUsNkJBQTZCLFNBQTdCQSwwQkFBNkIsQ0FBQ1AsWUFBRDtTQUNqQ0EsaUJBQWlCLENBQWpCLEdBQXFCLENBQXJCLEdBQXlCLENBRFE7Q0FBbkM7O0FBR0EsU0FBU1EsZ0JBQVQsUUFjRztNQWJETixNQWFDLFNBYkRBLE1BYUM7TUFaRE8sS0FZQyxTQVpEQSxLQVlDO01BWFFDLE9BV1IsU0FYREMsT0FXQztNQVZPQyxDQVVQLFNBVkRsUyxNQVVDO01BVE1tUyxDQVNOLFNBVEQzUCxLQVNDO01BUkQ0UCxTQVFDLFNBUkRBLFNBUUM7O01BQ0dYLFlBQVksRUFBaEI7TUFDTWpQLFFBQVEyUCxJQUFJWCxNQUFsQjtNQUNNeFIsU0FBU2tTLElBQUlWLE1BQW5COzs7Ozs7TUFNTWEsV0FBV04sUUFBUUYsMkJBQTJCRyxPQUEzQixDQUFSLEdBQThDQSxPQUEvRDs7O01BR01DLFVBQVVaLGFBQWFnQixRQUFiLENBQWhCO01BQ01DLFlBQVlGLFlBQVlILFFBQVFwYSxNQUF0QztNQUNNNEYsU0FBU3dVLFFBQVFLLFNBQVIsQ0FBZjs7Ozs7O01BTU1DLGFBQWEsSUFBSXBiLEtBQUosQ0FBVWtiLFFBQVYsRUFBb0JHLElBQXBCLENBQXlCLENBQXpCLENBQW5CO01BQ01DLFlBQVksSUFBSXRiLEtBQUosQ0FBVWtiLFFBQVYsRUFBb0JHLElBQXBCLENBQXlCLENBQXpCLENBQWxCOzs7O09BSUssSUFBSVosSUFBSSxDQUFiLEVBQWdCQSxJQUFJLElBQUlTLFFBQXhCLEVBQWtDVCxLQUFLLENBQXZDLEVBQTBDO1FBQ2xDYyxNQUFNaEIsT0FBT2EsVUFBUCxDQUFaO1FBQ01JLFNBQVNGLFVBQVVDLEdBQVYsQ0FBZjtRQUNNRSxhQUFhblYsT0FBT2lWLEdBQVAsRUFBWUMsTUFBWixJQUFzQjNTLE1BQXpDOztjQUVVOFEsSUFBVixDQUFlO1dBQ1J5QixXQUFXRyxHQUFYLENBRFE7WUFFUEEsT0FBT2xRLFFBQVF3UCxPQUFmLENBRk87YUFHTnhQLFFBQVF3UCxPQUhGO2NBSUxZO0tBSlY7O2VBT1dGLEdBQVgsS0FBbUJFLFVBQW5CO2NBQ1VGLEdBQVYsS0FBa0IsQ0FBbEI7Ozs7O01BS0VYLEtBQUosRUFBVztRQUNIYyxrQkFBa0JyYSxLQUFLc2EsSUFBTCxDQUFVZCxVQUFVLENBQXBCLEtBQTBCeFAsUUFBUXdQLE9BQWxDLENBQXhCO2dCQUNZUCxVQUFVcGEsR0FBVixDQUFjOzBCQUNyQnVaLFFBRHFCO2NBRWxCaUMsa0JBQWtCakMsU0FBUy9QOztLQUZ2QixDQUFaO2NBSVVrUyxPQUFWLENBQWtCLEVBQUVwUyxLQUFLLENBQVAsRUFBVUUsTUFBTSxDQUFoQixFQUFtQjJCLE9BQU9xUSxlQUExQixFQUEyQzdTLGNBQTNDLEVBQWxCOzs7Ozs7TUFNRXdSLE1BQUosRUFBWTtnQkFDRUQsV0FBV0MsTUFBWCxFQUFtQkMsU0FBbkIsQ0FBWjs7O1NBR0tBLFNBQVA7OztBQWlCRixBQUFlLFNBQVN1QixPQUFULENBQWlCemIsS0FBakIsRUFBK0I7TUFFMUMwYSxPQUYwQyxHQVN4QzFhLEtBVHdDLENBRTFDMGEsT0FGMEM7TUFHMUNGLEtBSDBDLEdBU3hDeGEsS0FUd0MsQ0FHMUN3YSxLQUgwQztNQUkxQ1AsTUFKMEMsR0FTeENqYSxLQVR3QyxDQUkxQ2lhLE1BSjBDO01BSzFDeFIsTUFMMEMsR0FTeEN6SSxLQVR3QyxDQUsxQ3lJLE1BTDBDO01BTTFDb1MsU0FOMEMsR0FTeEM3YSxLQVR3QyxDQU0xQzZhLFNBTjBDO01BTzFDYSxXQVAwQyxHQVN4QzFiLEtBVHdDLENBTzFDMGIsV0FQMEM7TUFRMUN6USxLQVIwQyxHQVN4Q2pMLEtBVHdDLENBUTFDaUwsS0FSMEM7O01BVXRDaVAsWUFBWUssaUJBQWlCO29CQUFBO1dBRTFCLENBQUMsQ0FBQ0MsS0FGd0I7Z0JBQUE7a0JBQUE7WUFLekJQLFVBQVUsQ0FMZTtlQU10QlksYUFBYTtHQU5SLENBQWxCO1NBU0UzTyxvQkFBQyxVQUFEO1VBQ1E7VUFBUXlQLEtBQVIsU0FBR3JDLEdBQUg7YUFDSm9DLFlBQVk7b0JBQUE7ZUFFSHhCLFVBQVV5QixLQUFWLEVBQWlCMVEsS0FGZDtnQkFHRmlQLFVBQVV5QixLQUFWLEVBQWlCbFQ7T0FIM0IsQ0FESTtLQURSO1lBUVV5UjtJQVRaOzs7QUFjRnVCLFFBQVFqUCxTQUFSLEdBQW9CO1dBQ1RKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBaEIsRUFBMkJ5RCxVQURsQjtTQUVYMUQsVUFBVVMsSUFGQztVQUdWVCxVQUFVVSxNQUhBO1VBSVZWLFVBQVVVLE1BQVYsQ0FBaUJnRCxVQUpQO2FBS1AxRCxVQUFVVSxNQUxIO2VBTUxWLFVBQVVpRixJQUFWLENBQWV2QixVQU5WO1NBT1gxRCxVQUFVVSxNQUFWLENBQWlCZ0Q7Q0FQMUI7Ozs7QUMvSmUsU0FBUzhMLE1BQVQsQ0FBZ0I1YixLQUFoQixFQUFvQztNQUN6QzZMLFFBRHlDLEdBQzVCN0wsS0FENEIsQ0FDekM2TCxRQUR5Qzs7TUFFM0MwRCxLQUFLQyxXQUNULENBQUN4UCxNQUFNNmIsRUFBTixLQUFhak0sU0FBYixJQUNDNVAsTUFBTWlXLEVBQU4sS0FBYXJHLFNBRGQsSUFFQzVQLE1BQU1rVyxFQUFOLEtBQWF0RyxTQUZkLElBR0M1UCxNQUFNbVcsRUFBTixLQUFhdkcsU0FIZixLQUlFelEsU0FBTzJjLGdCQUxBLEVBTVQ5YixNQUFNNmIsRUFBTixJQUFZMWMsbUJBQWVhLE1BQU02YixFQUFyQixDQU5ILEVBT1Q3YixNQUFNaVcsRUFBTixJQUFZOVcsbUJBQWVhLE1BQU1pVyxFQUFyQixDQVBILEVBUVRqVyxNQUFNa1csRUFBTixJQUFZL1csbUJBQWVhLE1BQU1rVyxFQUFyQixDQVJILEVBU1RsVyxNQUFNbVcsRUFBTixJQUFZaFgsbUJBQWVhLE1BQU1tVyxFQUFyQixDQVRILEVBVVRuVyxNQUFNK2IsSUFBTixJQUFjLElBQWQsSUFBc0I1YyxtQkFBZWEsTUFBTStiLElBQXJCLENBVmIsRUFXVC9iLE1BQU1nYyxNQUFOLElBQWdCLElBQWhCLElBQXdCN2MsbUJBQWVhLE1BQU1nYyxNQUFyQixDQVhmLEVBWVRoYyxNQUFNaWMsTUFBTixJQUFnQixJQUFoQixJQUF3QjljLG1CQUFlYSxNQUFNaWMsTUFBckIsQ0FaZixFQWFUamMsTUFBTWtjLE1BQU4sSUFBZ0IsSUFBaEIsSUFBd0IvYyxtQkFBZWEsTUFBTWtjLE1BQXJCLENBYmYsQ0FBWDtTQWVPaFE7O01BQUssV0FBV3FELEVBQWhCOztHQUFQOzs7QUFHRnFNLE9BQU9wUCxTQUFQLEdBQW1CO1lBQ1BKLFVBQVVLLElBREg7TUFFYkwsVUFBVVUsTUFGRztNQUdiVixVQUFVVSxNQUhHO01BSWJWLFVBQVVVLE1BSkc7TUFLYlYsVUFBVVUsTUFMRztRQU1YVixVQUFVVSxNQU5DO1VBT1RWLFVBQVVVLE1BUEQ7VUFRVFYsVUFBVVUsTUFSRDtVQVNUVixVQUFVVTtDQVRwQjs7QUNwQ2UsU0FBU3FQLFNBQVQsQ0FBbUJuYyxLQUFuQixFQUFpQztNQUN0QzZMLFFBRHNDLEdBQ3pCN0wsS0FEeUIsQ0FDdEM2TCxRQURzQzs7U0FHNUNLO09BQUE7TUFBSyxnQkFBZSxRQUFwQixFQUE2QixTQUFRLE1BQXJDOztTQUNFO1FBQUssVUFBVSxHQUFmLEVBQW9CLE9BQU0sTUFBMUI7OztHQUZKOzs7QUFTRmlRLFVBQVUzUCxTQUFWLEdBQXNCO1lBQ1ZKLFVBQVVLO0NBRHRCOzs7O0FDaEJlLFNBQVMyUCxPQUFULEdBQW1CO1NBQ3pCbFEsNEJBQUksV0FBVy9NLFNBQU9rZCxPQUF0QixHQUFQOzs7QUNHYSxTQUFTQyxLQUFULENBQWV0YyxLQUFmLEVBQTZCO01BQ2xDdWMsU0FEa0MsR0FDcEJ2YyxLQURvQixDQUNsQ3VjLFNBRGtDOztNQUV0QzdNLGFBQUo7VUFDUTZNLFNBQVI7U0FDTyxJQUFMO2FBQ1MsbUJBQVA7O1NBRUcsT0FBTDthQUNTLHFCQUFQOztTQUVHLE1BQUw7YUFDUyxxQkFBUDs7U0FFRyxNQUFMO2FBQ1MsbUJBQVA7Ozs7O1NBTUZyUTs7TUFBSyxPQUFNLElBQVgsRUFBZ0IsUUFBTyxJQUF2QjtrQ0FDUSxHQUFHd0QsSUFBVDtHQUZKOzs7QUFPRjRNLE1BQU05UCxTQUFOLEdBQWtCO2FBQ0xKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQjtDQURiOzs7O0FDMUJBOztBQUVBLElBQU1tUSxtQkFBbUI7T0FDbEIsSUFEa0I7T0FFbEIsT0FGa0I7T0FHbEIsTUFIa0I7T0FJbEI7Q0FKUDs7QUFPQSxJQUFNQyxnQkFBZ0I7TUFDaEIsQ0FEZ0I7U0FFYixDQUZhO1FBR2QsQ0FIYztRQUlkO0NBSlI7O0FBT0EsSUFBTUMsU0FBUyxFQUFmO0FBQ0EsQUFBTyxJQUFNQyxlQUFlLEVBQXJCO0FBQ1AsSUFBTUMseUJBQXlCLEVBQS9CO0FBQ0EsQUFBTyxJQUFNQyxnQkFBZ0IsQ0FBdEI7Ozs7O0FBNERQLEFBQU8sU0FBU0MsVUFBVCxDQUNMQyxVQURLLEVBRUxDLGNBRkssRUFHTEMsV0FISyxFQUlMQyxVQUpLLEVBS0w7OztNQUdJQyxLQUFLRixZQUFZN1QsR0FBWixHQUFrQjJULFdBQVd0VSxNQUE3QixHQUFzQ2tVLFlBQS9DO01BQ0luVCxRQUNGMFQsV0FBV2pTLEtBQVgsR0FBbUI4UixXQUFXOVIsS0FBOUIsR0FBc0MwUixZQUF0QyxHQUFxRE0sWUFBWXpULEtBRG5FO01BRUk0VCxPQUNGRixXQUFXelUsTUFBWCxHQUFvQnNVLFdBQVd0VSxNQUEvQixHQUF3Q2tVLFlBQXhDLEdBQXVETSxZQUFZNVQsTUFEckU7TUFFSUMsT0FBTzJULFlBQVkzVCxJQUFaLEdBQW1CeVQsV0FBVzlSLEtBQTlCLEdBQXNDMFIsWUFBakQ7Ozs7TUFLRU0sWUFBWTdULEdBQVosR0FBa0J5VCxhQUFsQixJQUNBSyxXQUFXelUsTUFBWCxHQUFvQndVLFlBQVk1VCxNQUFoQyxHQUF5Q3dULGFBRjNDLEVBR0U7V0FDTyxDQUFQO1lBQ1EsQ0FBUjs7OztNQUtBSSxZQUFZM1QsSUFBWixHQUFtQnVULGFBQW5CLElBQ0FLLFdBQVdqUyxLQUFYLEdBQW1CZ1MsWUFBWXpULEtBQS9CLEdBQXVDcVQsYUFGekMsRUFHRTtTQUNLLENBQUw7V0FDTyxDQUFQOzs7TUFHSVEsU0FBUyxDQUFDRixFQUFELEVBQUszVCxLQUFMLEVBQVk0VCxJQUFaLEVBQWtCOVQsSUFBbEIsQ0FBZjs7O01BR00wUCxNQUFNL1gsS0FBSytYLEdBQUwsYUFBWXFFLE1BQVosQ0FBWjs7O01BR0lDLGdCQUFKO01BQ0lOLGtCQUFrQkssT0FBT1osY0FBY08sY0FBZCxDQUFQLElBQXdDLENBQTlELEVBQWlFOztjQUVyREEsY0FBVjtHQUZGLE1BR087O2NBRUtSLGlCQUFpQmEsT0FBTzlSLE9BQVAsQ0FBZXlOLEdBQWYsQ0FBakIsQ0FBVjs7U0FFS3NFLE9BQVA7Ozs7OztBQU1GLEFBQU8sU0FBU0MsU0FBVCxDQUNMUixVQURLLEVBRUxPLE9BRkssRUFHTEwsV0FISyxFQUlMQyxVQUpLLEVBS0w7O01BRUlNLGVBQUo7TUFDSUMsbUJBQUo7TUFDSUMsNkJBQUo7O01BRUlKLFlBQVksT0FBWixJQUF1QkEsWUFBWSxNQUF2QyxFQUErQzthQUNwQ1AsV0FBV3RVLE1BQVgsR0FBb0IsQ0FBN0I7aUJBQ2F3VSxZQUFZN1QsR0FBWixHQUFrQixDQUFDNlQsWUFBWTVULE1BQVosR0FBcUI0VCxZQUFZN1QsR0FBbEMsSUFBeUMsQ0FBeEU7MkJBQ3VCOFQsV0FBV3pVLE1BQWxDO0dBSEYsTUFJTzs7YUFFSXNVLFdBQVc5UixLQUFYLEdBQW1CLENBQTVCO2lCQUNhZ1MsWUFBWTNULElBQVosR0FBbUIsQ0FBQzJULFlBQVl6VCxLQUFaLEdBQW9CeVQsWUFBWTNULElBQWpDLElBQXlDLENBQXpFOzJCQUN1QjRULFdBQVdqUyxLQUFsQzs7O01BR0kwUyxjQUFjRixhQUFhRCxNQUFiLEdBQXNCZCxNQUExQztNQUNNa0IsZUFBZUYsdUJBQXVCRCxVQUF2QixHQUFvQ0QsTUFBcEMsR0FBNkNkLE1BQWxFO01BQ0ltQixlQUFKO01BQ0lGLGNBQWMsQ0FBZCxJQUFtQkMsZUFBZSxDQUF0QyxFQUF5Qzs7YUFFOUIsUUFBVDtHQUZGLE1BR08sSUFBSUEsZUFBZSxDQUFuQixFQUFzQjs7YUFFbEJOLFlBQVksTUFBWixJQUFzQkEsWUFBWSxPQUFsQyxHQUE0QyxJQUE1QyxHQUFtRCxNQUE1RDtHQUZLLE1BR0E7O2FBRUlBLFlBQVksTUFBWixJQUFzQkEsWUFBWSxPQUFsQyxHQUE0QyxNQUE1QyxHQUFxRCxPQUE5RDs7U0FFS08sTUFBUDs7Ozs7O0FBTUYsQUFBTyxTQUFTQyxjQUFULENBQ0xELE1BREssRUFFTFosV0FGSyxFQUdMQyxVQUhLLEVBSUw7O01BRUlhLHNCQUNGbkIseUJBQXlCLENBQUNLLFlBQVl4VSxNQUFaLEdBQXFCa1UsWUFBdEIsSUFBc0MsQ0FEakU7TUFFSXFCLHdCQUNGcEIseUJBQXlCLENBQUNLLFlBQVloUyxLQUFaLEdBQW9CMFIsWUFBckIsSUFBcUMsQ0FEaEU7TUFFSXNCLHFCQUFxQnRCLFlBQXpCO01BQ0l1Qix1QkFBdUJ2QixZQUEzQjs7OztNQUlNd0Isb0JBQ0psQixZQUFZN1QsR0FBWixHQUFrQjJVLG1CQUFsQixHQUF3QyxDQUF4QyxJQUNBZCxZQUFZNVQsTUFBWixHQUFxQjBVLG1CQUFyQixHQUEyQ2IsV0FBV3pVLE1BRnhEO01BR00yVixzQkFDSm5CLFlBQVkzVCxJQUFaLEdBQW1CMFUscUJBQW5CLEdBQTJDLENBQTNDLElBQ0FmLFlBQVl6VCxLQUFaLEdBQW9Cd1UscUJBQXBCLEdBQTRDZCxXQUFXalMsS0FGekQ7TUFHSWtULGlCQUFKLEVBQXVCOzBCQUVuQnRCLGdCQUFnQixDQUFDSSxZQUFZeFUsTUFBWixHQUFxQmtVLFlBQXRCLElBQXNDLENBRHhEO3lCQUVxQkUsYUFBckI7O01BRUV1QixtQkFBSixFQUF5Qjs0QkFFckJ2QixnQkFBZ0IsQ0FBQ0ksWUFBWWhTLEtBQVosR0FBb0IwUixZQUFyQixJQUFxQyxDQUR2RDsyQkFFdUJFLGFBQXZCOzs7U0FHSztZQUNHO1NBQ0htQixxQkFERztTQUVIRDtLQUhBO1dBS0U7U0FDRkcsb0JBREU7U0FFRkQ7O0dBUFA7Ozs7OztBQWVGLEFBQU8sU0FBU0ksYUFBVCxDQUNMQyxJQURLLEVBRUxDLFNBRkssRUFHTHhCLFVBSEssRUFJTE8sT0FKSyxFQUtMTyxNQUxLLEVBTUxaLFdBTkssRUFPTDtNQUNJdUIsYUFBYUYsS0FBS2hWLElBQXRCO01BQ0ltVixZQUFZSCxLQUFLbFYsR0FBckI7O01BRUlzVixXQUFXcEIsWUFBWSxNQUFaLEdBQXFCLENBQUNYLFlBQXRCLEdBQXFDLElBQXBEO01BQ0lnQyxhQUFhckIsWUFBWSxNQUFaLEdBQXFCLENBQUNYLFlBQXRCLEdBQXFDLElBQXREO01BQ0lpQyxjQUFjLElBQWxCO01BQ0lDLFlBQVl2QixZQUFZLE9BQVosR0FBc0IsQ0FBQ1gsWUFBdkIsR0FBc0MsSUFBdEQ7O01BRUlrQixXQUFXLElBQWYsRUFBcUI7Z0JBQ1BTLEtBQUtsVixHQUFMLEdBQVdtVixVQUFVTyxNQUFWLENBQWlCM1UsQ0FBeEM7ZUFDV29VLFVBQVVRLEtBQVYsQ0FBZ0I1VSxDQUEzQjtHQUZGLE1BR08sSUFBSTBULFdBQVcsTUFBZixFQUF1QjtnQkFFMUJTLEtBQUtsVixHQUFMLEdBQVcyVCxXQUFXdFUsTUFBdEIsR0FBK0J3VSxZQUFZeFUsTUFBM0MsR0FBb0Q4VixVQUFVTyxNQUFWLENBQWlCM1UsQ0FEdkU7a0JBRWNvVSxVQUFVUSxLQUFWLENBQWdCNVUsQ0FBOUI7R0FISyxNQUlBLElBQUkwVCxXQUFXLE1BQWYsRUFBdUI7aUJBQ2ZTLEtBQUtoVixJQUFMLEdBQVlpVixVQUFVTyxNQUFWLENBQWlCNWEsQ0FBMUM7Z0JBQ1lxYSxVQUFVUSxLQUFWLENBQWdCN2EsQ0FBNUI7R0FGSyxNQUdBLElBQUkyWixXQUFXLE9BQWYsRUFBd0I7aUJBRTNCUyxLQUFLaFYsSUFBTCxHQUFZeVQsV0FBVzlSLEtBQXZCLEdBQStCZ1MsWUFBWWhTLEtBQTNDLEdBQW1Ec1QsVUFBVU8sTUFBVixDQUFpQjVhLENBRHRFO2lCQUVhcWEsVUFBVVEsS0FBVixDQUFnQjdhLENBQTdCO0dBSEssTUFJQSxJQUFJMlosV0FBVyxRQUFmLEVBQXlCO1FBQzFCUCxZQUFZLE1BQVosSUFBc0JBLFlBQVksT0FBdEMsRUFBK0M7VUFDdkNHLGFBQWFnQixZQUFZeEIsWUFBWXhVLE1BQVosR0FBcUIsQ0FBcEQ7a0JBQ1lnVixhQUFhVixXQUFXdFUsTUFBWCxHQUFvQixDQUE3QztpQkFDVyxDQUFDc1UsV0FBV3RVLE1BQVgsR0FBb0JrVSxZQUFyQixJQUFxQyxDQUFoRDs7UUFFRVcsWUFBWSxJQUFaLElBQW9CQSxZQUFZLE1BQXBDLEVBQTRDO1VBQ3BDRyxjQUFhZSxhQUFhdkIsWUFBWWhTLEtBQVosR0FBb0IsQ0FBcEQ7bUJBQ2F3UyxjQUFhVixXQUFXOVIsS0FBWCxHQUFtQixDQUE3QztrQkFDWSxDQUFDOFIsV0FBVzlSLEtBQVgsR0FBbUIwUixZQUFwQixJQUFvQyxDQUFoRDs7OztTQUlHO2tCQUNTO1dBQ1A4QixTQURPO1lBRU5EO0tBSEg7aUJBS1E7V0FDTkUsUUFETTthQUVKQyxVQUZJO2NBR0hDLFdBSEc7WUFJTEM7O0dBVFY7Ozs7QUFlRixBQUFPLFNBQVNHLFdBQVQsQ0FDTEMsY0FESyxFQUVMbEMsVUFGSyxFQUdMTyxPQUhLLEVBSUxMLFdBSkssRUFLTEMsVUFMSyxFQU1MO01BQ01nQyxhQUFhdkMsZUFBZSxDQUFsQzs7TUFFSXZULFlBQUo7TUFDSWtVLFlBQVksTUFBaEIsRUFBd0I7VUFDaEJKLFdBQVdpQyxPQUFYLEdBQXFCbEMsWUFBWTVULE1BQWpDLEdBQTBDNlYsVUFBaEQ7R0FERixNQUVPLElBQUk1QixZQUFZLElBQWhCLEVBQXNCO1VBRXpCSixXQUFXaUMsT0FBWCxJQUFzQmxDLFlBQVk3VCxHQUFaLEdBQWtCMlQsV0FBV3RVLE1BQTdCLEdBQXNDeVcsVUFBNUQsQ0FERjtHQURLLE1BR0E7O1VBRUNoQyxXQUFXaUMsT0FBWCxHQUFxQmxDLFlBQVk3VCxHQUF2Qzs7OztNQUlFRSxhQUFKO01BQ0lnVSxZQUFZLE1BQWhCLEVBQXdCO1dBRXBCSixXQUFXa0MsT0FBWCxJQUFzQm5DLFlBQVkzVCxJQUFaLEdBQW1CeVQsV0FBVzlSLEtBQTlCLEdBQXNDaVUsVUFBNUQsQ0FERjtHQURGLE1BR08sSUFBSTVCLFlBQVksT0FBaEIsRUFBeUI7V0FDdkJKLFdBQVdrQyxPQUFYLEdBQXFCbkMsWUFBWXpULEtBQWpDLEdBQXlDMFYsVUFBaEQ7R0FESyxNQUVBOztXQUVFaEMsV0FBV2tDLE9BQVgsR0FBcUJuQyxZQUFZM1QsSUFBeEM7Ozs7U0FJSzJWLGVBQWU5VSxDQUF0QjtVQUNROFUsZUFBZS9hLENBQXZCO1NBQ08sRUFBRWtGLFFBQUYsRUFBT0UsVUFBUCxFQUFQOzs7SUFHbUIrVjs7Ozs7Ozs7Ozs7Ozs7eUxBQ25CaE4sUUFBZTtvQkFDQzthQUNQekMsU0FETztlQUVMQSxTQUZLO2dCQUdKQSxTQUhJO2NBSU5BO09BTEs7bUJBT0E7YUFDTkEsU0FETTtlQUVKQSxTQUZJO2dCQUdIQSxTQUhHO2NBSUxBO09BWEs7ZUFhSjthQTJCWDBQLG9CQUFvQixVQUFDdGYsS0FBRCxFQUFrQjtVQUVsQ2lmLGNBRmtDLEdBT2hDamYsS0FQZ0MsQ0FFbENpZixjQUZrQztVQUdsQ2pDLGNBSGtDLEdBT2hDaGQsS0FQZ0MsQ0FHbENnZCxjQUhrQztVQUlsQ3VDLHdCQUprQyxHQU9oQ3ZmLEtBUGdDLENBSWxDdWYsd0JBSmtDO1VBS2xDdEMsV0FMa0MsR0FPaENqZCxLQVBnQyxDQUtsQ2lkLFdBTGtDO1VBTWxDaFMsS0FOa0MsR0FPaENqTCxLQVBnQyxDQU1sQ2lMLEtBTmtDOzs7OztVQVc5Qm1VLFVBQVVHLDJCQUNaLENBRFksR0FFWi9PLE9BQU9nUCxXQUFQLElBQ0NDLFNBQVNDLGVBQVQsSUFBNEJELFNBQVNDLGVBQVQsQ0FBeUJDLFVBRHRELElBRUEsQ0FKSjtVQUtNUixVQUFVSSwyQkFDWixDQURZLEdBRVovTyxPQUFPb1AsV0FBUCxJQUNDSCxTQUFTQyxlQUFULElBQTRCRCxTQUFTQyxlQUFULENBQXlCRyxTQUR0RCxJQUVBLENBSko7O1VBTU0zQyxhQUFhO2dCQUNUMU0sT0FBT3NQLFdBREU7ZUFFVnRQLE9BQU91UCxVQUZHO3dCQUFBOztPQUFuQjs7VUFPTWhELGFBQWE7Z0JBQ1QsTUFBSytCLE1BQUwsR0FBYyxNQUFLQSxNQUFMLENBQVlrQixZQUExQixHQUF5QyxDQURoQzs7T0FBbkI7OztVQU1NMUMsVUFBVVIsV0FDZEMsVUFEYyxFQUVkQyxjQUZjLEVBR2RDLFdBSGMsRUFJZEMsVUFKYyxDQUFoQjs7O1VBUU1XLFNBQVNOLFVBQVVSLFVBQVYsRUFBc0JPLE9BQXRCLEVBQStCTCxXQUEvQixFQUE0Q0MsVUFBNUMsQ0FBZjs7O1VBR01vQixPQUFPVSxZQUNYQyxjQURXLEVBRVhsQyxVQUZXLEVBR1hPLE9BSFcsRUFJWEwsV0FKVyxFQUtYQyxVQUxXLENBQWI7OztVQVNNK0MsYUFBYW5DLGVBQWVELE1BQWYsRUFBdUJaLFdBQXZCLEVBQW9DQyxVQUFwQyxDQUFuQjs7OzsyQkFHc0NtQixjQUNwQ0MsSUFEb0MsRUFFcEMyQixVQUZvQyxFQUdwQ2xELFVBSG9DLEVBSXBDTyxPQUpvQyxFQUtwQ08sTUFMb0MsRUFNcENaLFdBTm9DLENBMURGO1VBMEQ1QmlELFlBMUQ0QixrQkEwRDVCQSxZQTFENEI7VUEwRGRDLFdBMURjLGtCQTBEZEEsV0ExRGM7O1lBbUUvQjVOLFFBQUwsQ0FBYztnQ0FBQTtrQ0FBQTs7T0FBZDs7Ozs7O3dDQTNGa0I7OztXQUNiK00saUJBQUwsQ0FBdUIsS0FBS3RmLEtBQTVCO2lCQUNXLFlBQU07WUFDWCxPQUFLQSxLQUFMLENBQVdvZ0IsV0FBWCxJQUEwQixPQUFLdEIsTUFBbkMsRUFBMkM7aUJBQ3BDQSxNQUFMLENBQVl1QixLQUFaOztPQUZKO2FBS09DLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLEtBQUt0Z0IsS0FBTCxDQUFXdWdCLFFBQTdDO2FBQ09ELGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLEtBQUt0Z0IsS0FBTCxDQUFXd2dCLFNBQTlDOzs7OzhDQUd3QkMsV0FBa0I7V0FDckNuQixpQkFBTCxDQUF1Qm1CLFNBQXZCOzs7OzJDQUdxQjthQUNkQyxtQkFBUCxDQUEyQixRQUEzQixFQUFxQyxLQUFLMWdCLEtBQUwsQ0FBV3VnQixRQUFoRDthQUNPRyxtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxLQUFLMWdCLEtBQUwsQ0FBV3dnQixTQUFqRDs7Ozs7Ozs7Ozs2QkFtRk87OzttQkFDOEIsS0FBS3hnQixLQURuQztVQUNDMmdCLE9BREQsVUFDQ0EsT0FERDtVQUNVOVUsUUFEVixVQUNVQSxRQURWO1VBQ29CWixLQURwQixVQUNvQkEsS0FEcEI7Ozs7VUFJRDJWLGFBQWEsS0FBS3ZPLEtBQUwsQ0FBV2lMLE9BQVgsS0FBdUIsSUFBdkIsR0FBOEIsUUFBOUIsR0FBeUMsU0FBNUQ7VUFDTXVELGFBQWdCRixPQUFoQixPQUFOO1VBQ01HLFNBQVNILFlBQVksT0FBWixHQUFzQixTQUF0QixHQUFrQyxJQUFqRDtVQUNNSSxjQUFjSixZQUFZLE9BQVosR0FBc0IsV0FBdEIsR0FBb0NBLE9BQXhEOzthQUdFelU7OztxQkFDYS9NLFVBQU82aEIsU0FEcEI7NEJBRVdGLGNBQVQsRUFBaUJGLHNCQUFqQixJQUFnQyxLQUFLdk8sS0FBTCxDQUFXNk4sWUFBM0M7Ozs7O3VCQUdhMVEsV0FDVHRJLE9BQU8yWixVQUFQLENBRFMsRUFFVDNaLE9BQU82WixXQUFQLENBRlMsRUFHVDVoQixVQUFPOGhCLFVBSEUsRUFJVDloQixVQUFPK2hCLFFBSkUsQ0FEYjtpQkFPTyxnQkFBSztxQkFDSHBDLE1BQUwsR0FBY3phLENBQWQ7YUFSSjtzQkFVWSxDQUFDOzs7Ozt5QkFHRW1MLFdBQVdyUSxVQUFPOGhCLFVBQWxCLEVBQThCOWhCLFVBQU9naUIsYUFBckMsQ0FEYjtxQkFFUyxFQUFFbFcsWUFBRjs7O1dBZFg7Ozs7eUJBbUJldUUsV0FBV3RJLE9BQU95WixPQUFQLENBQVgsRUFBNEJ4aEIsVUFBTzRmLEtBQW5DLENBRGI7a0NBRWMsS0FBSzFNLEtBQUwsQ0FBVzhOLFdBQXZCOztnQ0FFQyxLQUFELElBQU8sV0FBVyxLQUFLOU4sS0FBTCxDQUFXaUwsT0FBN0I7OztPQTNCUjs7OztFQTlIa0NsTTtBQWtLdENpTyxTQUFTN1MsU0FBVCxHQUFxQjtXQUNWSixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsUUFBckIsRUFBK0IsT0FBL0IsQ0FBaEIsQ0FEVTtZQUVURCxVQUFVSyxJQUZEO2tCQUdITCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsQ0FBaEIsQ0FIRzthQUlSRCxVQUFVaUYsSUFBVixDQUFldkIsVUFKUDtZQUtUMUQsVUFBVWlGLElBQVYsQ0FBZXZCLFVBTE47a0JBTUgxRCxVQUFVTSxLQUFWLENBQWdCLEVBQUV4SSxHQUFHa0ksVUFBVVUsTUFBZixFQUF1QjNDLEdBQUdpQyxVQUFVVSxNQUFwQyxFQUFoQixDQU5HOzRCQU9PVixVQUFVUyxJQVBqQjtlQVFOVCxVQUFVUyxJQVJKO2VBU05ULFVBQVVNLEtBQVYsQ0FBZ0I7WUFDbkJOLFVBQVVVLE1BRFM7WUFFbkJWLFVBQVVVLE1BRlM7VUFHckJWLFVBQVVVLE1BSFc7V0FJcEJWLFVBQVVVLE1BSlU7U0FLdEJWLFVBQVVVLE1BTFk7V0FNcEJWLFVBQVVVO0dBTk4sQ0FUTTtTQWlCWlYsVUFBVVU7Q0FqQm5COztJQzlkcUJzVTs7Ozs7Ozs7Ozs7Ozs7aU5BYW5CQyxtQkFBbUIsVUFBQzlLLEtBQUQsRUFBdUI7O1VBRWxDK0IsS0FBS2dKLDJCQUFYO1VBRUUsQ0FBQyxNQUFLdGhCLEtBQUwsQ0FBVzJWLE9BQVosSUFDQSxDQUFDMkMsRUFERCxJQUVDL0IsTUFBTWEsTUFBTixZQUF3Qm1LLElBQXhCLElBQWdDakosR0FBR2xOLFFBQUgsQ0FBWW1MLE1BQU1hLE1BQWxCLENBSG5DLEVBSUU7OztZQUdHcFgsS0FBTCxDQUFXMlYsT0FBWCxDQUFtQlksS0FBbkI7Ozs7Ozt3Q0F0QmtCO2VBQ1QrSixnQkFBVCxDQUEwQixPQUExQixFQUFtQyxLQUFLZSxnQkFBeEMsRUFBMEQ7aUJBQy9DO09BRFg7Ozs7MkNBS3FCO2VBQ1pYLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLEtBQUtXLGdCQUEzQyxFQUE2RDtpQkFDbEQ7T0FEWDs7Ozs2QkFrQk87YUFDQSxLQUFLcmhCLEtBQUwsQ0FBVzZMLFFBQWxCOzs7O0VBM0I4Q3VGOztBQ1FsRCxJQUFNb1EsaUJBQWlCO01BQ2pCLEdBRGlCO01BRWpCLEdBRmlCO01BR2pCLEdBSGlCO01BSWpCLEdBSmlCO01BS2pCO0NBTE47O0FBUUEsSUFBTUMsa0JBQWtCLEVBQXhCOztJQW1CcUJDOzs7Ozs7Ozs7Ozs7Ozs2TEFDbkJyUCxRQUFlO3NCQUNHO1dBQ1gsQ0FEVztXQUVYO09BSFE7MkJBS1E7Z0JBQ1gsQ0FEVztnQkFFWCxDQUZXO2NBR2IsQ0FIYTtlQUlaLENBSlk7YUFLZCxDQUxjO2VBTVo7O2FBWVhzUCxnQkFBZ0IsVUFBQ3BMLEtBQUQsRUFBZ0M7VUFDMUNBLE1BQU1xTCxPQUFOLEtBQWtCSCxlQUF0QixFQUF1QztjQUNoQ3poQixLQUFMLENBQVc2aEIsU0FBWDs7YUFJSkMsa0JBQWtCLFVBQUN2TCxLQUFELEVBQWtCO1VBRWhDQSxNQUFNYSxNQUFOLFlBQXdCbUssSUFBeEIsSUFDQSxNQUFLdmhCLEtBQUwsQ0FBVytoQixNQURYLElBRUEsQ0FBQyxNQUFLL2hCLEtBQUwsQ0FBVytoQixNQUFYLENBQWtCM1csUUFBbEIsQ0FBMkJtTCxNQUFNYSxNQUFqQyxDQUhILEVBSUU7Y0FDS3BYLEtBQUwsQ0FBVzZoQixTQUFYOzthQUlKRyxlQUFlLFlBQU07WUFDZEMsaUJBQUwsQ0FBdUIsTUFBS2ppQixLQUE1QjthQUdGaWlCLG9CQUFvQixVQUFDamlCLEtBQUQsRUFBa0I7VUFDNUIraEIsTUFENEIsR0FDUy9oQixLQURULENBQzVCK2hCLE1BRDRCO1VBQ3BCeEMsd0JBRG9CLEdBQ1N2ZixLQURULENBQ3BCdWYsd0JBRG9COztVQUVoQzJDLDRCQUFKO1VBQ0lqRCx1QkFBSjtVQUNJOEMsTUFBSixFQUFZOzhCQUNZQSxPQUFPSSxxQkFBUCxFQUF0Qjs7O3lCQUdpQjthQUNaNUMsMkJBQ0MyQyxvQkFBb0I1WSxJQUFwQixHQUEyQnlZLE9BQU9LLFVBRG5DLEdBRUMsQ0FIVzthQUlaN0MsMkJBQ0MyQyxvQkFBb0I5WSxHQUFwQixHQUEwQjJZLE9BQU9NLFNBRGxDLEdBRUM7U0FOTjs7O1lBVUc5UCxRQUFMLENBQWMsRUFBRTBNLDhCQUFGLEVBQWtCaUQsd0NBQWxCLEVBQWQ7Ozs7Ozt3Q0E5Q2tCO1dBQ2JELGlCQUFMLENBQXVCLEtBQUtqaUIsS0FBNUI7Ozs7OENBR3dCeWdCLFdBQWtCO1dBQ3JDd0IsaUJBQUwsQ0FBdUJ4QixTQUF2Qjs7Ozs2QkE0Q087bUJBUUgsS0FBS3pnQixLQVJGO1VBRUwraEIsTUFGSyxVQUVMQSxNQUZLO1VBR0xwQixPQUhLLFVBR0xBLE9BSEs7VUFJTDlVLFFBSkssVUFJTEEsUUFKSztVQUtMbVIsY0FMSyxVQUtMQSxjQUxLO1VBTUx1Qyx3QkFOSyxVQU1MQSx3QkFOSztVQU9MYSxXQVBLLFVBT0xBLFdBUEs7O1VBU0gsQ0FBQzJCLE1BQUwsRUFBYTtlQUNKLElBQVA7O1VBRUk5aEIsT0FBTyxLQUFLRCxLQUFMLENBQVdDLElBQVgsR0FBa0IsS0FBS0QsS0FBTCxDQUFXQyxJQUE3QixHQUFvQyxJQUFqRDtVQUNNZ0wsUUFBUSxPQUFPaEwsSUFBUCxLQUFnQixRQUFoQixHQUEyQnVoQixlQUFldmhCLElBQWYsQ0FBM0IsR0FBa0RBLElBQWhFO2FBRUVpTTs0QkFBQTtVQUFzQixTQUFTLEtBQUs0VixlQUFwQzs7a0JBQ0U7O3FCQUNXbkIsT0FEWDs0QkFFa0IzRCxjQUZsQjt1QkFHYSxLQUFLMkUsYUFIbEI7c0JBSVksS0FBS0ssWUFKakI7c0NBSzRCekMsd0JBTDVCOzRCQU1rQixLQUFLbE4sS0FBTCxDQUFXNE0sY0FON0I7eUJBT2VtQixXQVBmO3lCQVFlLEtBQUsvTixLQUFMLENBQVc2UCxtQkFSMUI7bUJBU1NqWDs7OztPQVhiOzs7O0VBL0VvQ21HOzs7QUFtR3hDc1EsV0FBV2xWLFNBQVgsR0FBdUI7VUFDYkosVUFBVVcsS0FBVixDQUFnQjtjQUNaWCxVQUFVaUYsSUFERTsyQkFFQ2pGLFVBQVVpRjtHQUYzQixDQURhO1dBS1pqRixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsUUFBckIsRUFBK0IsT0FBL0IsQ0FBaEIsQ0FMWTtZQU1YRCxVQUFVSyxJQU5DO2tCQU9MTCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0IsTUFBaEIsRUFBd0IsTUFBeEIsQ0FBaEIsQ0FQSzthQVFWRCxVQUFVaUYsSUFBVixDQUFldkIsVUFSTDs0QkFTSzFELFVBQVVTLElBVGY7ZUFVUlQsVUFBVVMsSUFWRjtRQVdmVCxVQUFVUSxTQUFWLENBQW9CLENBQ3hCUixVQUFVVSxNQURjLEVBRXhCVixVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQWhCLENBRndCLENBQXBCOztDQVhSOztBQ2hJZSxTQUFTaVcsTUFBVCxDQUFnQnRpQixLQUFoQixFQUE4QjtNQUV6QytoQixNQUZ5QyxHQVN2Qy9oQixLQVR1QyxDQUV6QytoQixNQUZ5QztNQUd6Q2xXLFFBSHlDLEdBU3ZDN0wsS0FUdUMsQ0FHekM2TCxRQUh5QztNQUl6Q21SLGNBSnlDLEdBU3ZDaGQsS0FUdUMsQ0FJekNnZCxjQUp5QztNQUt6QzZFLFNBTHlDLEdBU3ZDN2hCLEtBVHVDLENBS3pDNmhCLFNBTHlDOzhCQVN2QzdoQixLQVR1QyxDQU16Q3VmLHdCQU55QztNQU16Q0Esd0JBTnlDLHlDQU1kLElBTmM7cUJBU3ZDdmYsS0FUdUMsQ0FPekNtUCxLQVB5QztNQU96Q0EsS0FQeUMsZ0NBT2pDLE9BUGlDO01BUXpDbFAsSUFSeUMsR0FTdkNELEtBVHVDLENBUXpDQyxJQVJ5Qzs7O01BV3ZDLENBQUM4aEIsTUFBTCxFQUFhO1dBQ0osSUFBUDs7O1NBSUE3VjtjQUFBOztjQUNVNlYsTUFEVjtlQUVXNVMsS0FGWDtzQkFHa0I2TixjQUhsQjtpQkFJYTZFLFNBSmI7Z0NBSzRCdEMsd0JBTDVCO21CQU1lcFEsVUFBVSxRQU56QjtZQU9RbFA7OztHQVJWOzs7QUFlRnFpQixPQUFPOVYsU0FBUCxHQUFtQjtVQUNUSixVQUFVVyxLQUFWLENBQWdCO2NBQ1pYLFVBQVVpRixJQURFOzJCQUVDakYsVUFBVWlGO0dBRjNCLENBRFM7WUFLUGpGLFVBQVVLLElBTEg7a0JBTURMLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQixDQU5DO2FBT05ELFVBQVVpRixJQUFWLENBQWV2QixVQVBUOzRCQVFTMUQsVUFBVVMsSUFSbkI7U0FTVlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE9BQW5CLENBQWhCLENBVFU7UUFVWEQsVUFBVVEsU0FBVixDQUFvQixDQUN4QlIsVUFBVVUsTUFEYyxFQUV4QlYsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQUZ3QixDQUFwQjs7Q0FWUjs7OztBQ3JDQSxTQUFTa1csR0FBVCxDQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtTQUNWRCxFQUFFMWlCLEdBQUYsQ0FBTSxVQUFDbVosSUFBRCxFQUFPSyxHQUFQO1dBQWUsQ0FBQ0wsSUFBRCxFQUFPd0osRUFBRW5KLEdBQUYsQ0FBUCxDQUFmO0dBQU4sQ0FBUDs7O0FBR0YsSUFBTW9KLGVBQWUsQ0FBckI7O0FBRUEsSUFBTUMsZUFBZTtNQUNmLEVBRGU7TUFFZixFQUZlO01BR2Y7Q0FITjs7QUFlQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQzVoQixDQUFELEVBQUlmLElBQUosRUFBYTtVQUN4QmUsQ0FBUjtTQUNPLENBQUw7U0FDSyxDQUFMO2FBQ1MsQ0FDTCxFQUFFb0ksS0FBSyxDQUFQLEVBQVVFLE1BQU0sQ0FBaEIsRUFBbUIyQixPQUFPaEwsSUFBMUIsRUFBZ0N3SSxRQUFReEksSUFBeEMsRUFBOEM0aUIsWUFBWSxRQUExRCxFQURLLENBQVA7U0FHRyxDQUFMO2FBQ1MsQ0FDTDthQUNPLENBRFA7Y0FFUSxDQUZSOytCQUd1QkgsZUFBZSxDQUFwQyxRQUhGO2dCQUlVemlCLElBSlY7b0JBS2M7T0FOVCxFQVFMO2FBQ08sQ0FEUDs4QkFFc0J5aUIsZUFBZSxDQUFuQyxRQUZGOytCQUd1QkEsZUFBZSxDQUFwQyxRQUhGO2dCQUlVemlCLElBSlY7b0JBS2M7T0FiVCxDQUFQOzthQWlCTyxDQUNMO2FBQ08sQ0FEUDtjQUVRLENBRlI7K0JBR3VCeWlCLGVBQWUsQ0FBcEMsUUFIRjtnQkFJVXppQixJQUpWO29CQUtjO09BTlQsRUFRTDthQUNPLENBRFA7OEJBRXNCeWlCLGVBQWUsQ0FBbkMsUUFGRjtlQUdTLFdBSFQ7Z0NBSXdCQSxlQUFlLENBQXJDLFFBSkY7b0JBS2M7T0FiVCxFQWVMOzZCQUNxQkEsZUFBZSxDQUFsQyxRQURGOzhCQUVzQkEsZUFBZSxDQUFuQyxRQUZGO2VBR1MsV0FIVDtnQ0FJd0JBLGVBQWUsQ0FBckMsUUFKRjtvQkFLYztPQXBCVCxDQUFQOztDQXpCTjs7QUFtREEsSUFBTUksV0FBVyxTQUFYQSxRQUFXO1NBQU9DLE9BQU85aEIsS0FBSytoQixFQUFMLEdBQVUsR0FBakIsQ0FBUDtDQUFqQjs7QUFFQSxJQUFNcFIsa0JBQWdCLFNBQWhCQSxhQUFnQixDQUFDNVIsS0FBRCxFQUlmO01BQ0dDLElBREgsR0FDOEJELEtBRDlCLENBQ0dDLElBREg7TUFDU3FCLElBRFQsR0FDOEJ0QixLQUQ5QixDQUNTc0IsSUFEVDtNQUNldWhCLFVBRGYsR0FDOEI3aUIsS0FEOUIsQ0FDZTZpQixVQURmOzs7TUFHQ0ksMkJBQXlCaGlCLEtBQUtpaUIsR0FBTCxDQUFTSixTQUFTLEVBQVQsQ0FBVCxDQUF6QixZQUFzRDdpQixJQUF0RCxXQUFOOztNQUVNa2pCLFVBQ0pqWDs7O2FBQ1EsTUFEUjtlQUVVLGlCQUZWO2VBR1UsS0FIVjsyQkFJc0IsZUFKdEI7YUFLUTs7Ozs7O0tBTFI7Ozs7a0JBU2EsTUFEWDtjQUVPLE1BRlA7MEJBR21CLFNBSG5CO29CQUlhLFFBSmI7bUJBS2EsQ0FDVDZGLFdBQVdDLFdBREYsRUFFVEQsV0FBV0UsU0FGRixFQUdURixXQUFXRyxZQUhGLEVBSVRILFdBQVdJLGNBSkYsRUFLVGhTLElBTFMsQ0FLSixHQUxJOzthQU9ILDRCQUFJbUIsSUFBSixHQUFVLENBQVYsRUFBYXdRLFdBQWIsRUFBUCxHQUFvQzs7R0FyQjNDO1VBeUJRK1EsVUFBUjtTQUNPLFlBQUw7YUFFSTNXO1dBQUE7O3dCQUNjNUssSUFEZDtpQkFFUSxNQUZSO2tCQUdTLE1BSFQ7bUJBSVUsTUFKVjtzQkFLYSxLQUxiO3FDQU02QjtxQkFDaEI7NkJBQ1EyaEIsY0FEUjs0QkFFT0E7Ozs7O09BVnRCO1NBaUJHLFNBQUw7YUFFSS9XO1dBQUE7O3dCQUNjNUssSUFEZDtpQkFFUSxNQUZSO2tCQUdTLE1BSFQ7bUJBSVUsTUFKVjtzQkFLYSxPQUxiO3FDQU02QjtxQkFDaEI7MEJBQ0syaEIsY0FETDs0QkFFT0E7Ozs7O09BVnRCOzthQW1CRS9XO1dBQUE7O3dCQUNjNUssSUFEZDtpQkFFUSxNQUZSO2tCQUdTLE1BSFQ7bUJBSVUsTUFKVjtzQkFLYSxRQUxiOzBCQU1pQjs7O09BUG5COztDQXhFTjs7QUF1RkEsQUFBZSxTQUFTOGhCLFdBQVQsQ0FBcUJwakIsS0FBckIsRUFBbUM7TUFDeENxakIsYUFEd0MsR0FDUHJqQixLQURPLENBQ3hDcWpCLGFBRHdDO01BQ3pCNVEsT0FEeUIsR0FDUHpTLEtBRE8sQ0FDekJ5UyxPQUR5QjtNQUNoQnhTLElBRGdCLEdBQ1BELEtBRE8sQ0FDaEJDLElBRGdCOztNQUUxQ3FqQixjQUFjcmpCLE9BQU8waUIsYUFBYTFpQixJQUFiLENBQVAsR0FBNEIsTUFBaEQ7TUFDTXNqQixlQUFldGpCLE9BQU8waUIsYUFBYTFpQixJQUFiLENBQVAsR0FBNEIsRUFBakQ7TUFDTWlhLFlBQVkwSSxhQUFhUyxjQUFjL2lCLE1BQTNCLEVBQW1DZ2pCLFdBQW5DLENBQWxCO1NBRUVwWDtPQUFBOzthQUNRLE9BRFI7Z0JBRVcsUUFGWDthQUdRLFFBSFI7YUFJU29YLFdBSlQ7Y0FLVUMsWUFMVjtnQkFNVyxVQU5YO2lDQU82Qjs4QkFFbkI5USxVQUFVLEVBQUUrUSxXQUFXLGdCQUFiLEVBQVYsR0FBNEMsRUFEbEQ7OztzQkFJYzs7Ozt3QkFJZixHQUFELElBQUssMkJBQTJCLEVBQUVyWSxTQUFTLEVBQUV3RyxlQUFlLE1BQWpCLEVBQVgsRUFBaEMsR0FoQkY7UUFpQk91SSxTQUFKLEVBQWVtSixhQUFmLEVBQThCdmpCLEdBQTlCLENBQ0MsZ0JBQTBEd1osR0FBMUQsRUFBa0U7O1VBQWhFRCxRQUFnRTs7VUFBdERvSyxZQUFzRCwwQkFBdkMsRUFBRW5pQixNQUFNLEVBQVIsRUFBWWlQLEtBQUtYLFNBQWpCLEVBQXVDOztVQUN4RDNFLEtBRHdELEdBQ2ZvTyxRQURlLENBQ3hEcE8sS0FEd0Q7VUFDakR4QyxNQURpRCxHQUNmNFEsUUFEZSxDQUNqRDVRLE1BRGlEO1VBQ3pDVyxHQUR5QyxHQUNmaVEsUUFEZSxDQUN6Q2pRLEdBRHlDO1VBQ3BDRSxJQURvQyxHQUNmK1AsUUFEZSxDQUNwQy9QLElBRG9DO1VBQzlCdVosVUFEOEIsR0FDZnhKLFFBRGUsQ0FDOUJ3SixVQUQ4QjtVQUV4RHZoQixJQUZ3RCxHQUUxQ21pQixZQUYwQyxDQUV4RG5pQixJQUZ3RDtVQUVsRGlQLEdBRmtELEdBRTFDa1QsWUFGMEMsQ0FFbERsVCxHQUZrRDs7YUFJOURyRTtXQUFBOztlQUNPb04sR0FEUDtvQkFFVyxVQUZYO2lCQUdTck8sS0FIVDtrQkFJVXhDLE1BSlY7cUNBSzZCLEVBQUUwQyxTQUFTLEVBQUUvQixRQUFGLEVBQU9FLFVBQVAsRUFBWDs7Y0FHekI0QyxvQkFBQyxLQUFEO2VBQ081SyxJQURQO2lCQUVRLFNBRlI7ZUFHT2lQLEdBSFA7d0JBSWdCLENBSmhCO3lCQUtpQixDQUxqQjtlQU1NO1VBUFAsR0FVQ3JFLG9CQUFDMEYsZUFBRDtnQkFDUXRRLElBRFI7c0JBRWN1aEIsVUFGZDtnQkFHUXBhO1VBcEJaO3FDQXVCTyxXQUFXdEosVUFBT3FTLElBQXZCO09BeEJKO0tBSkg7R0FsQkw7OztBQXVERjRSLFlBQVk1VyxTQUFaLEdBQXdCO2lCQUNQSixVQUFVc04sT0FBVixDQUNidE4sVUFBVU0sS0FBVixDQUFnQjtVQUNSTixVQUFVWSxNQUFWLENBQWlCOEMsVUFEVDtTQUVUMUQsVUFBVVk7R0FGakIsQ0FEYSxFQUtiOEMsVUFOb0I7V0FPYjFELFVBQVVTLElBUEc7UUFRaEJULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsQ0FBaEI7Q0FSUjs7OztBQy9MQSxJQUFNcVgsdUJBQXVCO01BQ3ZCLENBRHVCO01BRXZCLENBRnVCO01BR3ZCLENBSHVCO01BSXZCLENBSnVCO01BS3ZCO0NBTE47O0FBUUEsSUFBTS9RLGVBQTBDO01BQzFDLENBRDBDO01BRTFDLENBRjBDO01BRzFDLENBSDBDO01BSTFDLENBSjBDO01BSzFDO0NBTE47O0FBUUEsQUFBZSxTQUFTZ1IsT0FBVCxDQUFpQjNqQixLQUFqQixFQUErQjtNQUUxQzRqQixrQkFGMEMsR0FZeEM1akIsS0Fad0MsQ0FFMUM0akIsa0JBRjBDO01BRzFDL1gsUUFIMEMsR0FZeEM3TCxLQVp3QyxDQUcxQzZMLFFBSDBDO3FCQVl4QzdMLEtBWndDLENBSTFDbVAsS0FKMEM7TUFJMUNBLEtBSjBDLGdDQUlsQyxVQUprQztrQkFZeENuUCxLQVp3QyxDQUsxQzhYLEVBTDBDO01BSzFDQSxFQUwwQyw2QkFLckMsSUFMcUM7TUFNMUMzRSxNQU4wQyxHQVl4Q25ULEtBWndDLENBTTFDbVQsTUFOMEM7TUFPMUNELE1BUDBDLEdBWXhDbFQsS0Fad0MsQ0FPMUNrVCxNQVAwQzt3QkFZeENsVCxLQVp3QyxDQVExQ2dULFFBUjBDO01BUTFDQSxRQVIwQyxtQ0FRL0IsV0FSK0I7b0JBWXhDaFQsS0Fad0MsQ0FTMUNDLElBVDBDO01BUzFDQSxJQVQwQywrQkFTbkMsSUFUbUM7TUFVMUNnVCxNQVYwQyxHQVl4Q2pULEtBWndDLENBVTFDaVQsTUFWMEM7d0JBWXhDalQsS0Fad0MsQ0FXMUNxVCxRQVgwQztNQVcxQ0EsUUFYMEMsbUNBVy9CLEtBWCtCOzs7TUFjdEM5RCxLQUFLa0MsV0FDVHRTLFVBQU93a0IsT0FERSxFQUVUeGtCLHVCQUFrQndULGFBQVcxUyxJQUFYLENBQWxCLENBRlMsRUFHVGdULFVBQVU5VCx5QkFBb0J3VCxhQUFXTSxNQUFYLENBQXBCLENBSEQsRUFJVEMsVUFBVS9ULHlCQUFvQndULGFBQVdPLE1BQVgsQ0FBcEIsQ0FKRCxFQUtUQyxVQUFVaFUseUJBQW9Cd1QsYUFBV1EsTUFBWCxDQUFwQixDQUxELEVBTVRqTSxPQUFPaUksS0FBUCxDQU5TLEVBT1Q2RCxhQUFhLFdBQWIsSUFBNEJqQixXQUFXa0QsU0FQOUIsRUFRVDVCLFlBQVl0QixXQUFXc0IsUUFSZCxDQUFYOztNQVdNd1EsZUFBZUQsc0JBQXNCRixxQkFBcUJ6akIsSUFBckIsQ0FBM0M7U0FDT21SLG1CQUFBLE9BQ0R5UyxZQURDO2VBR1F0VSxFQUhSOztLQUtDOEQsWUFBWSxPQUFPeEgsUUFBUCxLQUFvQixRQUFoQyxHQUNBLEVBQUV5SixPQUFPekosUUFBVCxFQURBLEdBRUEsSUFQRCxHQVNMQSxRQVRLLENBQVA7OztBQWFGOFgsUUFBUW5YLFNBQVIsR0FBb0I7c0JBQ0VKLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFoQixDQURGO1lBRVJELFVBQVVLLElBRkY7U0FHWEwsVUFBVUMsS0FBVixDQUFnQixDQUNyQixNQURxQixFQUVyQixVQUZxQixFQUdyQixVQUhxQixFQUlyQixNQUpxQixFQUtyQixPQUxxQixFQU1yQixXQU5xQixFQU9yQixRQVBxQixFQVFyQixVQVJxQixFQVNyQixNQVRxQixFQVVyQixPQVZxQixFQVdyQixRQVhxQixFQVlyQixRQVpxQixFQWFyQixNQWJxQixFQWNyQixRQWRxQixFQWVyQixLQWZxQixFQWdCckIsWUFoQnFCLEVBaUJyQixPQWpCcUIsQ0FBaEIsQ0FIVztNQXNCZEQsVUFBVVksTUF0Qkk7WUF1QlJaLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsV0FBWCxDQUFoQixDQXZCUTtRQXdCWkQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQXhCWTtVQXlCVkQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQXpCVTtVQTBCVkQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTFCVTtVQTJCVkQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQixDQTNCVTtZQTRCUkQsVUFBVVM7Q0E1QnRCOzs7Ozs7QUNwRkEsSUFBTWlYLHFCQUFxQjtNQUNyQixFQURxQjtNQUVyQixFQUZxQjtNQUdyQixFQUhxQjtNQUlyQixFQUpxQjtNQUtyQjtDQUxOOztBQWtCQSxJQUFNQyw4QkFBOEI7ZUFDckIsTUFEcUI7YUFFdkIsTUFGdUI7U0FHM0I7Q0FIVDs7QUFNQSxBQUFlLFNBQVNDLEdBQVQsQ0FBYWhrQixLQUFiLEVBQTJCOzs7c0JBU3BDQSxLQVRvQyxDQUV0QzhXLE1BRnNDO01BRXRDQSxNQUZzQyxpQ0FFN0IsS0FGNkI7dUJBU3BDOVcsS0FUb0MsQ0FHdEMyZ0IsT0FIc0M7TUFHdENBLE9BSHNDLGtDQUc1QixhQUg0Qjt1QkFTcEMzZ0IsS0FUb0MsQ0FJdEN1WCxPQUpzQztNQUl0Q0EsT0FKc0Msa0NBSTVCLEtBSjRCO3VCQVNwQ3ZYLEtBVG9DLENBS3RDMlcsT0FMc0M7TUFLdENBLE9BTHNDLGtDQUs1QixLQUw0Qjt5QkFTcEMzVyxLQVRvQyxDQU10Q2lrQixTQU5zQztNQU10Q0EsU0FOc0Msb0NBTTFCRiw0QkFBNEJwRCxPQUE1QixDQU4wQjtNQU90Q3ZSLElBUHNDLEdBU3BDcFAsS0FUb0MsQ0FPdENvUCxJQVBzQztvQkFTcENwUCxLQVRvQyxDQVF0Q0MsSUFSc0M7TUFRdENBLElBUnNDLCtCQVEvQixJQVIrQjs7O01BV2xDaWtCLFdBQVdKLG1CQUFtQjdqQixJQUFuQixJQUEyQixDQUE1Qzs7TUFFTWhCLGNBQWM7WUFDVjZrQixtQkFBbUI3akIsSUFBbkIsQ0FEVTtXQUVYNmpCLG1CQUFtQjdqQixJQUFuQjtHQUZUOztNQUtNOFYsVUFBVXZHLFdBQVdyUSxVQUFPZ2xCLEdBQWxCLEVBQXVCaGxCLFVBQU93aEIsT0FBUCxDQUF2QixpREFDYnhoQixVQUFPMlgsTUFETSxFQUNHQSxNQURILCtCQUViM1gsVUFBT29ZLE9BRk0sRUFFSUEsT0FGSiwrQkFHYnBZLFVBQU93WCxPQUhNLEVBR0lBLFdBQVcsQ0FBQ1ksT0FBWixJQUF1QixDQUFDVCxNQUg1QixnQkFBaEI7O1NBT0U1Szs7TUFBSyxXQUFXNkosT0FBaEIsRUFBeUIsT0FBTzlXLFdBQWhDOztTQUNFO1FBQUssT0FBTSxRQUFYOzBCQU9HLElBQUQ7ZUFDU2dsQixTQURUO2NBRVE3VSxJQUZSO2NBR1E4VSxRQUhSOzRCQUlxQjs7O0dBYjNCOzs7QUFvQkZGLElBQUl4WCxTQUFKLEdBQWdCO1VBQ05KLFVBQVVTLElBREo7V0FFTFQsVUFBVUMsS0FBVixDQUFnQixDQUFDLGFBQUQsRUFBZ0IsV0FBaEIsRUFBNkIsT0FBN0IsQ0FBaEIsQ0FGSztXQUdMRCxVQUFVUyxJQUhMO1dBSUxULFVBQVVTLElBSkw7YUFLSFQsVUFBVUMsS0FBVixDQUFnQixDQUFDLE1BQUQsRUFBUyxVQUFULEVBQXFCLEtBQXJCLEVBQTRCLE1BQTVCLEVBQW9DLE9BQXBDLENBQWhCLENBTEc7UUFNUkQsVUFBVUMsS0FBVixDQUFnQmpNLE9BQU9DLElBQVAsQ0FBWTJPLEtBQVosQ0FBaEIsRUFBb0NjLFVBTjVCO1FBT1IxRCxVQUFVQyxLQUFWLENBQWdCak0sT0FBT0MsSUFBUCxDQUFZeWpCLGtCQUFaLENBQWhCO0NBUFI7O0lDckRxQk07Ozs7Ozs7Ozs7Ozs7OzZMQVluQi9SLFFBQWU7Y0FDTCxLQURLO2VBRUosS0FGSTtlQUdKO2FBR1hpRixhQUFhO2FBQU0sTUFBSy9FLFFBQUwsQ0FBYyxFQUFFZ0YsU0FBUyxLQUFYLEVBQWQsQ0FBTjthQUViQyxjQUFjLFlBQU07WUFDYmpGLFFBQUwsQ0FBYyxFQUFFZ0YsU0FBUyxJQUFYLEVBQWQ7YUFHRjhNLGtCQUFrQixZQUFNO1lBQ2pCOVIsUUFBTCxDQUFjLEVBQUV1RSxRQUFRLElBQVYsRUFBZDthQUdGTCxtQkFBbUIsWUFBTTtZQUNsQmxFLFFBQUwsQ0FBYyxFQUFFb0UsU0FBUyxJQUFYLEVBQWQ7YUFHRkMsbUJBQW1CLFlBQU07WUFDbEJyRSxRQUFMLENBQWM7Z0JBQ0osS0FESTtpQkFFSDtPQUZYO2FBTUYrUixnQkFBZ0IsWUFBTTtZQUNmL1IsUUFBTCxDQUFjLEVBQUV1RSxRQUFRLEtBQVYsRUFBZDs7Ozs7OzZCQUdPO21CQVVILEtBQUs5VyxLQVZGO1VBRUx3VixxQkFGSyxVQUVMQSxxQkFGSztVQUdMQyxxQkFISyxVQUdMQSxxQkFISztVQUlMdkcsa0JBSkssVUFJTEEsa0JBSks7VUFLTHlSLE9BTEssVUFLTEEsT0FMSztVQU1Mc0QsU0FOSyxVQU1MQSxTQU5LO1VBT0w3VSxJQVBLLFVBT0xBLElBUEs7VUFRTG5QLElBUkssVUFRTEEsSUFSSztVQVNMMFYsT0FUSyxVQVNMQSxPQVRLO21CQVk4QixLQUFLdEQsS0FabkM7VUFZQ3lFLE1BWkQsVUFZQ0EsTUFaRDtVQVlTUyxPQVpULFVBWVNBLE9BWlQ7VUFZa0JaLE9BWmxCLFVBWWtCQSxPQVpsQjs7O2FBZUx6Szs7OzJCQUNpQnNKLHFCQURqQjsyQkFFaUJDLHFCQUZqQjt3QkFHY3ZHLGtCQUhkO3FCQUlhL1AsVUFBTzZXLE1BSnBCO2tCQUtVLEtBQUtzQixVQUxmOzs7Ozs7Ozs7OztZQU1XO21CQUFTM0IsV0FBV0EsUUFBUSxFQUFFWSxZQUFGLEVBQVIsQ0FBcEI7V0FBVCxDQU5GO21CQU9XLEtBQUtpQixXQVBoQjt1QkFRZSxLQUFLNk0sZUFScEI7d0JBU2dCLEtBQUs1TixnQkFUckI7d0JBVWdCLEtBQUtHLGdCQVZyQjtxQkFXYSxLQUFLME4sYUFYbEI7Z0JBWU87OzRCQUVKLEdBQUQ7a0JBQ1V4TixNQURWO21CQUVXNkosT0FGWDttQkFHV3BKLE9BSFg7bUJBSVdaLE9BSlg7cUJBS2FzTixTQUxiO2dCQU1RN1UsSUFOUjtnQkFPUW5QOztPQXRCWjs7OztFQXpEb0NtUjs7QUFBbkJnVCxXQUNaNVgsWUFBWTt5QkFDTUosVUFBVVMsSUFEaEI7eUJBRU1ULFVBQVVTLElBRmhCO3NCQUdHVCxVQUFVWSxNQUFWLENBQWlCOEMsVUFIcEI7V0FJUjFELFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxhQUFELEVBQWdCLFdBQWhCLEVBQTZCLE9BQTdCLENBQWhCLENBSlE7UUFLWEQsVUFBVUMsS0FBVixDQUFnQmpNLE9BQU9DLElBQVAsQ0FBWTJPLEtBQVosQ0FBaEIsRUFBb0NjLFVBTHpCO2FBTU4xRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsS0FBckIsRUFBNEIsTUFBNUIsRUFBb0MsT0FBcEMsQ0FBaEIsQ0FOTTtXQU9SRCxVQUFVaUYsSUFQRjtRQVFYakYsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQjs7Ozs7QUN2QkssU0FBU2tZLEtBQVQsQ0FBZXZrQixLQUFmLEVBQTZCO01BQ2xDNkwsUUFEa0MsR0FDWjdMLEtBRFksQ0FDbEM2TCxRQURrQztNQUN4QjJZLE9BRHdCLEdBQ1p4a0IsS0FEWSxDQUN4QndrQixPQUR3Qjs7O1NBSXhDdFk7O01BQU8sV0FBVy9NLFVBQU9zbEIsS0FBekIsRUFBZ0MsU0FBU0QsT0FBekM7O0dBREY7OztBQU9GRCxNQUFNL1gsU0FBTixHQUFrQjtZQUNOSixVQUFVSyxJQURKO1dBRVBMLFVBQVVZLE1BQVYsQ0FBaUI4QztDQUY1Qjs7SUNacUI0VTs7O2lCQUNQMWtCLEtBQVosRUFBMEI7Ozs2R0FDbEJBLEtBRGtCOztVQUVuQnNZLEVBQUwsR0FBVW1ILFNBQVNrRixhQUFULENBQXVCLEtBQXZCLENBQVY7Ozs7Ozt3Q0FHa0I7VUFDZGxGLFNBQVNtRixJQUFiLEVBQW1CO2lCQUNSQSxJQUFULENBQWNDLFdBQWQsQ0FBMEIsS0FBS3ZNLEVBQS9COzs7OzsyQ0FJbUI7VUFDakJtSCxTQUFTbUYsSUFBYixFQUFtQjtpQkFDUkEsSUFBVCxDQUFjRSxXQUFkLENBQTBCLEtBQUt4TSxFQUEvQjs7Ozs7NkJBTUs7VUFDQ3pNLFFBREQsR0FDYyxLQUFLN0wsS0FEbkIsQ0FDQzZMLFFBREQ7O2FBRUFrWixzQkFBYWxaLFFBQWIsRUFBdUIsS0FBS3lNLEVBQTVCLENBQVA7Ozs7RUF0QitCbEg7O0FDSG5DOzs7Ozs7Ozs7QUFTQSxJQUFNNFQsY0FBYyxTQUFkQSxXQUFjLENBQUMvWixLQUFELEVBQVF4QyxNQUFSO1NBQW1Cd0MsUUFBUXhDLE1BQTNCO0NBQXBCOztBQVNBLEFBQWUsU0FBU3djLFNBQVQsT0FLTDtNQUpScFosUUFJUSxRQUpSQSxRQUlRO01BSFJxWixrQkFHUSxRQUhSQSxrQkFHUTtNQUZSemMsTUFFUSxRQUZSQSxNQUVRO01BRFJ3QyxLQUNRLFFBRFJBLEtBQ1E7O01BQ0ZrYSxzQkFBc0JILFlBQVkvWixLQUFaLEVBQW1CeEMsTUFBbkIsQ0FBNUI7O01BRUkyYyxzQkFBSjtNQUNJQyxxQkFBSjs7TUFFSUgscUJBQXFCQyxtQkFBekIsRUFBOEM7bUJBQzdCbGEsS0FBZjtvQkFDZ0JBLFFBQVFpYSxrQkFBeEI7R0FGRixNQUdPO21CQUNVemMsU0FBU3ljLGtCQUF4QjtvQkFDZ0J6YyxNQUFoQjs7O01BR0k0WixZQUFZLENBQUMrQyxnQkFBZ0IzYyxNQUFqQixJQUEyQixDQUFDLENBQTlDO01BQ00yWixhQUFhLENBQUNpRCxlQUFlcGEsS0FBaEIsSUFBeUIsQ0FBQyxDQUE3Qzs7U0FHRWlCO1FBQUE7TUFBTSxPQUFPakIsS0FBYixFQUFvQixRQUFReEMsTUFBNUI7OztRQUNPLE9BQU8sRUFBRTdHLFdBQVd5Z0IsU0FBYixFQUF3QnRnQixZQUFZcWdCLFVBQXBDLEVBQVo7O1lBQ0U7VUFBTSxPQUFPaUQsWUFBYixFQUEyQixRQUFRRCxhQUFuQzs7OztHQUhOOzs7QUFXRkgsVUFBVXpZLFNBQVYsR0FBc0I7WUFDVkosVUFBVUssSUFEQTtzQkFFQUwsVUFBVVUsTUFBVixDQUFpQmdELFVBRmpCO1VBR1oxRCxVQUFVVSxNQUFWLENBQWlCZ0QsVUFITDtTQUliMUQsVUFBVVUsTUFBVixDQUFpQmdEO0NBSjFCOzs7O0FDdENBLElBQU13VixlQUFlLENBQXJCOztJQUVxQkM7Ozs7Ozs7Ozs7Ozs7O2lMQVNuQmxULFFBQWU7eUJBQ007YUFHckJtVCxjQUFjLFVBQUNqUCxLQUFELEVBQWtDO3dCQUNwQixNQUFLdlcsS0FEZTtVQUN0Q3lsQixJQURzQyxlQUN0Q0EsSUFEc0M7VUFDaEM5UCxPQURnQyxlQUNoQ0EsT0FEZ0M7O1VBRTFDQSxXQUFXOFAsSUFBZixFQUFxQjtnQkFDWCxFQUFFbFAsWUFBRixFQUFSOzthQUlKOE4sa0JBQWtCLFlBQU07eUJBQ0csTUFBS3JrQixLQURSO1VBQ2R5bEIsSUFEYyxnQkFDZEEsSUFEYztVQUNSck8sTUFEUSxnQkFDUkEsTUFEUTs7VUFFbEJBLFdBQVcsT0FBWCxJQUFzQnFPLElBQTFCLEVBQWdDO2NBQ3pCbFQsUUFBTCxDQUFjLEVBQUVtVCxtQkFBbUIsS0FBckIsRUFBZDs7YUFJSkMsY0FBYyxVQUFDcFAsS0FBRCxFQUFxQzt5QkFDeEIsTUFBS3ZXLEtBRG1CO1VBQ3pDeWxCLElBRHlDLGdCQUN6Q0EsSUFEeUM7VUFDbkNyTyxNQURtQyxnQkFDbkNBLE1BRG1DOztVQUU3Q0EsV0FBVyxPQUFYLElBQXNCYixNQUFNcUwsT0FBTixLQUFrQjBELFlBQXhDLElBQXdERyxJQUE1RCxFQUFrRTtjQUMzRGxULFFBQUwsQ0FBYyxFQUFFbVQsbUJBQW1CLElBQXJCLEVBQWQ7Ozs7Ozs7NkJBSUs7bUJBQ21ELEtBQUsxbEIsS0FEeEQ7VUFDQzZMLFFBREQsVUFDQ0EsUUFERDtpQ0FDV3dELE1BRFg7VUFDV0EsTUFEWCxpQ0FDb0IsS0FEcEI7aUNBQzJCK0gsTUFEM0I7VUFDMkJBLE1BRDNCLGlDQUNvQyxJQURwQztVQUMwQ3FPLElBRDFDLFVBQzBDQSxJQUQxQzs7VUFFREcsTUFBTXhPLFdBQVcsT0FBWCxHQUFxQixxQkFBckIsR0FBNkMsSUFBekQ7VUFDTXlPLGFBQWF6TyxlQUFhQSxNQUFiLEdBQXdCLElBQTNDOzthQUdFbEw7OztxQkFDYXVGLFdBQ1R0UyxVQUFPMm1CLElBREUsRUFFVCxLQUFLelQsS0FBTCxDQUFXcVQsaUJBQVgsR0FBK0J2bUIsVUFBTzRtQixvQkFBdEMsR0FBNkQsRUFGcEQsRUFHVDFXLFNBQVMsRUFBVCxHQUFjbFEsVUFBT21YLEtBSFosQ0FEYjtnQkFNUW1QLElBTlI7dUJBT2UsS0FBS3BCLGVBUHBCO21CQVFXLEtBQUtzQixXQVJoQjttQkFTVyxLQUFLSCxXQVRoQjtlQVVPSSxHQVZQO2tCQVdVQzs7O09BWlo7Ozs7RUF2QzhCelU7O0FBQWJtVSxLQUNaL1ksWUFBWTtZQUNQSixVQUFVSyxJQUFWLENBQWVxRCxVQURSO1FBRVgxRCxVQUFVWSxNQUFWLENBQWlCOEMsVUFGTjtVQUdUMUQsVUFBVVMsSUFIRDtXQUlSVCxVQUFVaUYsSUFKRjtVQUtUakYsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsT0FBZixDQUFoQjs7O0FDMUJaOzs7Ozs7Ozs7Ozs7SUF5QnFCMlo7Ozs7Ozs7Ozs7Ozs7OzZMQWtCbkJ6TixRQUFRLFlBQU07d0JBUVIsTUFBS3ZZLEtBUkc7VUFFVmltQixlQUZVLGVBRVZBLGVBRlU7VUFHVkMsT0FIVSxlQUdWQSxPQUhVO1VBSVZDLFVBSlUsZUFJVkEsVUFKVTtVQUtWQyxTQUxVLGVBS1ZBLFNBTFU7VUFNVkMsWUFOVSxlQU1WQSxZQU5VO1VBT1Z4RyxTQVBVLGVBT1ZBLFNBUFU7OztVQVVScUcsV0FBV0MsVUFBWCxJQUF5QixDQUFDQyxTQUE5QixFQUF5Qzs7O1VBR25DRSxlQUFlTCxrQkFBa0IsQ0FBdkM7O1VBRUlwRyxZQUFZeUcsWUFBWixHQUEyQkQsWUFBL0IsRUFBNkM7Ozs7Ozs7O3dDQXZCM0I7aUJBQ1AsS0FBSzlOLEtBQWhCOzs7O3lDQUdtQjtXQUNkQSxLQUFMOzs7OzZCQXVCTzthQUNBLElBQVA7Ozs7RUF2Q29Dbkg7O0FBQW5CNFUsV0FDWnhaLFlBQVk7bUJBQ0FKLFVBQVVVLE1BQVYsQ0FBaUJnRCxVQURqQjtXQUVSMUQsVUFBVVMsSUFGRjtjQUdMVCxVQUFVUyxJQUFWLENBQWVpRCxVQUhWO2FBSU4xRCxVQUFVaUYsSUFKSjtnQkFLSGpGLFVBQVVVLE1BQVYsQ0FBaUJnRCxVQUxkO2FBTU4xRCxVQUFVVSxNQUFWLENBQWlCZ0Q7OztJQzdCWHlXOzs7U0FDbkJ6bUIsTUFBcUIsSUFBSTBtQixPQUFKOzs7OzsyQkFFakJuYixLQUFZO2FBQ1AsS0FBS3ZMLEdBQUwsQ0FBUzJtQixHQUFULENBQWFwYixHQUFiLENBQVA7Ozs7d0JBR0VBLEtBQWlCO2FBQ1osS0FBS3ZMLEdBQUwsQ0FBUzRtQixHQUFULENBQWFyYixHQUFiLENBQVA7Ozs7MkJBR0VBLEtBQVF0SCxPQUFnQjtXQUNyQmpFLEdBQUwsQ0FBUzZtQixHQUFULENBQWF0YixHQUFiLEVBQWtCdEgsS0FBbEI7Ozs7NEJBR1k7V0FDUGpFLEdBQUwsR0FBVyxJQUFJMG1CLE9BQUosRUFBWDs7Ozs7O0FDbkJKOzs7Ozs7QUFPQSxBQUFlLFNBQVNJLFFBQVQsQ0FDYmpuQixFQURhLEVBR2I7TUFEQWtuQixVQUNBLHVFQURxQixHQUNyQjs7TUFDSUMsYUFBK0IsSUFBbkM7O01BRU1DLFlBQVksU0FBWkEsU0FBWSxHQUFnQjtzQ0FBWkMsSUFBWTtVQUFBOzs7UUFDNUJGLFVBQUosRUFBZ0I7bUJBQ0RBLFVBQWI7OztpQkFHV0csV0FBVyxZQUFNO21CQUNmLElBQWI7NENBQ01ELElBQU47S0FGVyxFQUdWSCxVQUhVLENBQWI7R0FMRjs7WUFXVUssWUFBVixHQUF5QixZQUFNO1FBQ3pCSixVQUFKLEVBQWdCO21CQUNEQSxVQUFiOztHQUZKOztTQU1PQyxTQUFQOzs7OztBQzlCRjs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsU0FBU0ksa0JBQVQsQ0FBNEJDLGVBQTVCLEVBQTZDO1NBQ3BDLE9BQU9BLGVBQVAsS0FBMkIsVUFBM0IsR0FDSEEsaUJBREcsR0FFSEEsZUFGSjs7O0lBS21CQzs7Ozs7Ozs7Ozs7Ozs7dU1BNEJuQkMsd0JBQXdCO2FBQU0sTUFBS0YsZUFBWDthQUV4QkcsZUFBZSxVQUFDaFIsS0FBRCxFQUFrQjtZQUMxQnZXLEtBQUwsQ0FBV3duQixRQUFYLENBQW9CalIsS0FBcEI7Ozs7Ozt3Q0F2QmtCO1VBQ1o2USxrQkFBa0JELG1CQUFtQixLQUFLbm5CLEtBQUwsQ0FBV29uQixlQUE5QixDQUF4QjtVQUNJQSxlQUFKLEVBQXFCO2FBQ2RLLHFCQUFMLENBQTJCTCxlQUEzQjs7Ozs7eUNBSWlCO1VBQ2JNLHNCQUFzQlAsbUJBQW1CLEtBQUtubkIsS0FBTCxDQUFXb25CLGVBQTlCLENBQTVCO1VBQ0lNLHVCQUF1QkEsd0JBQXdCLEtBQUtOLGVBQXhELEVBQXlFO2FBQ2xFSyxxQkFBTCxDQUEyQkMsbUJBQTNCOzs7OzsyQ0FJbUI7VUFDakIsS0FBS04sZUFBVCxFQUEwQjthQUNuQkEsZUFBTCxDQUFxQjFHLG1CQUFyQixDQUF5QyxRQUF6QyxFQUFtRCxLQUFLNkcsWUFBeEQ7Ozs7OzBDQVVrQkgsaUJBQThCO1VBQzlDLEtBQUtBLGVBQVQsRUFBMEI7O2FBRW5CQSxlQUFMLENBQXFCMUcsbUJBQXJCLENBQXlDLFFBQXpDLEVBQW1ELEtBQUs2RyxZQUF4RDs7V0FFR0gsZUFBTCxHQUF1QkEsZUFBdkI7V0FDS0EsZUFBTCxDQUFxQjlHLGdCQUFyQixDQUFzQyxRQUF0QyxFQUFnRCxLQUFLaUgsWUFBckQ7Ozs7NkJBS087YUFDQW5XLGNBQUEsQ0FBZXVXLElBQWYsQ0FBb0IsS0FBSzNuQixLQUFMLENBQVc2TCxRQUEvQixDQUFQOzs7O0VBOUN5Q3VGOztBQUF4QmlXLGdCQUNaN2EsWUFBWTtZQUNQSixVQUFVSyxJQUFWLENBQWVxRCxVQURSO1lBRVAxRCxVQUFVaUYsSUFBVixDQUFldkIsVUFGUjttQkFHQTFELFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVU8sTUFBWCxFQUFtQlAsVUFBVWlGLElBQTdCLENBQXBCLEVBQ2R2Qjs7O0FDbkNQOzs7Ozs7QUFPQSxBQUFlLFNBQVM4WCxRQUFULENBQ2Jqb0IsRUFEYSxFQUdiO01BREFrbkIsVUFDQSx1RUFEcUIsR0FDckI7O01BQ0lnQixhQUFKO01BQ0lmLG1CQUFKO01BQ01nQixZQUFZLFNBQVpBLFNBQVksR0FBZ0I7c0NBQVpkLElBQVk7VUFBQTs7O1FBQzFCZSxNQUFNQyxLQUFLRCxHQUFMLEVBQVo7UUFDSUYsU0FBU2pZLFNBQVQsSUFBc0JtWSxNQUFNRixJQUFOLEdBQWFoQixVQUF2QyxFQUFtRDttQkFDcENDLFVBQWI7bUJBQ2FHLFdBQVcsWUFBTTtlQUNyQmMsR0FBUDs4Q0FDTWYsSUFBTjtPQUZXLEVBR1ZILGNBQWNrQixNQUFNRixJQUFwQixDQUhVLENBQWI7S0FGRixNQU1PO2FBQ0VFLEdBQVA7NENBQ01mLElBQU47O0dBVko7O1lBY1VFLFlBQVYsR0FBeUIsWUFBTTtRQUN6QkosVUFBSixFQUFnQjttQkFDREEsVUFBYjs7R0FGSjs7U0FNT2dCLFNBQVA7OztBQ2pDRjs7Ozs7O0FBT0EsQUFBTyxTQUFTRyxnQkFBVCxDQUEwQkMsT0FBMUIsRUFBd0Q7U0FDdERBLFlBQVkxWCxNQUFaLEdBQXFCQSxPQUFPc1AsV0FBNUIsR0FBMENvSSxRQUFRbEksWUFBekQ7OztBQUdGLEFBQU8sU0FBU21JLGtCQUFULEdBQThCO01BQy9CM1gsT0FBTzJPLE9BQVAsS0FBbUJ2UCxTQUF2QixFQUFrQzs7V0FFekJZLE9BQU8yTyxPQUFkOztNQUdBTSxTQUFTQyxlQUFULElBQ0FELFNBQVNDLGVBQVQsQ0FBeUJHLFNBQXpCLEtBQXVDalEsU0FGekMsRUFHRTs7V0FFTzZQLFNBQVNDLGVBQVQsQ0FBeUJHLFNBQWhDOztTQUVLLENBQVA7OztBQUdGLEFBQU8sU0FBU3VJLG9CQUFULENBQThCRixPQUE5QixFQUE0RDtTQUMxREEsWUFBWTFYLE1BQVosR0FDSDJYLG9CQURHLEdBRUhELFFBQVFySSxTQUFSLEdBQW9CcUksUUFBUS9GLHFCQUFSLEdBQWdDL1ksR0FGeEQ7OztBQUtGLEFBQU8sU0FBU2lmLGVBQVQsQ0FBeUJILE9BQXpCLEVBQXVEO1NBQ3JEQSxZQUFZMVgsTUFBWixJQUFzQmlQLFNBQVNDLGVBQS9CLEdBQ0hELFNBQVNDLGVBQVQsQ0FBeUIyRyxZQUR0QixHQUVINkIsUUFBUTdCLFlBRlo7OztBQUtGLEFBQU8sU0FBU2lDLFlBQVQsQ0FBc0JKLE9BQXRCLEVBQW9EO1NBQ2xEQSxZQUFZMVgsTUFBWixHQUFxQjJYLG9CQUFyQixHQUE0Q0QsUUFBUXJJLFNBQTNEOzs7QUN0Q0ssSUFBTTBJLHNCQUFzQkMsT0FBTyxTQUFQLENBQTVCO0FBQ1AsQUFBTyxJQUFNQyx5QkFBeUJELE9BQU8sWUFBUCxDQUEvQjs7QUNRUCxJQUFNck8sV0FBUyxTQUFUQSxNQUFTLE1BQU87TUFDaEJiLE1BQU0sQ0FBVjtPQUNLLElBQUllLElBQUksQ0FBYixFQUFnQkEsSUFBSS9PLElBQUloTCxNQUF4QixFQUFnQytaLEtBQUssQ0FBckMsRUFBd0M7UUFDbEMvTyxJQUFJK08sQ0FBSixJQUFTL08sSUFBSWdPLEdBQUosQ0FBYixFQUF1QjtZQUNmZSxDQUFOOzs7U0FHR2YsR0FBUDtDQVBGOztBQVVBLElBQU1vUCxZQUFZLFNBQVpBLFNBQVksQ0FBQ3pkLEtBQUQ7TUFBUXhDLE1BQVIsdUVBQWlCa2dCLFFBQWpCO1NBQStCO1NBQzFDLENBQUMsSUFEeUM7VUFFekMsQ0FBQyxJQUZ3QztnQkFBQTs7R0FBL0I7Q0FBbEI7O0FBT0EscUJBQWU7TUFDYkMsS0FEYSxRQUNiQSxLQURhOzhCQUViQyxXQUZhO01BRWJBLFdBRmEsb0NBRUMsR0FGRDt5QkFHYjVPLE1BSGE7TUFHYkEsTUFIYSwrQkFHSixFQUhJOzBCQUliNk8sT0FKYTtNQUliQSxPQUphLGdDQUlILENBSkc7TUFLYjdkLEtBTGEsUUFLYkEsS0FMYTtTQVlSLFVBQUNtTyxLQUFELEVBQXNDO1FBQ3ZDbk8sU0FBUyxJQUFiLEVBQW1CO2FBQ1ZtTyxNQUFNdFosR0FBTixDQUFVO2VBQU00b0IsVUFBVUcsV0FBVixDQUFOO09BQVYsQ0FBUDs7O1FBR0lFLHVCQUF1QkYsY0FBYzVPLE1BQTNDO1FBQ00rTyxjQUFjL25CLEtBQUsrWCxHQUFMLENBQ2xCL1gsS0FBS2dvQixLQUFMLENBQVcsQ0FBQ2hlLFFBQVFnUCxNQUFULElBQW1COE8sb0JBQTlCLENBRGtCLEVBRWxCRCxPQUZrQixDQUFwQjs7UUFLTUksVUFBVSxJQUFJdHBCLEtBQUosQ0FBVW9wQixXQUFWLEVBQXVCL04sSUFBdkIsQ0FBNEIsQ0FBNUIsQ0FBaEI7UUFDTWtPLGVBQWVsb0IsS0FBSytYLEdBQUwsQ0FDbkIvWCxLQUFLZ29CLEtBQUwsQ0FBVyxDQUFDaGUsUUFBUThkLHVCQUF1QkMsV0FBL0IsR0FBNkMvTyxNQUE5QyxJQUF3RCxDQUFuRSxDQURtQixFQUVuQixDQUZtQixDQUFyQjs7V0FLT2IsTUFBTWhhLE1BQU4sQ0FBYSxVQUFDc00sR0FBRCxFQUFNdU4sSUFBTixFQUFlO1VBQzNCaUIsWUFBWXhPLEdBQWxCOztVQUVNakQsU0FBU21nQixNQUFNbkMsR0FBTixDQUFVeE4sSUFBVixDQUFmO1VBQ0lJLGlCQUFKOztVQUVJNVEsVUFBVSxJQUFkLEVBQW9CO21CQUNQaWdCLFVBQVVHLFdBQVYsQ0FBWDtPQURGLE1BRU87WUFDQ08sa0JBQWtCM2dCLFNBQVN3UixNQUFqQztZQUNNa0IsTUFBTWhCLFNBQU8rTyxPQUFQLENBQVo7WUFDTTlmLE9BQU04ZixRQUFRL04sR0FBUixDQUFaO1lBQ003UixRQUFPNlIsTUFBTTROLG9CQUFOLEdBQTZCSSxZQUExQzs7Z0JBRVFoTyxHQUFSLEtBQWdCaU8sZUFBaEI7bUJBQ1csRUFBRWhnQixTQUFGLEVBQU9FLFdBQVAsRUFBYTJCLE9BQU80ZCxXQUFwQixFQUFpQ3BnQixjQUFqQyxFQUFYOztnQkFFUThRLElBQVYsQ0FBZUYsUUFBZjthQUNPYSxTQUFQO0tBbEJLLEVBbUJKLEVBbkJJLENBQVA7R0E3QmE7Q0FBZjs7QUN0QkEsSUFBTXdPLGNBQVksU0FBWkEsU0FBWSxDQUFDemQsS0FBRDtNQUFReEMsTUFBUix1RUFBaUJrZ0IsUUFBakI7U0FBK0I7U0FDMUMsQ0FBQyxJQUR5QztVQUV6QyxDQUFDLElBRndDO2dCQUFBOztHQUEvQjtDQUFsQjs7QUFPQSx3QkFBZTtNQUNiQyxLQURhLFFBQ2JBLEtBRGE7OEJBRWJDLFdBRmE7TUFFYkEsV0FGYSxvQ0FFQyxHQUZEO3lCQUdiNU8sTUFIYTtNQUdiQSxNQUhhLCtCQUdKLEVBSEk7TUFJYmhQLEtBSmEsUUFJYkEsS0FKYTswQkFLYjZkLE9BTGE7TUFLYkEsT0FMYSxnQ0FLSCxDQUxHO1NBWVIsVUFBQzFQLEtBQUQsRUFBc0M7UUFDdkNuTyxTQUFTLElBQWIsRUFBbUI7YUFDVm1PLE1BQU10WixHQUFOLENBQVU7ZUFBTTRvQixZQUFVRyxXQUFWLENBQU47T0FBVixDQUFQOzs7UUFHSUUsdUJBQXVCRixjQUFjNU8sTUFBM0M7UUFDTStPLGNBQWMvbkIsS0FBSytYLEdBQUwsQ0FDbEIvWCxLQUFLZ29CLEtBQUwsQ0FBVyxDQUFDaGUsUUFBUWdQLE1BQVQsSUFBbUI4TyxvQkFBOUIsQ0FEa0IsRUFFbEJELE9BRmtCLENBQXBCOztRQUtNNU8sWUFBWSxFQUFsQjtRQUNNZ1AsVUFBVSxFQUFoQjs7U0FFSyxJQUFJN08sSUFBSSxDQUFiLEVBQWdCQSxJQUFJakIsTUFBTTlZLE1BQTFCLEVBQWtDK1osS0FBSyxDQUF2QyxFQUEwQztVQUNwQ2hCLGlCQUFKO1VBQ001USxVQUFTbWdCLE1BQU1uQyxHQUFOLENBQVVyTixNQUFNaUIsQ0FBTixDQUFWLENBQWY7O1VBRUk1UixXQUFVLElBQWQsRUFBb0I7bUJBQ1BpZ0IsWUFBVUcsV0FBVixDQUFYO09BREYsTUFFTztZQUNDN2tCLFNBQVNxVyxJQUFJMk8sV0FBbkI7WUFDTUssTUFBTXBvQixLQUFLZ29CLEtBQUwsQ0FBVzVPLElBQUkyTyxXQUFmLENBQVo7O1lBRUlobEIsV0FBVyxDQUFYLElBQWdCeUUsVUFBU3lnQixRQUFRRyxHQUFSLENBQTdCLEVBQTJDO2tCQUNqQ0EsR0FBUixJQUFlNWdCLE9BQWY7OztZQUdJVyxPQUNKaWdCLE1BQU0sQ0FBTixHQUNJSCxRQUFRSSxLQUFSLENBQWMsQ0FBZCxFQUFpQkQsR0FBakIsRUFBc0JqcUIsTUFBdEIsQ0FBNkIsVUFBQ21xQixHQUFELEVBQU1wZixDQUFOO2lCQUFZb2YsTUFBTXBmLENBQU4sR0FBVThQLE1BQXRCO1NBQTdCLEVBQTJELENBQTNELENBREosR0FFSSxDQUhOOzttQkFLVzttQkFBQTtnQkFFSGpXLFNBQVMra0Isb0JBRk47aUJBR0ZGLFdBSEU7O1NBQVg7O2dCQU9RdFAsSUFBVixDQUFlRixRQUFmOztXQUVLYSxTQUFQO0dBdERhO0NBQWY7O0FDUEEsSUFBTUMsV0FBUyxTQUFUQSxNQUFTLE1BQU87TUFDaEJiLE1BQU0sQ0FBVjtPQUNLLElBQUllLElBQUksQ0FBYixFQUFnQkEsSUFBSS9PLElBQUloTCxNQUF4QixFQUFnQytaLEtBQUssQ0FBckMsRUFBd0M7UUFDbEMvTyxJQUFJK08sQ0FBSixJQUFTL08sSUFBSWdPLEdBQUosQ0FBYixFQUF1QjtZQUNmZSxDQUFOOzs7U0FHR2YsR0FBUDtDQVBGOztBQVVBLHVCQUFlLGdCQVlSO3lCQVhMVyxNQVdLO01BWExBLE1BV0ssK0JBWEksQ0FXSjtNQVZMMk8sS0FVSyxRQVZMQSxLQVVLOzBCQVRMRSxPQVNLO01BVExBLE9BU0ssZ0NBVEssQ0FTTDttQ0FSTFUsZ0JBUUs7TUFSTEEsZ0JBUUsseUNBUmMsR0FRZDtNQVBMdmUsS0FPSyxRQVBMQSxLQU9LOztNQUNEQSxTQUFTLElBQWIsRUFBbUI7V0FDVixVQUFDbU8sS0FBRDthQUNMQSxNQUFNdFosR0FBTixDQUFVO2VBQU87ZUFDVjZvQixRQURVO2dCQUVUQSxRQUZTO2lCQUdSQSxRQUhRO2tCQUlQQTtTQUpBO09BQVYsQ0FESztLQUFQOzs7Ozs7TUFZSWMsV0FBV3hvQixLQUFLZ29CLEtBQUwsQ0FBV2hlLFFBQVF1ZSxnQkFBbkIsQ0FBakI7TUFDTVIsY0FBYy9uQixLQUFLK1gsR0FBTCxDQUNsQi9YLEtBQUtnb0IsS0FBTCxDQUFXLENBQUNoZSxRQUFRd2UsV0FBV3hQLE1BQXBCLElBQThCdVAsZ0JBQXpDLENBRGtCLEVBRWxCVixPQUZrQixDQUFwQjtNQUlNRCxjQUFjNW5CLEtBQUtnb0IsS0FBTCxDQUFXaGUsUUFBUStkLFdBQW5CLENBQXBCOztTQUVPLFVBQUM1UCxLQUFELEVBQXFCOztRQUVwQjhQLFVBQVUsSUFBSXRwQixLQUFKLENBQVVvcEIsV0FBVixFQUF1Qi9OLElBQXZCLENBQTRCLENBQTVCLENBQWhCOztXQUVPN0IsTUFBTWhhLE1BQU4sQ0FBYSxVQUFDc00sR0FBRCxFQUFNdU4sSUFBTixFQUFlO1VBQzNCaUIsWUFBWXhPLEdBQWxCO1VBQ01qRCxTQUFTbWdCLE1BQU1uQyxHQUFOLENBQVV4TixJQUFWLENBQWY7VUFDSUksaUJBQUo7O1VBRUk1USxVQUFVLElBQWQsRUFBb0I7bUJBQ1A7ZUFDSmtnQixRQURJO2dCQUVIQSxRQUZHO2lCQUdGRSxXQUhFO2tCQUlERjtTQUpWO09BREYsTUFPTztZQUNDeE4sTUFBTWhCLFNBQU8rTyxPQUFQLENBQVo7WUFDTTlmLE9BQU04ZixRQUFRL04sR0FBUixDQUFaO1lBQ003UixRQUFPNlIsTUFBTTBOLFdBQU4sR0FBb0I1TyxTQUFTLENBQTFDOztnQkFFUWtCLEdBQVIsS0FBZ0IxUyxNQUFoQjttQkFDVzttQkFBQTtxQkFBQTtpQkFHRm9nQixjQUFjNU8sTUFIWjs7U0FBWDs7O2dCQVFRVixJQUFWLENBQWVGLFFBQWY7YUFDT2EsU0FBUDtLQTNCSyxFQTRCSixFQTVCSSxDQUFQO0dBSkY7Q0FqQ0Y7O0lDZHFCd1A7Ozs7SUNBQUM7Ozs7QUM2RXJCLElBQU1DLGtCQUFrQixHQUF4Qjs7O0FBR0EsSUFBTUMsd0JBQXdCLEdBQTlCOztBQUVBLElBQU1DLDZCQUE2QixTQUE3QkEsMEJBQTZCO1NBQU05b0IsTUFBTTJuQixRQUFOLEdBQWlCM25CLENBQWpCLEdBQXFCNE8sU0FBM0I7Q0FBbkM7O0FBRUEsU0FBU21hLFdBQVQsY0FVRTtNQVJFbEIsV0FRRixRQVJFQSxXQVFGO01BUEVtQixRQU9GLFFBUEVBLFFBT0Y7TUFOZS9QLE1BTWYsUUFORWdRLFdBTUY7TUFMRS9qQixNQUtGLFFBTEVBLE1BS0Y7TUFKRWdrQixnQkFJRixRQUpFQSxnQkFJRjtNQUhFcEIsT0FHRixRQUhFQSxPQUdGO01BREU3ZCxLQUNGLFNBREVBLEtBQ0Y7O01BQ0krZSxZQUFZL2UsVUFBVSxJQUExQixFQUFnQztXQUN2QmtmLGdCQUFnQjtvQkFBQTthQUVkRCxnQkFGYztzQkFBQTt3QkFJSHJCLFdBSkc7O0tBQWhCLENBQVA7O01BU0EzaUIsV0FBV3VpQixzQkFBWCxJQUNBdmlCLGtCQUFrQmtrQixnQkFGcEIsRUFHRTtXQUNPQyxpQkFBaUI7YUFDZkgsZ0JBRGU7OEJBQUE7b0JBQUE7c0JBQUE7O0tBQWpCLENBQVA7O1NBUUtJLGNBQWM7V0FDWkosZ0JBRFk7NEJBQUE7a0JBQUE7b0JBQUE7O0dBQWQsQ0FBUDs7O0FBU0YsU0FBU0ssa0JBQVQsQ0FBK0J2cUIsS0FBL0IsRUFBZ0RxUyxLQUFoRCxFQUFpRTtNQUN2RDZYLGdCQUR1RCxHQUN6QmxxQixLQUR5QixDQUN2RGtxQixnQkFEdUQ7TUFDckNwQixPQURxQyxHQUN6QjlvQixLQUR5QixDQUNyQzhvQixPQURxQztNQUV2RDFQLEtBRnVELEdBRTdDL0csS0FGNkMsQ0FFdkQrRyxLQUZ1RDs7OztNQUt6RG9SLGdCQUFnQnBSLE1BQU1xUixNQUFOLENBQ3BCO1dBQVF4UixRQUFRaVIsaUJBQWlCeEQsR0FBakIsQ0FBcUJ6TixJQUFyQixDQUFoQjtHQURvQixDQUF0Qjs7TUFJTS9TLFNBQVM2akIsWUFBWS9wQixLQUFaLEVBQW1CcVMsS0FBbkIsQ0FBZjtNQUNNcVksa0JBQWtCeGtCLE9BQU9za0IsYUFBUCxDQUF4Qjs7TUFFTS9oQixTQUFTaWlCLGdCQUFnQnBxQixNQUFoQixHQUNYVyxLQUFLK1gsR0FBTCwrQkFBWTBSLGdCQUFnQjVxQixHQUFoQixDQUFvQjtXQUFPNnFCLElBQUl2aEIsR0FBSixHQUFVdWhCLElBQUlsaUIsTUFBckI7R0FBcEIsQ0FBWixFQURXLEdBRVgsQ0FGSjs7TUFJTW1pQixpQkFBaUJ4UixNQUNwQnFSLE1BRG9CLENBQ2I7V0FBUXhSLFFBQVEsQ0FBQ2lSLGlCQUFpQnhELEdBQWpCLENBQXFCek4sSUFBckIsQ0FBakI7R0FEYSxFQUVwQnFRLEtBRm9CLENBRWQsQ0FGYyxFQUVYUixPQUZXLENBQXZCO01BR00rQixxQkFBcUIza0IsT0FBTzBrQixjQUFQLENBQTNCOztTQUVPO2tCQUFBO2dDQUFBO2tDQUFBOzBDQUFBOztHQUFQOzs7Ozs7Ozs7OztJQWdCbUJFOzs7bUJBMkdQOXFCLEtBQVosRUFBNkI7OztpSEFDckJBLEtBRHFCOztVQXZHN0JnaUIsWUF1RzZCLEdBdkdkNEUsU0FBUyxZQUFNO1VBQ3hCLE1BQUttRSxXQUFULEVBQXNCO2NBQ2Z4WSxRQUFMLENBQWMsRUFBRXRILE9BQU8sTUFBSzhmLFdBQUwsQ0FBaUJDLFdBQTFCLEVBQWQ7O0tBRlcsRUFJWnBCLGVBSlksQ0F1R2M7VUFqRzdCcUIsb0JBaUc2QixHQWpHTnJELFNBQVMsWUFBTTtVQUNoQyxDQUFDLE1BQUtSLGVBQVYsRUFBMkI7OztVQUdyQkEsa0JBQWtCLE1BQUtBLGVBQUwsQ0FBcUJFLHFCQUFyQixFQUF4Qjs7VUFFSSxDQUFDRixlQUFMLEVBQXNCOzs7O1lBSWpCN1UsUUFBTCxDQUFjO21CQUNEK1YsYUFBYWxCLGVBQWI7T0FEYjs7WUFJSzhELGdDQUFMO0tBZHFCLENBaUdNO1VBaEY3QkMscUJBZ0Y2QixHQWhGTHZFLFNBQVMsWUFBTTtZQUNoQ3dFLGdCQUFMO0tBRHNCLEVBRXJCLENBRnFCLENBZ0ZLOztVQTZKN0JDLGlCQTdKNkIsR0E2SlQsVUFBQ0MsR0FBRCxFQUF1QjtZQUNwQ1AsV0FBTCxHQUFtQk8sR0FBbkI7S0E5SjJCOztVQWlLN0JDLHFCQWpLNkIsR0FpS0wsVUFBQ0QsR0FBRCxFQUEyQjtZQUM1Q2xFLGVBQUwsR0FBdUJrRSxHQUF2QjtLQWxLMkI7O1VBcUs3QkosZ0NBcks2QixHQXFLTSxZQUFNO3dCQUNiLE1BQUs3WSxLQURRO1VBQy9CNUosTUFEK0IsZUFDL0JBLE1BRCtCO1VBQ3ZCd0MsS0FEdUIsZUFDdkJBLEtBRHVCOztVQUdyQyxPQUFPLE1BQUtqTCxLQUFMLENBQVd3ckIsNEJBQWxCLEtBQW1ELFVBQW5ELElBQ0EsTUFBS3ZGLGVBRlAsRUFHRTtZQUNNd0YsWUFBVztlQUNWLE1BQUtwWixLQUFMLENBQVd3TixTQUREO2dCQUVULENBRlM7a0JBR1AsTUFBS29HLGVBSEU7aUJBSVJoYixTQUFTO1NBSmxCO1lBTU15Z0IsV0FBVTtlQUNULE1BQUtDLGVBREk7Z0JBRVIsQ0FGUTt3QkFBQTtpQkFJUDFnQixTQUFTO1NBSmxCOztjQU9LakwsS0FBTCxDQUFXd3JCLDRCQUFYLENBQXdDRSxRQUF4QyxFQUFpREQsU0FBakQ7O0tBeEx5Qjs7VUE0TDdCRywyQkE1TDZCLEdBNExDLFVBQUN2WixLQUFELEVBQTZCO1VBQ3JELE1BQUtyUyxLQUFMLENBQVc2ckIscUJBQWYsRUFBc0M7Y0FDL0I3ckIsS0FBTCxDQUFXNnJCLHFCQUFYLENBQWlDeFosS0FBakM7O0tBOUx5Qjs7VUEwTzdCeVosc0JBMU82QixHQTBPSixVQUFDQyxRQUFELEVBQWN6UyxHQUFkLEVBQTJCRCxRQUEzQixFQUEyQzt3QkFNOUQsTUFBS3JaLEtBTnlEO1VBRTFEZ3NCLFNBRjBELGVBRWhFQyxJQUZnRTtVQUdoRUMsVUFIZ0UsZUFHaEVBLFVBSGdFO1VBSWhFQyxnQkFKZ0UsZUFJaEVBLGdCQUpnRTtVQUtoRUMsbUJBTGdFLGVBS2hFQSxtQkFMZ0U7VUFPMURoakIsR0FQMEQsR0FPN0JpUSxRQVA2QixDQU8xRGpRLEdBUDBEO1VBT3JERSxJQVBxRCxHQU83QitQLFFBUDZCLENBT3JEL1AsSUFQcUQ7VUFPL0MyQixLQVArQyxHQU83Qm9PLFFBUDZCLENBTy9DcE8sS0FQK0M7VUFPeEN4QyxNQVB3QyxHQU83QjRRLFFBUDZCLENBT3hDNVEsTUFQd0M7OztVQVM5RDRqQixrQkFBSjtVQUNJLE1BQUtyc0IsS0FBTCxDQUFXb25CLGVBQWYsRUFBZ0M7WUFDeEJrRixnQkFBZ0IsTUFBS3JHLGVBQUwsR0FBdUI0RCxxQkFBN0M7WUFDTTBDLGtCQUFrQixNQUFLbGEsS0FBTCxDQUFXd04sU0FBWCxHQUF1QixNQUFLOEwsZUFBcEQ7WUFDTTdTLGNBQWNxVCxtQkFDaEJJLGtCQUFrQkosZ0JBREYsR0FFaEJJLGtCQUFrQkQsYUFGdEI7WUFHTUUsaUJBQWlCSixzQkFDbkJHLGtCQUFrQixNQUFLdEcsZUFBdkIsR0FBeUNtRyxtQkFEdEIsR0FFbkJHLGtCQUFrQixNQUFLdEcsZUFBdkIsR0FBeUNxRyxhQUY3Qzs7b0JBSVksRUFDVmpULFNBQVNqUSxHQUFULEdBQWVpUSxTQUFTNVEsTUFBeEIsR0FBaUNxUSxXQUFqQyxJQUNBTyxTQUFTalEsR0FBVCxHQUFlb2pCLGNBRkwsQ0FBWjtPQVZGLE1BY087O29CQUVPLElBQVo7OztVQUdJQyxnQkFDSnZnQjs7O3lCQUNlb04sR0FEZjtxQkFFYSxDQUFDbmEsVUFBT3V0QixhQUFSLEVBQXVCdnRCLFVBQU93dEIsc0JBQTlCLEVBQXNEeHNCLElBQXRELENBQ1QsR0FEUyxDQUZiO2dDQUFBO2lCQU1TO2lCQUNBLENBREE7a0JBRUMsQ0FGRDt1Q0FHb0JtSixJQUF6Qix1QkFBK0NGLEdBQS9DLFFBSEs7NkNBSTBCRSxJQUEvQix1QkFBcURGLEdBQXJELFFBSks7bUJBS0UwZ0IsMkJBQTJCN2UsS0FBM0IsQ0FMRjtvQkFNRzZlLDJCQUEyQnJoQixNQUEzQjs7OzRCQUdULFNBQUQsSUFBVyxNQUFNc2pCLFFBQWpCLEVBQTJCLFNBQVN6UyxHQUFwQyxFQUF5QyxhQUFhLEtBQXREO09BaEJKOzthQW9CTzRTLGFBQWNHLGFBQWFJLGFBQWQsSUFBZ0MsSUFBN0MsR0FBb0RBLGFBQTNEO0tBM1IyQjs7VUFHdEJ4RyxlQUFMLEdBQXVCLENBQXZCO1VBQ0swRixlQUFMLEdBQXVCLENBQXZCOztVQUVLdFosS0FBTCxHQUFhOzhCQUNhclMsTUFBTW9aLEtBQU4sQ0FBWXdULElBQVosQ0FDdEI7ZUFBUSxDQUFDLENBQUMzVCxJQUFGLElBQVUsQ0FBQ2paLE1BQU1rcUIsZ0JBQU4sQ0FBdUJ4RCxHQUF2QixDQUEyQnpOLElBQTNCLENBQW5CO09BRHNCLENBRGI7Y0FJSCxDQUpHO3FCQUtJLEVBTEo7c0JBTUssRUFOTDs7YUFRSmpaLE1BQU1vWixLQVJGOzBCQVNTLEVBVFQ7dUJBVU0sRUFWTjtpQkFXQSxDQVhBO2FBWUp4SjtLQVpUOzs7Ozs7Ozs7Ozs7Ozs7d0NBbUJrQjs7O2FBQ1gwUSxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLMEIsWUFBdkM7O1dBRUtvSixnQkFBTDs7VUFFTXZMLFNBTFksR0FLRSxLQUFLeE4sS0FMUCxDQUtad04sU0FMWTs7VUFNZCxLQUFLdUgsZUFBTCxJQUF3QixJQUE1QixFQUFrQztZQUMxQkEsbUJBQWtCLEtBQUtBLGVBQUwsQ0FBcUJFLHFCQUFyQixFQUF4QjtZQUNJRixnQkFBSixFQUFxQjtzQkFDUGtCLGFBQWFsQixnQkFBYixDQUFaOzs7O1dBSUM3VSxRQUFMLENBQWM7ZUFBYzs4QkFBQTtpQkFFbkIsT0FBS3dZLFdBQUwsR0FBbUIsT0FBS0EsV0FBTCxDQUFpQkMsV0FBcEMsR0FBa0Q2QixVQUFVNWhCO1NBRnZEO09BQWQ7OztXQU1LMmdCLDJCQUFMLENBQ0UsS0FBS3ZaLEtBQUwsQ0FBV3lhLHNCQUFYLEdBQW9DLFdBQXBDLEdBQWtELE1BRHBEOzs7O3VDQUtpQnhjLFdBQXFCdWMsV0FBcUI7OzttQkFDdkIsS0FBSzdzQixLQURrQjtVQUNuRG9aLEtBRG1ELFVBQ25EQSxLQURtRDtVQUM1QzhRLGdCQUQ0QyxVQUM1Q0EsZ0JBRDRDOzs7V0FHdERpQixxQkFBTDs7VUFFSTBCLFVBQVU1aEIsS0FBVixJQUFtQixJQUFuQixJQUEyQixLQUFLb0gsS0FBTCxDQUFXcEgsS0FBWCxLQUFxQjRoQixVQUFVNWhCLEtBQTlELEVBQXFFO3lCQUNsRDhoQixLQUFqQjs7O1VBR0lELHlCQUF5QjFULE1BQU13VCxJQUFOLENBQzdCO2VBQVEsQ0FBQyxDQUFDM1QsSUFBRixJQUFVLENBQUNpUixpQkFBaUJ4RCxHQUFqQixDQUFxQnpOLElBQXJCLENBQW5CO09BRDZCLENBQS9COztVQUlJNlQsMEJBQTBCLENBQUNELFVBQVVDLHNCQUF6QyxFQUFpRTthQUMxRGxCLDJCQUFMLENBQWlDLFdBQWpDO09BREYsTUFFTyxJQUFJLENBQUNrQixzQkFBRCxJQUEyQkQsVUFBVUMsc0JBQXpDLEVBQWlFO2FBQ2pFbEIsMkJBQUwsQ0FBaUMsTUFBakM7O1dBRUdWLGdDQUFMOztVQUdFNEIsMEJBQ0FBLDJCQUEyQixLQUFLemEsS0FBTCxDQUFXeWEsc0JBRHRDLElBRUFELFVBQVU1aEIsS0FBVixJQUFtQixJQUhyQixFQUlFO2FBQ0sraEIsb0JBQUwsR0FBNEJDLHNCQUFzQixZQUFNO2NBQ2hEQyxrQkFBa0IzQyxtQkFBbUIsT0FBS3ZxQixLQUF4QixFQUErQixPQUFLcVMsS0FBcEMsQ0FBeEI7aUJBQ0tFLFFBQUw7O2FBRUsyYSxlQUZMO1NBRjBCLENBQTVCO09BTEYsTUFZTyxJQUFJSiwwQkFBMEJELFVBQVV6VCxLQUFWLEtBQW9CQSxLQUFsRCxFQUF5RDthQUN6RDRULG9CQUFMLEdBQTRCQyxzQkFBc0IsWUFBTTtjQUNoREMsa0JBQWtCM0MsbUJBQW1CLE9BQUt2cUIsS0FBeEIsRUFBK0IsT0FBS3FTLEtBQXBDLENBQXhCO2lCQUNLRSxRQUFMLGNBQW1CMmEsZUFBbkI7U0FGMEIsQ0FBNUI7Ozs7Ozs7Ozs7MkNBVW1CO1VBQ2pCLEtBQUtGLG9CQUFULEVBQStCOzZCQUNSLEtBQUtBLG9CQUExQjs7OztXQUlHN0IscUJBQUwsQ0FBMkJqRSxZQUEzQjtXQUNLbEYsWUFBTCxDQUFrQmtGLFlBQWxCO1dBQ0srRCxvQkFBTCxDQUEwQi9ELFlBQTFCOzthQUVPeEcsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMsS0FBS3NCLFlBQTFDOzs7O3VDQXdHaUI7VUFDYixLQUFLb0YsZUFBTCxJQUF3QixJQUE1QixFQUFrQztZQUN4QkEsaUJBRHdCLEdBQ0osSUFESSxDQUN4QkEsZUFEd0I7O1lBRTFCK0YscUJBQXFCL0Ysa0JBQWdCRSxxQkFBaEIsRUFBM0I7WUFDSTZGLGtCQUFKLEVBQXdCO2VBQ2pCbEgsZUFBTCxHQUF1QmdDLGlCQUFpQmtGLGtCQUFqQixDQUF2QjtjQUNNN1UsS0FBSyxLQUFLeVMsV0FBaEI7Y0FDSXpTLGNBQWM4VSxXQUFsQixFQUErQjtnQkFDdkJDLG9CQUFvQmpGLHFCQUFxQitFLGtCQUFyQixDQUExQjtpQkFDS3hCLGVBQUwsR0FDRXJULEdBQUc2SixxQkFBSCxHQUEyQi9ZLEdBQTNCLEdBQWlDaWtCLGlCQURuQzs7Ozs7Ozs7Ozs7Ozs7NkJBWUM7V0FDRnJ0QixLQUFMLENBQVdrcUIsZ0JBQVgsQ0FBNEI2QyxLQUE1QjtXQUNLM0IsZ0JBQUw7V0FDS0YsZ0NBQUw7V0FDS29DLFdBQUw7Ozs7NkJBdURPOzs7b0JBT0gsS0FBS3R0QixLQVBGO1VBRUw2b0IsV0FGSyxXQUVMQSxXQUZLO1VBR0NtRCxTQUhELFdBR0xDLElBSEs7VUFJTGpDLFFBSkssV0FJTEEsUUFKSztVQUtMRSxnQkFMSyxXQUtMQSxnQkFMSztVQU1MOVEsS0FOSyxXQU1MQSxLQU5LO21CQWdCSCxLQUFLL0csS0FoQkY7VUFTTHlhLHNCQVRLLFVBU0xBLHNCQVRLO1VBVUxya0IsTUFWSyxVQVVMQSxNQVZLO1VBV0xtaUIsY0FYSyxVQVdMQSxjQVhLO1VBWUxKLGFBWkssVUFZTEEsYUFaSztVQWFMSyxrQkFiSyxVQWFMQSxrQkFiSztVQWNMSCxlQWRLLFVBY0xBLGVBZEs7VUFlTHpmLEtBZkssVUFlTEEsS0FmSzs7O1VBa0JIc2lCLGlCQUFKO1VBQ0l0aUIsU0FBUyxJQUFULElBQWlCNmhCLHNCQUFyQixFQUE2Qzs7O21CQUl6QzVnQjs7O3VCQUNhL00sVUFBTzJyQixPQURwQjttQkFFUyxFQUFFcmlCLFFBQVEsQ0FBVixFQUFhd0MsT0FBTyxNQUFwQixFQUZUO2lCQUdPLEtBQUtvZ0I7O2dCQUVIWixNQUFOLENBQWE7bUJBQVF4UixJQUFSO1dBQWIsRUFBMkJuWixHQUEzQixDQUErQixVQUFDbVosSUFBRCxFQUFPb0IsQ0FBUDttQkFDOUJuTzs7OzJCQUNZLFFBRFo7c0NBQUE7cUJBR09tTyxDQUhQO3VCQUlTO3VCQUNBLENBREE7d0JBRUMsQ0FGRDs2QkFHTSxpQ0FITjttQ0FJWSxpQ0FKWjt5QkFLRTJQLFdBQ0hwYSxTQURHLEdBRUhrYSwyQkFBMkJqQixXQUEzQixDQVBDO2lCQUpUO3FCQWFPLGlCQUFNO3NCQUNMdlEsTUFBTSxDQUFDMFIsUUFBWCxFQUFxQjs7cUNBRUZyRCxHQUFqQixDQUFxQjFOLElBQXJCLEVBQTJCWCxHQUFHMEgsWUFBOUI7Ozs7a0NBSUgsU0FBRCxJQUFXLE1BQU0vRyxJQUFqQixFQUF1QixTQUFTb0IsQ0FBaEMsRUFBbUMsYUFBYSxLQUFoRDthQXJCNEI7V0FBL0I7U0FOTDtPQUhGLE1BbUNPLElBQUlwUCxTQUFTLElBQWIsRUFBbUI7OzttQkFHYmlCLDZCQUFLLE9BQU8sRUFBRWpCLE9BQU8sTUFBVCxFQUFaLEVBQStCLEtBQUssS0FBS29nQixpQkFBekMsR0FBWDtPQUhLLE1BSUE7bUJBRUhuZjs7WUFBSyxPQUFPLEVBQUVqQixPQUFPLE1BQVQsRUFBWixFQUErQixLQUFLLEtBQUtvZ0IsaUJBQXpDOzs7Y0FDTyxXQUFXbHNCLFVBQU8yckIsT0FBdkIsRUFBZ0MsT0FBTyxFQUFFcmlCLGNBQUYsRUFBVXdDLFlBQVYsRUFBdkM7MEJBQ2lCbkwsR0FBZCxDQUFrQixVQUFDbVosSUFBRCxFQUFPb0IsQ0FBUDs7O3VCQUVaeVIsc0JBQUwsQ0FBNEI3UyxJQUE1QixFQUFrQ29CLENBQWxDLEVBQXFDcVEsZ0JBQWdCclEsQ0FBaEIsQ0FBckM7O2FBRkQ7V0FGTDs7O2NBT08sV0FBV2xiLFVBQU8yckIsT0FBdkIsRUFBZ0MsT0FBTyxFQUFFN2YsWUFBRixFQUF2QzsyQkFDa0JuTCxHQUFmLENBQW1CLFVBQUMwdEIsSUFBRCxFQUFPblQsQ0FBUCxFQUFhOzs7O2tCQUl6Qm9ULG1CQUFtQmpELGNBQWNscUIsTUFBZCxHQUF1QitaLENBQWhEO2tCQUNNaEIsV0FBV3dSLG1CQUFtQnhRLENBQW5CLENBQWpCO3FCQUVFbk87OztzQ0FDb0J1aEIsZ0JBRHBCO3lCQUVTO2dDQUNPLFFBRFA7OEJBRUssVUFGTDt5QkFHQTNELDJCQUEyQnpRLFNBQVNqUSxHQUFwQyxDQUhBOzBCQUlDMGdCLDJCQUEyQnpRLFNBQVMvUCxJQUFwQyxDQUpEOzJCQUtFd2dCLDJCQUEyQnpRLFNBQVNwTyxLQUFwQyxDQUxGOzRCQU1HNmUsMkJBQTJCelEsU0FBUzVRLE1BQXBDO21CQVJaO3VCQVVPLGlCQUFNO3dCQUNMNlAsRUFBSixFQUFRO3VDQUNXcU8sR0FBakIsQ0FBcUI2RyxJQUFyQixFQUEyQmxWLEdBQUcwSCxZQUE5Qjs7OztvQ0FJSCxTQUFEO3dCQUNRd04sSUFEUjsyQkFFV0MsZ0JBRlg7OztlQWpCSjthQU5EOztTQVRQOzs7YUE2Q0ssS0FBS3p0QixLQUFMLENBQVdvbkIsZUFBWCxHQUNMbGI7dUJBQUE7O2VBQ08sS0FBS3FmLHFCQURaO29CQUVZLEtBQUtOLG9CQUZqQjsyQkFHbUIsS0FBS2pyQixLQUFMLENBQVdvbkI7OztPQUp6QixHQVNMbUcsUUFURjs7Ozs2Q0E3UjhCdnRCLE9BQWlCcVMsT0FBaUI7VUFDeEQrRyxLQUR3RCxHQUM1QnBaLEtBRDRCLENBQ3hEb1osS0FEd0Q7VUFDakQ4USxnQkFEaUQsR0FDNUJscUIsS0FENEIsQ0FDakRrcUIsZ0JBRGlEOzs7O1VBSTFENEMseUJBQXlCMVQsTUFBTXdULElBQU4sQ0FDN0I7ZUFBUTNULFFBQVEsQ0FBQ2lSLGlCQUFpQnhELEdBQWpCLENBQXFCek4sSUFBckIsQ0FBakI7T0FENkIsQ0FBL0I7OztXQUtLLElBQUlvQixJQUFJLENBQWIsRUFBZ0JBLElBQUlqQixNQUFNOVksTUFBMUIsRUFBa0MrWixLQUFLLENBQXZDLEVBQTBDOzs7WUFHcENoSSxNQUFNK0csS0FBTixDQUFZaUIsQ0FBWixNQUFtQnpLLFNBQXZCLEVBQWtDO2lCQUN6QjswREFBQTs7V0FBUDs7Ozs7O2NBU015SyxDQUFOLE1BQWFoSSxNQUFNK0csS0FBTixDQUFZaUIsQ0FBWixDQUFiOztjQUVNL1osTUFBTixHQUFlK1IsTUFBTStHLEtBQU4sQ0FBWTlZLE1BSjdCLEVBS0U7aUJBQ087MERBQUE7O1dBQVA7Ozs7O1VBUUE4WSxNQUFNOVksTUFBTixLQUFpQixDQUFqQixJQUFzQitSLE1BQU0rRyxLQUFOLENBQVk5WSxNQUFaLEdBQXFCLENBQS9DLEVBQWtEO2VBQ3pDO3dEQUFBOztTQUFQOztVQUtFd3NCLDJCQUEyQnphLE1BQU15YSxzQkFBckMsRUFBNkQ7O2VBRXBEO3dEQUFBOztTQUFQOzs7O2FBT0ssSUFBUDs7OztFQXJRb0MxYjs7QUFBbkIwWixRQStCWnRlLFlBQVk7Ozs7O2VBS0pKLFVBQVVVLE1BTE47Ozs7OztRQVdYVixVQUFVaUYsSUFBVixDQUFldkIsVUFYSjs7Ozs7O1lBaUJQMUQsVUFBVVMsSUFqQkg7Ozs7O2VBc0JKVCxVQUFVVSxNQXRCTjs7Ozs7U0EyQlZWLFVBQVVzTixPQUFWLENBQWtCdE4sVUFBVVcsS0FBVixDQUFnQixFQUFoQixDQUFsQixFQUF1QytDLFVBM0I3Qjs7Ozs7b0JBZ0NDMUQsVUFBVXNoQixVQUFWLENBQXFCbkgsZ0JBQXJCLENBaENEOzs7OztVQXFDVG5hLFVBQVVRLFNBQVYsQ0FBb0IsQ0FDMUJSLFVBQVVzaEIsVUFBVixDQUFxQkMsYUFBckIsQ0FEMEIsRUFFMUJ2aEIsVUFBVXNoQixVQUFWLENBQXFCdEQsZ0JBQXJCLENBRjBCLEVBRzFCaGUsVUFBVXdoQixNQUhnQixDQUFwQixDQXJDUzs7Ozs7OzthQWdETnhoQixVQUFVaUYsSUFoREo7Ozs7O1dBcURSakYsVUFBVVUsTUFyREY7Ozs7OzttQkEyREFWLFVBQVVpRixJQTNEVjs7Ozs7Y0FnRUxqRixVQUFVUzs7QUEvRkxpZSxRQWtHWnhaLGVBQWU7ZUFDUCxHQURPO29CQUVGLElBQUlpVixnQkFBSixFQUZFO1dBR1gsQ0FIVztVQUlaZ0MsbUJBSlk7YUFLVCxxQkFBTSxFQUxHO2NBTVI7OztBQzNQaEI7Ozs7SUFJcUJzRjs7Ozs2Q0FJYTthQUN2QixJQUFJdEgsZ0JBQUosRUFBUDs7OzsyQkFLVXZtQixLQUFaLEVBQTZCOzs7aUlBQ3JCQSxLQURxQjs7VUFpQjdCd3JCLDRCQWpCNkIsR0FpQkUsVUFBQ0UsT0FBRCxFQUFvQkQsUUFBcEIsRUFBMkM7d0JBQ25CLE1BQUtwWixLQURjO1VBQ2hFNFQsZUFEZ0UsZUFDaEVBLGVBRGdFO1VBQy9DcEcsU0FEK0MsZUFDL0NBLFNBRCtDO1VBQ3BDd0csWUFEb0MsZUFDcENBLFlBRG9DOztVQUd0RW9GLFNBQVNoakIsTUFBVCxLQUFvQndkLGVBQXBCLElBQ0F3RixTQUFTcmlCLEdBQVQsS0FBaUJ5VyxTQURqQixJQUVBNkwsUUFBUWpqQixNQUFSLEtBQW1CNGQsWUFIckIsRUFJRTtjQUNLOVQsUUFBTCxDQUFjOzJCQUNLa1osU0FBU2hqQixNQURkO3FCQUVEZ2pCLFNBQVNyaUIsR0FGUjt3QkFHRXNpQixRQUFRampCO1NBSHhCOztLQXhCeUI7O1VBK0M3QnFsQixNQS9DNkIsR0ErQ3BCLFVBQUN4QyxHQUFELEVBQThCO1VBQ2pDQSxHQUFKLEVBQVM7Y0FDRnlDLE9BQUwsR0FBZXpDLEdBQWY7O0tBakR5Qjs7VUFxRDdCbEYsU0FyRDZCLEdBcURqQixZQUFNO1VBQ1I0SCxTQURRLEdBQ00sTUFBS2h1QixLQURYLENBQ1JndUIsU0FEUTs7VUFFWkEsYUFBYSxPQUFPQSxTQUFQLEtBQXFCLFVBQXRDLEVBQWtEO2NBQzNDemIsUUFBTCxDQUNFO3NCQUNjO1NBRmhCLEVBSUU7aUJBQU15YixVQUFVLEVBQUVudUIsTUFBTSxNQUFLRyxLQUFMLENBQVdvWixLQUFYLENBQWlCOVksTUFBekIsRUFBVixDQUFOO1NBSkY7O0tBeER5Qjs7VUFpRTdCc3JCLDJCQWpFNkIsR0FpRUMsVUFBQ3ZaLEtBQUQsRUFBNkI7VUFDbkR5YSx5QkFBeUJ6YSxVQUFVLFdBQXpDO1VBQ0ksTUFBS0EsS0FBTCxDQUFXeWEsc0JBQVgsS0FBc0NBLHNCQUExQyxFQUFrRTtjQUMzRHZhLFFBQUwsQ0FBYyxFQUFFdWEsOENBQUYsRUFBZDs7O1VBR0UsT0FBTyxNQUFLOXNCLEtBQUwsQ0FBVzZyQixxQkFBbEIsS0FBNEMsVUFBaEQsRUFBNEQ7Y0FDckQ3ckIsS0FBTCxDQUFXNnJCLHFCQUFYLENBQWlDeFosS0FBakM7O0tBeEV5Qjs7VUE0RTdCNGIsTUE1RTZCLEdBNEVwQixZQUFNO1VBQ1QsTUFBS0YsT0FBVCxFQUFrQjtjQUNYQSxPQUFMLENBQWFFLE1BQWI7O0tBOUV5Qjs7VUFrRjdCak0sWUFsRjZCLEdBa0ZkLFlBQU07VUFDZixNQUFLK0wsT0FBVCxFQUFrQjtjQUNYQSxPQUFMLENBQWEvTCxZQUFiOztLQXBGeUI7O1VBR3RCM1AsS0FBTCxHQUFhO3VCQUNNLENBRE47OEJBRWEsS0FGYjtrQkFHQyxLQUhEOzthQUtKclMsTUFBTW9aLEtBTEY7aUJBTUEsQ0FOQTtvQkFPRztLQVBoQjs7Ozs7Ozs7Ozs7NkJBdUZPO2FBQ0EsS0FBS3BaLEtBQUwsQ0FBV29uQixlQUFYLEdBQ0xsYjtzQkFBQTs7NEJBQ0csVUFBRDsyQkFDbUIsS0FBS21HLEtBQUwsQ0FBVzRULGVBRDlCO3FCQUVhLEtBQUtHLFNBRmxCO3NCQUlJLEtBQUsvVCxLQUFMLENBQVc4VCxVQUFYLElBQXlCLEtBQUs5VCxLQUFMLENBQVd5YSxzQkFKeEM7d0JBTWdCLEtBQUt6YSxLQUFMLENBQVdnVSxZQU4zQjtxQkFPYSxLQUFLaFUsS0FBTCxDQUFXd047VUFSMUI7NEJBVUcsT0FBRCxlQUNNLEtBQUs3ZixLQURYO3dDQUVnQyxLQUFLd3JCLDRCQUZyQztpQ0FHeUIsS0FBS0ksMkJBSDlCO2VBSU8sS0FBS2tDOztPQWZULEdBbUJMNWhCLG9CQUFDLE9BQUQsZUFBYSxLQUFLbE0sS0FBbEIsSUFBeUIsS0FBSyxLQUFLOHRCLE1BQW5DLElBbkJGOzs7OzZDQTNEOEI5dEIsT0FBaUJxUyxPQUFpQjtVQUN4RCtHLEtBRHdELEdBQzlDcFosS0FEOEMsQ0FDeERvWixLQUR3RDs7OztVQUk1RHBaLE1BQU1vWixLQUFOLEtBQWdCL0csTUFBTStHLEtBQTFCLEVBQWlDO2VBQ3hCO3NCQUFBO3NCQUVPO1NBRmQ7Ozs7YUFPSyxJQUFQOzs7O0VBdEQ0Q2hJOztBQUEzQnljLGdCQVFadmMsZUFBZXdaLFFBQVF4Wjs7SUNyQlg0Yzs7OzRCQUNQbHVCLEtBQVosRUFBMEI7OzttSUFDbEJBLEtBRGtCOztVQUVuQm11QixZQUFMLEdBQW9CLElBQXBCOzs7Ozs7d0NBR2tCO1VBQ2QsT0FBTzNkLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7YUFDNUIyZCxZQUFMLEdBQW9CM2QsT0FBT2lQLFFBQVAsQ0FBZ0JtRixJQUFoQixDQUFxQnJrQixLQUFyQixDQUEyQnlTLFFBQS9DO2VBQ095TSxRQUFQLENBQWdCbUYsSUFBaEIsQ0FBcUJya0IsS0FBckIsQ0FBMkJ5UyxRQUEzQixHQUFzQyxRQUF0Qzs7Ozs7MkNBSW1CO1VBQ2pCLE9BQU94QyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO2VBQzFCaVAsUUFBUCxDQUFnQm1GLElBQWhCLENBQXFCcmtCLEtBQXJCLENBQTJCeVMsUUFBM0IsR0FBc0MsS0FBS21iLFlBQTNDOzs7Ozs2QkFNSzthQUNBLEtBQUtudUIsS0FBTCxDQUFXNkwsUUFBbEI7Ozs7RUF0QjBDdUY7O0FDQTlDLFNBQVNnZCxpQkFBVCxDQUEyQjlWLEVBQTNCLEVBQStDO01BQ3ZDK1YsV0FBVyxDQUNmLFNBRGUsRUFFZixZQUZlLEVBR2YsdUJBSGUsRUFJZix3QkFKZSxFQUtmLDBCQUxlLEVBTWYsd0JBTmUsRUFPZixRQVBlLEVBUWYsUUFSZSxFQVNmLE9BVGUsRUFVZixpQkFWZSxFQVdmLGdCQVhlLEVBWWYsbUJBWmUsRUFhZixpQkFiZSxFQWNmLGlCQWRlLEVBZWYsU0FmZSxFQWdCZmx1QixJQWhCZSxDQWdCVixHQWhCVSxDQUFqQjtTQWlCT21ZLEdBQUdnVyxnQkFBSCxDQUFvQkQsUUFBcEIsQ0FBUDs7O0FBR0YsSUFBTUUsZUFBZSxTQUFmQSxZQUFlLENBQUNqVyxFQUFELEVBQXFCO01BQ3BDLE9BQU9BLEdBQUcrSCxLQUFWLEtBQW9CLFVBQXhCLEVBQW9DO09BQy9CQSxLQUFIOztDQUZKOztJQU1xQm1POzs7Ozs7Ozs7Ozs7OzsyTUFjbkJDLFdBQVcsVUFBQ25XLEVBQUQsRUFBeUI7VUFDOUJBLEVBQUosRUFBUTtjQUNEQSxFQUFMLEdBQVVBLEVBQVY7O2FBSUpkLGNBQWMsVUFBQ2pCLEtBQUQsRUFBdUI7VUFFakMsQ0FBQyxNQUFLK0IsRUFBTixJQUNDL0IsTUFBTWEsTUFBTixZQUF3Qm1LLElBQXhCLElBQWdDLE1BQUtqSixFQUFMLENBQVFsTixRQUFSLENBQWlCbUwsTUFBTWEsTUFBdkIsQ0FGbkMsRUFHRTs7OztZQUlJc1gsZUFBTjtZQUNNQyxjQUFOO1lBQ0tDLGVBQUw7Ozs7Ozt3Q0E3QmtCO1dBQ2JDLG1CQUFMLEdBQTJCcFAsU0FBU3FQLGFBQXBDO1dBQ0tGLGVBQUw7ZUFDU3RPLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DLEtBQUs5SSxXQUF4QyxFQUFxRCxJQUFyRDs7OzsyQ0FHcUI7ZUFDWmtKLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDLEtBQUtsSixXQUEzQyxFQUF3RCxJQUF4RDtVQUNJLEtBQUtxWCxtQkFBVCxFQUE4QjtxQkFDZixLQUFLQSxtQkFBbEI7Ozs7O3NDQXVCYztVQUNSdlcsRUFEUSxHQUNELElBREMsQ0FDUkEsRUFEUTs7VUFFWkEsRUFBSixFQUFRO3FCQUNPOFYsa0JBQWtCOVYsRUFBbEIsRUFBc0IsQ0FBdEIsQ0FBYjs7Ozs7NkJBUUs7YUFDQXBNOztVQUFLLEtBQUssS0FBS3VpQixRQUFmO2FBQStCenVCLEtBQUwsQ0FBVzZMO09BQTVDOzs7O0VBN0MyQ3VGOzs7O0FDWC9DLElBQU1vUSxtQkFBaUI7TUFDakIsR0FEaUI7TUFFakIsR0FGaUI7TUFHakI7Q0FITjs7QUFNQSxJQUFNQyxvQkFBa0IsRUFBeEI7O0FBRUEsSUFBTXNOLFdBQVcsU0FBWEEsUUFBVztNQUFHbGpCLFFBQUgsUUFBR0EsUUFBSDtTQUNmSztrQkFBQTs7aUNBQ08sV0FBVy9NLFVBQU80dkIsUUFBdkIsR0FERjs7R0FEZTtDQUFqQjs7SUFPcUJDOzs7Ozs7Ozs7Ozs7OztxTEFvQm5CQyxxQkFBcUIsWUFBTTtZQUNwQmp2QixLQUFMLENBQVc2aEIsU0FBWDthQUdGcU4sbUJBQW1CLFlBQU07WUFDbEJsdkIsS0FBTCxDQUFXNmhCLFNBQVg7YUFHRjhELGNBQWMsVUFBQ3BQLEtBQUQsRUFBZ0M7VUFDeENBLE1BQU1xTCxPQUFOLEtBQWtCSCxpQkFBdEIsRUFBdUM7Y0FDaEN6aEIsS0FBTCxDQUFXNmhCLFNBQVg7Ozs7Ozs7d0NBbEJnQjthQUNYdkIsZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsS0FBS3FGLFdBQXRDOzs7OzJDQUdxQjthQUNkakYsbUJBQVAsQ0FBMkIsT0FBM0IsRUFBb0MsS0FBS2lGLFdBQXpDOzs7OzZCQWlCTzttQkFTSCxLQUFLM2xCLEtBVEY7VUFFTG12Qix1QkFGSyxVQUVMQSx1QkFGSztVQUdMQyx1QkFISyxVQUdMQSx1QkFISztVQUlMdmpCLFFBSkssVUFJTEEsUUFKSztVQUtMd2pCLE1BTEssVUFLTEEsTUFMSztVQU1MQyxPQU5LLFVBTUxBLE9BTks7K0JBT0xDLElBUEs7VUFPTEEsSUFQSywrQkFPRSxRQVBGOytCQVFMdHZCLElBUks7VUFRTEEsSUFSSywrQkFRRSxJQVJGOztVQVVEZ0wsUUFBUXVXLGlCQUFldmhCLElBQWYsQ0FBZDs7YUFHRWlNO3dCQUFBOzs7MkJBQ0U7Ozs7OzRCQUVnQmtqQix1QkFEZDt5QkFFYWp3QixVQUFPNmhCLFNBRnBCO29CQUdRdU87OztzQkFFTjs7O29DQUNFO2tCQUFzQixTQUFTLEtBQUtOLGtCQUFwQzs7O29CQUNPLFdBQVc5dkIsVUFBT3F3QixPQUF2QixFQUFnQyxVQUFVLENBQUMsQ0FBM0MsRUFBOEMsT0FBTyxFQUFFdmtCLFlBQUYsRUFBckQ7O3VCQUNFOzs0QkFDTyxNQURQO2dDQUVXLFVBRlg7K0JBR1UsTUFIVjtpQ0FJWTs7O3lCQUVWO3dCQUFLLFNBQUw7K0JBQ1ksUUFBVCxHQUNDaUI7MkJBQUE7O3FEQUM2QjtxQ0FDaEIsRUFBRXVqQixhQUFhLEVBQWYsRUFBbUJDLGNBQWMsRUFBakM7MkJBRmI7bUNBSVUsTUFKVjswQ0FLaUIsUUFMakI7b0NBTVk7OztpQ0FFVjs0QkFBUyxNQUFLLElBQWQsRUFBbUIsb0JBQW9CLENBQXZDOzs7dUJBVEgsR0FjQ3hqQjsyQkFBQTswQkFBSyxTQUFRLE1BQWIsRUFBb0IsU0FBUyxDQUE3Qjs7aUNBQ0U7NEJBQVMsTUFBSyxJQUFkLEVBQW1CLG9CQUFvQixDQUF2Qzs7O3VCQWhCTjsrQkFxQlksUUFBVCxJQUNDQTsyQkFBQTswQkFBSyxTQUFTLENBQWQsRUFBaUIsVUFBUyxVQUExQixFQUFxQyxTQUFyQyxFQUF5QyxXQUF6Qzs0Q0FDRyxVQUFEOzhDQUNzQmlqQix1QkFEdEI7Z0NBRU8sUUFGUDttQ0FHVyxLQUFLRDs7dUJBMUJ0QjsrQkE4QlksUUFBVCxJQUFxQmhqQixvQkFBQyxPQUFEO3FCQXBDMUI7O3lCQXNDRTt3QkFBSyxNQUFLLE1BQVYsRUFBaUIsVUFBUyxNQUExQixFQUFpQyxVQUFTLFVBQTFDOztxQkF0Q0Y7O3lCQXlDRTt3QkFBSyxTQUFMO2dDQUVJQTsyQkFBQTs7aUNBQ1ksUUFBVCxJQUFxQkEsb0JBQUMsT0FBRCxPQUR4Qjs7NkJBRUU7NEJBQUssU0FBUyxDQUFkOzs7Ozs7Ozs7OztPQXhEdEI7Ozs7RUE5QytCa0Y7O0FBQWQ0ZCxNQUNaeGlCLFlBQVk7WUFDUEosVUFBVUssSUFESDsyQkFFUUwsVUFBVVksTUFBVixDQUFpQjhDLFVBRnpCO1VBR1QxRCxVQUFVSyxJQUhEO1dBSVJMLFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUpUOzJCQUtRMUQsVUFBVVksTUFBVixDQUFpQjhDLFVBTHpCO2FBTU4xRCxVQUFVaUYsSUFOSjtRQU9YakYsVUFBVUMsS0FBVixDQUFnQixDQUFDLGFBQUQsRUFBZ0IsUUFBaEIsQ0FBaEIsQ0FQVztRQVFYRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLENBQWhCOzs7OztBQ3BDSyxTQUFTc2pCLE1BQVQsQ0FBZ0IzdkIsS0FBaEIsRUFBOEI7TUFDbkM0dkIsTUFEbUMsR0FDWjV2QixLQURZLENBQ25DNHZCLE1BRG1DO29CQUNaNXZCLEtBRFksQ0FDM0JDLElBRDJCO01BQzNCQSxJQUQyQiwrQkFDcEIsR0FEb0I7OztTQUl6Q2lNO09BQUE7O2lDQUM2QjtpQkFDaEI7bUNBQ2tCMGpCLFNBQVMsQ0FBVCxHQUFhLFVBRC9CO21CQUVFLE1BRkY7cUJBR0k7O09BTGpCO2VBUVdBLFNBQVMsTUFBVCxHQUFrQixPQVI3QjtjQVNVM3ZCLElBVFY7Z0JBVVcsVUFWWDthQVdTQTs7OztRQUVGLFdBQVdkLFVBQU8wd0IsV0FBdkI7bUNBQ08sV0FBVzF3QixVQUFPMndCLFdBQXZCOztHQWZOOzs7QUFxQkZILE9BQU9uakIsU0FBUCxHQUFtQjtVQUNUSixVQUFVUyxJQUREO1FBRVhULFVBQVVVO0NBRmxCOzs7O0lDWnFCaWpCOzs7Ozs7Ozs7Ozs7OzsrTEFpQm5CMWQsUUFBUTtlQUNHO2FBR1g2RSxlQUFlLFVBQUNYLEtBQUQsRUFBa0M7VUFDdkNZLE9BRHVDLEdBQzNCWixNQUFNYSxNQURxQixDQUN2Q0QsT0FEdUM7O1lBRTFDblgsS0FBTCxDQUFXcVgsUUFBWCxDQUFvQixFQUFFRixnQkFBRixFQUFXWixZQUFYLEVBQXBCO2FBR0ZlLGFBQWE7YUFBTSxNQUFLL0UsUUFBTCxDQUFjLEVBQUVnRixTQUFTLEtBQVgsRUFBZCxDQUFOO2FBRWJDLGNBQWMsWUFBTTtZQUNiakYsUUFBTCxDQUFjLEVBQUVnRixTQUFTLElBQVgsRUFBZDs7Ozs7OzZCQUdPOzs7bUJBQzhDLEtBQUt2WCxLQURuRDtVQUNDbVgsT0FERCxVQUNDQSxPQUREO1VBQ1V6QixRQURWLFVBQ1VBLFFBRFY7VUFDb0JvQyxFQURwQixVQUNvQkEsRUFEcEI7VUFDd0J4VyxJQUR4QixVQUN3QkEsSUFEeEI7VUFDOEJyQixJQUQ5QixVQUM4QkEsSUFEOUI7VUFDb0M4RCxLQURwQyxVQUNvQ0EsS0FEcEM7O2FBR0xtSTs7O3FCQUNhc0QsV0FBV3JRLFVBQU80d0IsV0FBbEIsaURBQ1I1d0IsVUFBTzZ3QixvQkFEQyxFQUNzQixLQUFLM2QsS0FBTCxDQUFXa0YsT0FEakMsK0JBRVJwWSxVQUFPOHdCLGFBRkMsRUFFZWh3QixTQUFTLElBRnhCLCtCQUdSZCxVQUFPK3dCLGFBSEMsRUFHZWp3QixTQUFTLElBSHhCLCtCQUlSZCxVQUFPZ3hCLGtCQUpDLEVBSW9CLENBQUN6YSxRQUFELElBQWF5QixPQUpqQywrQkFLUmhZLFVBQU9peEIsc0JBTEMsRUFLd0IxYSxZQUFZLENBQUN5QixPQUxyQzs7O21CQVNBQSxPQURYO3FCQUVhM0gsV0FBV3JRLFVBQU9reEIsS0FBbEIsbURBQ1JseEIsVUFBT214QixZQURDLEVBQ2MsQ0FBQzVhLFFBRGYsZ0NBRVJ2VyxVQUFPb3hCLE9BRkMsRUFFU3R3QixTQUFTLElBRmxCLGdDQUdSZCxVQUFPcXhCLE9BSEMsRUFHU3Z3QixTQUFTLElBSGxCLGlCQUZiO29CQU9ZeVYsUUFQWjtjQVFNb0MsRUFSTjtnQkFTUXhXLElBVFI7a0JBVVUsS0FBS2dXLFVBVmY7b0JBV1ksS0FBS0osWUFYakI7bUJBWVcsS0FBS00sV0FaaEI7Z0JBYU8sT0FiUDtpQkFjU3pUO1VBdkJYO21CQTBCSW1JO3FCQUNhc0QsV0FBV3JRLFVBQU9zeEIsS0FBbEIsbURBQ1J0eEIsVUFBT3V4QixPQURDLEVBQ1N6d0IsU0FBUyxJQURsQixnQ0FFUmQsVUFBT3d4QixPQUZDLEVBRVMxd0IsU0FBUyxJQUZsQixnQ0FHUmQsVUFBT3l4QixZQUhDLEVBR2MsQ0FBQ2xiLFFBSGYsZ0NBSVJ2VyxVQUFPMHhCLGFBSkMsRUFJZW5iLFFBSmY7O09BNUJuQjs7OztFQWxDcUN0RTs7QUFBcEIyZSxZQUNadmpCLFlBQVk7V0FDUkosVUFBVVMsSUFERjtZQUVQVCxVQUFVUyxJQUZIO01BR2JULFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUhKO1FBSVgxRCxVQUFVWSxNQUpDO1lBS1BaLFVBQVVpRixJQUFWLENBQWV2QixVQUxSO1NBTVYxRCxVQUFVWSxNQUFWLENBQWlCOEMsVUFOUDtRQU9YMUQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLENBQWhCOztBQVJXMGpCLFlBV1p6ZSxlQUFlO1dBQ1gsS0FEVztZQUVWLEtBRlU7UUFHZDs7O0lDWFd3Zjs7Ozs7Ozs7Ozs7Ozs7K0xBSW5CQyxpQkFBaUJuSixTQUFTLFlBQU07WUFDekJyVixRQUFMLENBQWMsTUFBS3llLGNBQUwsRUFBZDtLQURlLFNBTWpCM2UsUUFBUTt1QkFDVyxDQURYO29CQUVRLENBRlI7aUJBR0s7YUE4QmJnVyxrQkFBa0IsWUFBTTtVQUNkckgsU0FEYyxHQUNBLE1BQUtoaEIsS0FETCxDQUNkZ2hCLFNBRGM7O1VBRWxCLENBQUNBLFNBQUwsRUFBZ0I7ZUFDUCxDQUFQOzthQUVLcUgsZ0JBQWdCckgsU0FBaEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7O3dDQTdCa0I7OztVQUNWQSxTQURVLEdBQ0ksS0FBS2hoQixLQURULENBQ1ZnaEIsU0FEVTs7VUFFZCxDQUFDQSxTQUFMLEVBQWdCOzs7aUJBR0wsWUFBTTtlQUNWek8sUUFBTDsyQkFDbUIwVixpQkFBaUJqSCxTQUFqQjtXQUNkLE9BQUtnUSxjQUFMLEVBRkw7T0FERjs7Ozs7Ozs7O3lDQVdtQjs7V0FFZEQsY0FBTDs7Ozs7Ozs7O3FDQWNlO21CQUNxQixLQUFLL3dCLEtBRDFCO1VBQ1BnaEIsU0FETyxVQUNQQSxTQURPO1VBQ0lpUSxZQURKLFVBQ0lBLFlBREo7O1VBRVgsQ0FBQ2pRLFNBQUwsRUFBZ0I7ZUFDUCxJQUFQOztVQUVJcUYsZUFBZTRLLGdCQUFnQixLQUFLNUksZUFBMUM7O2FBRU87c0JBQ1NoQyxjQURUO21CQUVNaUMsYUFBYXRILFNBQWI7T0FGYjs7Ozs2QkFRTzttQkFDOEMsS0FBSzNPLEtBRG5EO1VBQ0M0VCxlQURELFVBQ0NBLGVBREQ7VUFDa0JJLFlBRGxCLFVBQ2tCQSxZQURsQjtVQUNnQ3hHLFNBRGhDLFVBQ2dDQSxTQURoQztvQkFFK0MsS0FBSzdmLEtBRnBEO1VBRUNnaEIsU0FGRCxXQUVDQSxTQUZEO1VBRVlvRixTQUZaLFdBRVlBLFNBRlo7VUFFdUJGLE9BRnZCLFdBRXVCQSxPQUZ2QjtVQUVnQ0MsVUFGaEMsV0FFZ0NBLFVBRmhDOzs7VUFJRG5tQixRQUFRO3dDQUFBOzRCQUFBO3dCQUFBOzhCQUFBO2tDQUFBOztPQUFkOztVQVNJLENBQUNnaEIsU0FBRCxJQUFja0YsT0FBbEIsRUFBMkI7ZUFDbEIsSUFBUDs7YUFHQWhhO3VCQUFBOztvQkFDWSxLQUFLNmtCLGNBRGpCOzJCQUVtQi9QOzs0QkFFaEIsVUFBRCxFQUFnQmhoQixLQUFoQjtPQUxKOzs7O0VBbEZxQ29SOzs7QUE2RnpDMGYsWUFBWXRrQixTQUFaLEdBQXdCOzs7O2FBSVhKLFVBQVVXLEtBQVYsQ0FBZ0I7c0JBQ1BYLFVBQVVpRixJQURIO3lCQUVKakYsVUFBVWlGO0dBRnRCLENBSlc7Z0JBUVJqRixVQUFVaUYsSUFSRjtXQVNiakYsVUFBVVMsSUFURztjQVVWVCxVQUFVUyxJQVZBO2FBV1hULFVBQVVpRjtDQVh2Qjs7QUFjQXlmLFlBQVl4ZixZQUFaLEdBQTJCO2FBQ2QsT0FBT2QsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUM7Q0FEdEQ7Ozs7SUN4R3FCMGdCOzs7Ozs7Ozs7Ozs7OzsrTEFXbkI3ZSxRQUFlO2VBQ0osS0FESTtlQUVKO2FBR1g2RSxlQUFlLFVBQUNYLEtBQUQsRUFBNkM7WUFDckR2VyxLQUFMLENBQVdxWCxRQUFYLENBQW9CO2VBQ1hkLE1BQU00YSxhQUFOLENBQW9CcHRCLEtBRFQ7d0JBRUZ3UztPQUZsQjthQU1GNmEsY0FBYyxVQUFDN2EsS0FBRCxFQUE2QztZQUNwRHZXLEtBQUwsQ0FBV3FYLFFBQVgsQ0FBb0I7ZUFDWCxFQURXO3dCQUVGZDtPQUZsQjthQU1GRSxtQkFBbUI7YUFBTSxNQUFLbEUsUUFBTCxDQUFjLEVBQUVvRSxTQUFTLElBQVgsRUFBZCxDQUFOO2FBRW5CQyxtQkFBbUI7YUFBTSxNQUFLckUsUUFBTCxDQUFjLEVBQUVvRSxTQUFTLEtBQVgsRUFBZCxDQUFOO2FBRW5CYSxjQUFjLFVBQUNqQixLQUFELEVBQTZDO1lBQ3BEaEUsUUFBTCxDQUFjLEVBQUVnRixTQUFTLElBQVgsRUFBZDs7VUFFSSxNQUFLdlgsS0FBTCxDQUFXcXhCLE9BQWYsRUFBd0I7Y0FDakJyeEIsS0FBTCxDQUFXcXhCLE9BQVgsQ0FBbUI7aUJBQ1Y5YSxNQUFNNGEsYUFBTixDQUFvQnB0QixLQURWOzBCQUVEd1M7U0FGbEI7O2FBT0plLGFBQWEsVUFBQ2YsS0FBRCxFQUE2QztZQUNuRGhFLFFBQUwsQ0FBYyxFQUFFZ0YsU0FBUyxLQUFYLEVBQWQ7O1VBRUksTUFBS3ZYLEtBQUwsQ0FBV3N4QixNQUFmLEVBQXVCO2NBQ2hCdHhCLEtBQUwsQ0FBV3N4QixNQUFYLENBQWtCLEVBQUUvYSxZQUFGLEVBQWxCOzs7Ozs7OzZCQUlLO21CQUNnRCxLQUFLdlcsS0FEckQ7VUFDQ2tQLGtCQURELFVBQ0NBLGtCQUREO1VBQ3FCNEksRUFEckIsVUFDcUJBLEVBRHJCO1VBQ3lCeVosV0FEekIsVUFDeUJBLFdBRHpCO1VBQ3NDeHRCLEtBRHRDLFVBQ3NDQSxLQUR0Qzs7Ozs7VUFLRHl0QixZQUNKLENBQUMsS0FBS25mLEtBQUwsQ0FBV2tGLE9BQVgsSUFBc0IsS0FBS2xGLEtBQUwsQ0FBV3NFLE9BQWxDLEtBQThDNVMsS0FBOUMsSUFBdURBLE1BQU16RCxNQUFOLEdBQWUsQ0FEeEU7O2FBSUU0TDtXQUFBOzttQkFDVSxNQURWO29CQUVXLFVBRlg7c0JBR2EsUUFIYjt3QkFJZ0IsS0FBS3VLLGdCQUpyQjt3QkFLZ0IsS0FBS0csZ0JBTHJCO21CQU1XLEtBQUtZLFdBTmhCO2tCQU9VLEtBQUtGLFVBUGY7aUJBUVE7OzthQUVOOzt1Q0FDNkI7dUJBQ2hCOytCQUNRLE1BRFI7O3FCQUdGLEtBSEU7MkJBSUk7O2FBTmpCO3NCQVNXLFVBVFg7c0JBQUE7c0JBV1k7OzhCQUVULElBQUQsSUFBTSxNQUFLLFFBQVgsRUFBb0Isb0JBQW1CLEVBQXZDO1NBdkJKOzt3QkEwQmdCcEksa0JBRGQ7cUJBRWEvUCxVQUFPeVksS0FGcEI7Y0FHTUUsRUFITjtvQkFJWSxLQUFLWixZQUpqQjt1QkFLZXFhLFdBTGY7Z0JBTU8sV0FOUDtnQkFPTyxRQVBQO2lCQVFTeHRCO1VBakNYO3FCQW9DSW1JO2FBQUE7WUFBSyxVQUFTLFVBQWQsRUFBeUIsV0FBekIsRUFBK0IsU0FBL0I7Ozs7eUJBRWUvTSxVQUFPc3lCLEtBRHBCO3VCQUVXLEtBQUtMLFdBRmhCO3dCQUdZLENBQUMsQ0FIYjtvQkFJTzs7Z0NBRUosSUFBRCxJQUFNLE1BQUssT0FBWCxFQUFtQixvQkFBbUIsRUFBdEM7OztPQTVDVjs7OztFQTdEcUNoZ0I7O0FBQXBCOGYsWUFDWjFrQixZQUFZO3NCQUNHSixVQUFVWSxNQUFWLENBQWlCOEMsVUFEcEI7TUFFYjFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUZKO1VBR1QxRCxVQUFVaUYsSUFIRDtZQUlQakYsVUFBVWlGLElBQVYsQ0FBZXZCLFVBSlI7V0FLUjFELFVBQVVpRixJQUxGO2VBTUpqRixVQUFVWSxNQU5OO1NBT1ZaLFVBQVVZOzs7OztBQ3RCTixTQUFTMGtCLGdCQUFULENBQTBCMXhCLEtBQTFCLEVBQXdDOzs7TUFDN0NvWixLQUQ2QyxHQUNPcFosS0FEUCxDQUM3Q29aLEtBRDZDO01BQ3RDL0IsUUFEc0MsR0FDT3JYLEtBRFAsQ0FDdENxWCxRQURzQztNQUM1QnNhLGlCQUQ0QixHQUNPM3hCLEtBRFAsQ0FDNUIyeEIsaUJBRDRCO29CQUNPM3hCLEtBRFAsQ0FDVEMsSUFEUztNQUNUQSxJQURTLCtCQUNGLElBREU7O1NBR25EaU07OztpQkFDYXNELFdBQVdyUSxVQUFPdXlCLGdCQUFsQixpREFDUnZ5QixVQUFPK1csRUFEQyxFQUNJalcsU0FBUyxJQURiLCtCQUVSZCxVQUFPZ1gsRUFGQyxFQUVJbFcsU0FBUyxJQUZiLGdCQURiO1lBS087O1VBRUVILEdBQU4sQ0FBVSxVQUFDbVosSUFBRCxFQUFPb0IsQ0FBUCxFQUFhOzs7VUFDaEJ1WCxhQUFhdlgsTUFBTXNYLGlCQUF6QjtVQUNNcGlCLEtBQUtDLFdBQVdyUSxVQUFPOFosSUFBbEIsbURBQ1I5WixVQUFPMHlCLGlCQURDLEVBQ21CLENBQUNELFVBRHBCLGdDQUVSenlCLFVBQU8yeUIsY0FGQyxFQUVnQkYsVUFGaEIsaUJBQVg7YUFLRTFsQjs7OzJCQUNpQjBsQixVQURqQjtxQkFFYXJpQixFQUZiO2VBR084SyxDQUhQO21CQUlXO21CQUFLaEQsU0FBUyxFQUFFZCxPQUFPd2IsQ0FBVCxFQUFZQyxhQUFhM1gsQ0FBekIsRUFBVCxDQUFMO1dBSlg7Z0JBS08sS0FMUDtnQkFNTzs7ZUFFR3BCLElBQVAsS0FBZ0IsUUFBaEIsR0FDQy9NO2NBQUE7O3NCQUFBO21CQUVTMGxCLGFBQWEsVUFBYixHQUEwQixNQUZuQzttQkFHUSxRQUhSO2tCQUlRM3hCOzs7U0FMVCxHQVVDaU07YUFBQTtZQUFLLFNBQVEsTUFBYixFQUFvQixnQkFBZSxRQUFuQzs7O09BbkJOO0tBTkQ7R0FSTDs7O0FBNENGd2xCLGlCQUFpQmxsQixTQUFqQixHQUE2QjtTQUNwQkosVUFBVXNOLE9BQVYsQ0FBa0J0TixVQUFVSyxJQUE1QixFQUFrQ3FELFVBRGQ7WUFFakIxRCxVQUFVaUYsSUFBVixDQUFldkIsVUFGRTtxQkFHUjFELFVBQVVVLE1BQVYsQ0FBaUJnRDtDQUh0Qzs7OztJQzlCcUJtaUI7Ozs7Ozs7Ozs7Ozs7OzZMQXdCbkI1ZixRQUFRO2VBQ0csS0FESDttQkFFTzthQWNmNmYsaUJBQWlCLFVBQUMzYixLQUFELEVBQWtDO1VBRS9DQSxNQUFNYSxNQUFOLFlBQXdCK2EsaUJBQXhCLElBQ0EsTUFBS255QixLQUFMLENBQVcrRCxLQUFYLEtBQXFCd1MsTUFBTWEsTUFBTixDQUFhclQsS0FGcEMsRUFHRTtjQUNLL0QsS0FBTCxDQUFXcVgsUUFBWCxDQUFvQixFQUFFZCxZQUFGLEVBQVN4UyxPQUFPd1MsTUFBTWEsTUFBTixDQUFhclQsS0FBN0IsRUFBcEI7O1lBRUksTUFBSy9ELEtBQUwsQ0FBV295QixZQUFmLEVBQTZCO2dCQUN0QjdmLFFBQUwsQ0FBYyxFQUFFOGYsYUFBYSxLQUFmLEVBQWQ7OzthQUtOL2EsYUFBYSxZQUFNO1VBQ2IsTUFBS3RYLEtBQUwsQ0FBV295QixZQUFmLEVBQTZCO2NBQ3RCN2YsUUFBTCxDQUFjLEVBQUU4ZixhQUFhLEtBQWYsRUFBZDs7YUFJSjdhLGNBQWMsWUFBTTtVQUNkLE1BQUt4WCxLQUFMLENBQVdveUIsWUFBZixFQUE2QjtjQUN0QjdmLFFBQUwsQ0FBYyxFQUFFOGYsYUFBYSxJQUFmLEVBQWQ7Ozs7Ozs7NkJBTUs7OzttQkFVSCxLQUFLcnlCLEtBVkY7VUFFTDBWLFFBRkssVUFFTEEsUUFGSztVQUdMMGMsWUFISyxVQUdMQSxZQUhLO1VBSUx0YSxFQUpLLFVBSUxBLEVBSks7VUFLTHdhLG1CQUxLLFVBS0xBLG1CQUxLO1VBTUxoeEIsSUFOSyxVQU1MQSxJQU5LO1VBT0xpeEIsT0FQSyxVQU9MQSxPQVBLO1VBUUxoQixXQVJLLFVBUUxBLFdBUks7VUFTTHh0QixLQVRLLFVBU0xBLEtBVEs7OztVQVlEZ1MsVUFBVXZHLFdBQ2RyUSxVQUFPcXpCLE1BRE8sRUFFZDljLFdBQVd2VyxVQUFPdVcsUUFBbEIsR0FBNkJ2VyxVQUFPa1gsT0FGdEIsRUFHZCtiLGVBQWVqekIsVUFBT3N6QixPQUF0QixHQUFnQ3R6QixVQUFPdXpCLE1BSHpCLENBQWhCOzthQU9FeG1CO1dBQUE7O2lCQUNTd0osV0FBVyxXQUFYLEdBQXlCLE9BRGxDO3FDQUU2QixFQUFFdkssU0FBUyxFQUFFd25CLGNBQWMsQ0FBaEIsRUFBWCxFQUY3QjttQkFHVSxNQUhWO29CQUlXLFVBSlg7aUJBS1E7OzthQUVOOzt3QkFDYSxRQURiO3dCQUFBO3VDQUc2Qjt1QkFDaEIsRUFBRWpELGNBQWMsRUFBaEIsRUFBb0JrRCxZQUFZLENBQWhDO2FBSmI7cUJBTVUsTUFOVjtzQkFPVyxVQVBYO3VCQUFBOzs7OEJBV0csSUFBRDtrQkFDTyxZQURQO2tCQUVRLEVBRlI7bUJBR1NsZCxXQUFXLE1BQVgsR0FBb0IsVUFIN0I7Z0NBSXFCOztTQXRCekI7Ozs7Z0NBMkJNMGMsZ0JBQWdCLEtBQUsvZixLQUFMLENBQVdrRixPQUEzQixHQUF3Q08sRUFBeEMsc0JBQTZELElBRmpFOzRCQUlnQnNhLGVBQWUsTUFBZixHQUF3QixPQUp4Qzt1QkFLYXJjLE9BTGI7c0JBTVlMLFFBTlo7Z0JBT01vQyxFQVBOO2tCQVFReFcsSUFSUjtvQkFTVSxLQUFLZ1csVUFUZjtxQkFVVyxLQUFLRSxXQVZoQjtzQkFXWSxLQUFLMGEsY0FYakI7aUJBWU8sZ0JBQUs7cUJBQ0hNLE1BQUwsR0FBY251QixDQUFkO2FBYko7bUJBZVNOOzt5QkFHTCxDQUFDQSxLQURGLElBRUdtSTs7Y0FBUSxjQUFSLEVBQWlCLGNBQWpCLEVBQTBCLFdBQTFCLEVBQWdDLFlBQWhDOztXQW5CTjtrQkF1QldwTSxHQUFSLENBQVk7bUJBQ1hvTTs7Z0JBQVEsS0FBSzJtQixPQUFPOXVCLEtBQXBCLEVBQTJCLE9BQU84dUIsT0FBTzl1QixLQUF6QztxQkFDVTBnQjthQUZDO1dBQVo7U0FoREw7d0JBdURJLEtBQUtwUyxLQUFMLENBQVdnZ0IsV0FEWixJQUVHbm1CO2dCQUFBOztvQkFDVSxLQUFLc21CLE1BRGY7bUJBRVEsUUFGUjs0QkFHa0JGLG1CQUhsQjt1QkFJYTtxQkFBTSxPQUFLL2YsUUFBTCxDQUFjLEVBQUU4ZixhQUFhLEtBQWYsRUFBZCxDQUFOO2FBSmI7a0JBS087OztlQUVMO2NBQUssU0FBUyxDQUFkOztrQkFDRTtnQkFBTSxVQUFOLEVBQVcsT0FBTSxPQUFqQjs7O2tCQUNRLElBQU92YSxFQUFQLG1CQUFOOzs7Ozs7T0FsRWQ7Ozs7NkNBeEQ4QjlYLE9BQWNxUyxPQUFjO1VBQ3REclMsTUFBTW95QixZQUFOLEtBQXVCL2YsTUFBTStmLFlBQWpDLEVBQStDO2VBQ3RDO3VCQUNRLENBQUMsQ0FBQ3B5QixNQUFNb3lCLFlBRGhCO3dCQUVTcHlCLE1BQU1veUI7U0FGdEI7OzthQU1LLElBQVA7Ozs7RUFyQ29DaGhCOztBQUFuQjZnQixXQUNaemxCLFlBQVk7WUFDUEosVUFBVVMsSUFESDtnQkFFSFQsVUFBVVksTUFGUDtNQUdiWixVQUFVWSxNQUFWLENBQWlCOEMsVUFISjt1QkFJSTFELFVBQVVZLE1BSmQ7UUFLWFosVUFBVVksTUFMQztZQU1QWixVQUFVaUYsSUFBVixDQUFldkIsVUFOUjtXQU9SMUQsVUFBVXNOLE9BQVYsQ0FDUHROLFVBQVVNLEtBQVYsQ0FBZ0I7V0FDUE4sVUFBVVksTUFBVixDQUFpQjhDLFVBRFY7V0FFUDFELFVBQVVZLE1BQVYsQ0FBaUI4QztHQUYxQixDQURPLENBUFE7ZUFhSjFELFVBQVVZLE1BYk47U0FjVlosVUFBVVk7O0FBZkFpbEIsV0FrQlozZ0IsZUFBZTtZQUNWLEtBRFU7dUJBRUMsT0FGRDtXQUdYOzs7OztBQzdDYixJQUFNd2hCLE9BQU8sRUFBYjs7QUFPQSxBQUFlLFNBQVNDLE9BQVQsT0FBc0Q7TUFBbkM3akIsa0JBQW1DLFFBQW5DQSxrQkFBbUM7TUFBZjhqQixJQUFlLFFBQWZBLElBQWU7O1NBQzVEQSxPQUNMOW1CO09BQUE7TUFBSyxJQUFJLEVBQUVwSSxTQUFTLE1BQVgsRUFBVCxFQUE4QixnQkFBZSxRQUE3QyxFQUFzRCxVQUFTLFFBQS9EOzs7UUFDTyxXQUFXM0UsVUFBT2lRLElBQXZCOzBCQUNHLElBQUQ7Y0FDTyxPQURQOzRCQUVzQkYsa0JBRnRCO2NBR1E0akI7OztHQU5QLEdBV0w1bUIsZ0NBWEY7OztBQWVGNm1CLFFBQVF2bUIsU0FBUixHQUFvQjtRQUNaSixVQUFVUyxJQUFWLENBQWVpRCxVQURIO3NCQUVFMUQsVUFBVVksTUFBVixDQUFpQjhDO0NBRnZDOztBQ0plLFNBQVNtakIsTUFBVCxDQUFnQmp6QixLQUFoQixFQUE4Qjs4QkFDa0JBLEtBRGxCLENBQ25Da3pCLG9CQURtQztNQUNuQ0Esb0JBRG1DLHlDQUNaLEVBQUVDLFVBQVUsQ0FBWixFQURZO01BQ0t0bkIsUUFETCxHQUNrQjdMLEtBRGxCLENBQ0s2TCxRQURMOztNQUVyQ3RMLFFBQVE7U0FDUFAsTUFBTW9KLEdBQU4sSUFBYSxJQUFiLEdBQW9CcEosTUFBTW9KLEdBQTFCLEdBQWdDd0csU0FEekI7VUFFTjVQLE1BQU1zSixJQUFOLElBQWMsSUFBZCxHQUFxQnRKLE1BQU1zSixJQUEzQixHQUFrQ3NHLFNBRjVCO1dBR0w1UCxNQUFNd0osS0FBTixJQUFlLElBQWYsR0FBc0J4SixNQUFNd0osS0FBNUIsR0FBb0NvRyxTQUgvQjtZQUlKNVAsTUFBTXFKLE1BQU4sSUFBZ0IsSUFBaEIsR0FBdUJySixNQUFNcUosTUFBN0IsR0FBc0N1RyxTQUpsQzs7WUFNSnNqQixxQkFBcUJDO0dBTi9CO1NBU0VqbkI7O01BQUssV0FBV2hHLE9BQU9rdEIsTUFBdkIsRUFBK0IsT0FBTzd5QixLQUF0Qzs7R0FERjs7O0FBT0YweUIsT0FBT3ptQixTQUFQLEdBQW1CO1lBQ1BKLFVBQVVLLElBREg7d0JBRUtMLFVBQVVNLEtBQVYsQ0FBZ0I7Y0FDMUJOLFVBQVVVO0dBREEsQ0FGTDtPQUtaVixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCLENBTFk7UUFNWFosVUFBVVEsU0FBVixDQUFvQixDQUFDUixVQUFVVSxNQUFYLEVBQW1CVixVQUFVWSxNQUE3QixDQUFwQixDQU5XO1VBT1RaLFVBQVVRLFNBQVYsQ0FBb0IsQ0FBQ1IsVUFBVVUsTUFBWCxFQUFtQlYsVUFBVVksTUFBN0IsQ0FBcEIsQ0FQUztTQVFWWixVQUFVUSxTQUFWLENBQW9CLENBQUNSLFVBQVVVLE1BQVgsRUFBbUJWLFVBQVVZLE1BQTdCLENBQXBCO0NBUlQ7Ozs7SUN6QnFCcW1COzs7Ozs7Ozs7Ozs7OztxTEFjbkJoaEIsUUFBZTtlQUNKO2FBR1hpRixhQUFhO2FBQU0sTUFBSy9FLFFBQUwsQ0FBYyxFQUFFZ0YsU0FBUyxLQUFYLEVBQWQsQ0FBTjthQUViTCxlQUFlLFVBQUNYLEtBQUQsRUFBa0M7VUFDdkNZLE9BRHVDLEdBQzNCWixNQUFNYSxNQURxQixDQUN2Q0QsT0FEdUM7O1lBRTFDblgsS0FBTCxDQUFXcVgsUUFBWCxDQUFvQjtvQkFBQTtlQUVYRjtPQUZUO2FBTUZLLGNBQWMsWUFBTTtZQUNiakYsUUFBTCxDQUFjLEVBQUVnRixTQUFTLElBQVgsRUFBZDs7Ozs7OzZCQUdPO21CQUNrQyxLQUFLdlgsS0FEdkM7VUFDQzBWLFFBREQsVUFDQ0EsUUFERDtVQUNXb0MsRUFEWCxVQUNXQSxFQURYO1VBQ2V4VyxJQURmLFVBQ2VBLElBRGY7VUFDcUJneUIsUUFEckIsVUFDcUJBLFFBRHJCOzs7VUFHREMsZUFBZS9qQixXQUNuQnJRLFVBQU9xMEIsTUFEWSxxQkFHaEJyMEIsVUFBT29ZLE9BSFMsRUFHQyxLQUFLbEYsS0FBTCxDQUFXa0YsT0FIWjs7aUJBT2YrYixXQUFXbjBCLFVBQU9zMEIsVUFBbEIsR0FBK0J0MEIsVUFBT3UwQixlQUQxQyxHQUVJSixXQUFXbjBCLFVBQU93MEIsY0FBbEIsR0FBbUN4MEIsVUFBT3kwQixXQVIzQixDQUFyQjs7VUFXTUMsZUFBZXJrQixXQUNuQnJRLFVBQU8yMEIsTUFEWSxFQUVuQlIsV0FBV24wQixVQUFPNDBCLFdBQWxCLEdBQWdDNTBCLFVBQU82MEIsVUFGcEIsRUFHbkJWLFlBQVksQ0FBQzVkLFFBQWIsR0FBd0J2VyxVQUFPODBCLFVBQS9CLEdBQTRDOTBCLFVBQU8rMEIsV0FIaEMsQ0FBckI7O1VBTU1DLGNBQWMza0IsV0FBV3JRLFVBQU9pMUIsUUFBbEIscUJBQ2pCajFCLFVBQU9rMUIsZUFEVSxFQUNRLENBQUMzZSxRQURULEVBQXBCOzthQUtFeEo7O1VBQUssV0FBV3FuQixZQUFoQjs7bUJBRWFELFFBRFg7cUJBRWFhLFdBRmI7b0JBR1l6ZSxRQUhaO2NBSU1vQyxFQUpOO2dCQUtReFcsSUFMUjtrQkFNVSxLQUFLZ1csVUFOZjtvQkFPWSxLQUFLSixZQVBqQjttQkFRVyxLQUFLTSxXQVJoQjtnQkFTTztVQVZUO3FDQVlPLFdBQVdxYyxZQUFoQjtPQWJKOzs7O0VBeERnQ3ppQjs7QUFBZmlpQixPQUNaN21CLFlBQVk7WUFDUEosVUFBVVMsSUFESDtNQUViVCxVQUFVWSxNQUFWLENBQWlCOEMsVUFGSjtRQUdYMUQsVUFBVVksTUFIQztZQUlQWixVQUFVaUYsSUFBVixDQUFldkIsVUFKUjtZQUtQMUQsVUFBVVM7O0FBTkh3bUIsT0FTWi9oQixlQUFlO1lBQ1YsS0FEVTtZQUVWOzs7OztJQ0xPZ2pCOzs7Ozs7Ozs7Ozs7OztpTEFZbkJqaUIsUUFBZTt1QkFDSXpDLFNBREo7dUJBRUlBO2FBR25CMmtCLGlCQUFpQixVQUFDbGEsQ0FBRCxFQUFZMFgsQ0FBWixFQUF5QztVQUNoRDFhLFFBRGdELEdBQ25DLE1BQUtyWCxLQUQ4QixDQUNoRHFYLFFBRGdEOztlQUUvQyxFQUFFbWQsZ0JBQWdCbmEsQ0FBbEIsRUFBcUI5RCxPQUFPd2IsQ0FBNUIsRUFBVDthQUdGMEMsaUJBQWlCLFVBQUNwYSxDQUFEO2FBQWUsTUFBSzlILFFBQUwsQ0FBYyxFQUFFbWlCLGlCQUFpQnJhLENBQW5CLEVBQWQsQ0FBZjthQUVqQnNhLGdCQUFnQjthQUFNLE1BQUtwaUIsUUFBTCxDQUFjLEVBQUVtaUIsaUJBQWlCOWtCLFNBQW5CLEVBQWQsQ0FBTjthQUVoQmdsQixzQkFBc0IsVUFBQ3ZhLENBQUQ7YUFBZSxNQUFLOUgsUUFBTCxDQUFjLEVBQUVzaUIsaUJBQWlCeGEsQ0FBbkIsRUFBZCxDQUFmO2FBRXRCeWEsc0JBQXNCO2FBQU0sTUFBS3ZpQixRQUFMLENBQWMsRUFBRXNpQixpQkFBaUJqbEIsU0FBbkIsRUFBZCxDQUFOOzs7Ozs7NkJBRWI7OzttQkFDMEIsS0FBSzVQLEtBRC9CO1VBQ0MrMEIsSUFERCxVQUNDQSxJQUREO1VBQ09QLGNBRFAsVUFDT0EsY0FEUDttQkFFc0MsS0FBS25pQixLQUYzQztVQUVDcWlCLGVBRkQsVUFFQ0EsZUFGRDtVQUVrQkcsZUFGbEIsVUFFa0JBLGVBRmxCOzthQUlMM29COztVQUFLLFdBQVcvTSxVQUFPbTFCLElBQXZCLEVBQTZCLE1BQUssU0FBbEM7YUFDUXgwQixHQUFMLENBQVMsaUJBQWlCdWEsQ0FBakIsRUFBdUI7OztjQUFwQnpFLElBQW9CLFNBQXBCQSxJQUFvQjtjQUFkNlAsSUFBYyxTQUFkQSxJQUFjOztjQUN6QnVQLFdBQVczYSxNQUFNbWEsY0FBdkI7Y0FDTVMsWUFBWTVhLE1BQU13YSxlQUF4QjtjQUNNSyxZQUFZN2EsTUFBTXFhLGVBQXhCO2NBQ01ubEIsS0FBS0MsV0FBV3JRLFVBQU9nMkIsR0FBbEIsaURBQ1JoMkIsVUFBT2kyQixjQURDLEVBQ2dCLENBQUNKLFFBRGpCLCtCQUVSNzFCLFVBQU9rMkIsV0FGQyxFQUVhTCxRQUZiLGdCQUFYO2lCQUtFOW9COzs7K0JBQ2lCOG9CLFFBRGpCO3lCQUVhemxCLEVBRmI7b0JBR1FrVyxJQUhSO21CQUlPcEwsQ0FKUDt1QkFLVyxpQkFBQzBYLENBQUQ7dUJBQThCLE9BQUt3QyxjQUFMLENBQW9CbGEsQ0FBcEIsRUFBdUIwWCxDQUF2QixDQUE5QjtlQUxYO3VCQU1XO3VCQUFNLE9BQUswQyxjQUFMLENBQW9CcGEsQ0FBcEIsQ0FBTjtlQU5YO3NCQU9VLE9BQUtzYSxhQVBmOzRCQVFnQjt1QkFBTSxPQUFLQyxtQkFBTCxDQUF5QnZhLENBQXpCLENBQU47ZUFSaEI7NEJBU2dCLE9BQUt5YSxtQkFUckI7b0JBVU87OztrQkFFTDs7MEJBQUE7dUJBRVNFLFlBQVlDLFNBQVosSUFBeUJDLFNBQXpCLEdBQXFDLFVBQXJDLEdBQWtELE1BRjNEO3NCQUdPOzs7O1dBaEJYO1NBUkQ7T0FGTDs7OztFQWpDOEI5akI7O0FBQWJrakIsS0FDWjluQixZQUFZO2tCQUNESixVQUFVVSxNQUFWLENBQWlCZ0QsVUFEaEI7UUFFWDFELFVBQVVzTixPQUFWLENBQ0p0TixVQUFVTSxLQUFWLENBQWdCO1VBQ1JOLFVBQVVLLElBREY7VUFFUkwsVUFBVVk7R0FGbEIsQ0FESSxFQUtKOEMsVUFQZTtZQVFQMUQsVUFBVWlGLElBQVYsQ0FBZXZCOzs7OztJQ1dSd2xCOzs7Ozs7Ozs7Ozs7Ozt5TEF3Qm5CampCLFFBQVE7ZUFDRyxLQURIO21CQUVPO2FBY2Y2RSxlQUFlLFVBQUNYLEtBQUQsRUFBcUQ7WUFDN0R2VyxLQUFMLENBQVdxWCxRQUFYLENBQW9CO29CQUFBO2VBRVhkLE1BQU00YSxhQUFOLENBQW9CcHRCO09BRjdCOztVQUtJLE1BQUsvRCxLQUFMLENBQVdveUIsWUFBZixFQUE2QjtjQUN0QjdmLFFBQUwsQ0FBYyxFQUFFOGYsYUFBYSxJQUFmLEVBQWQ7O2FBSUovYSxhQUFhLFVBQUNmLEtBQUQsRUFBcUQ7VUFDNUQsTUFBS3ZXLEtBQUwsQ0FBV295QixZQUFmLEVBQTZCO2NBQ3RCN2YsUUFBTCxDQUFjLEVBQUU4ZixhQUFhLEtBQWYsRUFBZDs7VUFFRSxNQUFLcnlCLEtBQUwsQ0FBV3N4QixNQUFmLEVBQXVCO2NBQ2hCdHhCLEtBQUwsQ0FBV3N4QixNQUFYLENBQWtCO3NCQUFBO2lCQUVUL2EsTUFBTTRhLGFBQU4sQ0FBb0JwdEI7U0FGN0I7O2FBT0p5VCxjQUFjLFVBQUNqQixLQUFELEVBQXFEO1VBQzdELE1BQUt2VyxLQUFMLENBQVdveUIsWUFBZixFQUE2QjtjQUN0QjdmLFFBQUwsQ0FBYyxFQUFFOGYsYUFBYSxJQUFmLEVBQWQ7O1VBRUUsTUFBS3J5QixLQUFMLENBQVdxeEIsT0FBZixFQUF3QjtjQUNqQnJ4QixLQUFMLENBQVdxeEIsT0FBWCxDQUFtQjtzQkFBQTtpQkFFVjlhLE1BQU00YSxhQUFOLENBQW9CcHRCO1NBRjdCOzthQU9KNGQsZ0JBQWdCLFVBQUNwTCxLQUFELEVBQXdEO1VBQ2xFLE1BQUt2VyxLQUFMLENBQVd3Z0IsU0FBZixFQUEwQjtjQUNuQnhnQixLQUFMLENBQVd3Z0IsU0FBWCxDQUFxQjtzQkFBQTtpQkFFWmpLLE1BQU00YSxhQUFOLENBQW9CcHRCO1NBRjdCOzs7Ozs7OzZCQVNLOzs7bUJBV0gsS0FBSy9ELEtBWEY7VUFFTDBWLFFBRkssVUFFTEEsUUFGSztVQUdMMGMsWUFISyxVQUdMQSxZQUhLO1VBSUx2YSxRQUpLLFVBSUxBLFFBSks7VUFLTEMsRUFMSyxVQUtMQSxFQUxLO1VBTUx3YSxtQkFOSyxVQU1MQSxtQkFOSztVQU9MaHhCLElBUEssVUFPTEEsSUFQSztVQVFMaXdCLFdBUkssVUFRTEEsV0FSSztVQVNMZ0UsSUFUSyxVQVNMQSxJQVRLO1VBVUx4eEIsS0FWSyxVQVVMQSxLQVZLOzs7VUFhRGdTLFVBQVV2RyxXQUNkclEsVUFBT3EyQixRQURPLEVBRWQ5ZixXQUFXdlcsVUFBT3VXLFFBQWxCLEdBQTZCdlcsVUFBT2tYLE9BRnRCLEVBR2R3QixZQUFZdWEsWUFBWixHQUEyQmp6QixVQUFPc3pCLE9BQWxDLEdBQTRDdHpCLFVBQU91ekIsTUFIckMsQ0FBaEI7O2FBT0V4bUI7Ozs7OEJBR01rbUIsZ0JBQWdCLEtBQUsvZixLQUFMLENBQVdrRixPQUEzQixHQUF3Q08sRUFBeEMsc0JBQTZELElBRmpFOzBCQUlnQnNhLGdCQUFnQnZhLFFBQWhCLEdBQTJCLE1BQTNCLEdBQW9DLE9BSnBEO3FCQUthOUIsT0FMYjtvQkFNWUwsUUFOWjtjQU9Nb0MsRUFQTjtnQkFRUXhXLElBUlI7a0JBU1UsS0FBS2dXLFVBVGY7b0JBVVksS0FBS0osWUFWakI7bUJBV1csS0FBS00sV0FYaEI7cUJBWWEsS0FBS21LLGFBWmxCO3VCQWFlNFAsV0FiZjtlQWNPLGdCQUFLO21CQUNIa0UsUUFBTCxHQUFnQnB4QixDQUFoQjtXQWZKO2dCQWlCUWt4QixJQWpCUjtpQkFrQlN4eEI7VUFuQlg7d0JBcUJtQixLQUFLc08sS0FBTCxDQUFXZ2dCLFdBQTNCLEdBQ0NubUI7Z0JBQUE7O29CQUNVLEtBQUt1cEIsUUFEZjttQkFFUSxRQUZSOzRCQUdrQm5ELG1CQUhsQjt1QkFJYTtxQkFBTSxPQUFLL2YsUUFBTCxDQUFjLEVBQUU4ZixhQUFhLEtBQWYsRUFBZCxDQUFOO2FBSmI7a0JBS087OztlQUVMO2NBQUssU0FBUyxDQUFkOztrQkFDRTtnQkFBTSxVQUFOLEVBQVcsT0FBTSxPQUFqQjs7O2tCQUNRLElBQU92YSxFQUFQLG1CQUFOOzs7OztTQVZQLEdBY0c7T0FwQ1I7Ozs7NkNBNUU4QjlYLE9BQWNxUyxPQUFjO1VBQ3REclMsTUFBTW95QixZQUFOLEtBQXVCL2YsTUFBTStmLFlBQWpDLEVBQStDO2VBQ3RDO3VCQUNRLENBQUMsQ0FBQ3B5QixNQUFNb3lCLFlBRGhCO3dCQUVTcHlCLE1BQU1veUI7U0FGdEI7OzthQU1LLElBQVA7Ozs7RUFyQ2tDaGhCOztBQUFqQmtrQixTQUNaOW9CLFlBQVk7WUFDUEosVUFBVVMsSUFESDtnQkFFSFQsVUFBVVksTUFGUDtZQUdQWixVQUFVUyxJQUhIO01BSWJULFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUpKO3VCQUtJMUQsVUFBVVksTUFMZDtRQU1YWixVQUFVWSxNQU5DO1VBT1RaLFVBQVVpRixJQVBEO1lBUVBqRixVQUFVaUYsSUFBVixDQUFldkIsVUFSUjtXQVNSMUQsVUFBVWlGLElBVEY7YUFVTmpGLFVBQVVpRixJQVZKO2VBV0pqRixVQUFVWSxNQVhOO1FBWVhaLFVBQVVVLE1BWkM7U0FhVlYsVUFBVVk7O0FBZEFzb0IsU0FpQlpoa0IsZUFBZTtZQUNWLEtBRFU7WUFFVixLQUZVO3VCQUdDLE9BSEQ7UUFJZDs7Ozs7SUNwQldva0I7Ozs7Ozs7Ozs7Ozs7OzJMQXFDbkJyakIsUUFBUTtlQUNHLEtBREg7bUJBRU87YUFjZjZFLGVBQWUsVUFBQ1gsS0FBRCxFQUFrRDtZQUMxRHZXLEtBQUwsQ0FBV3FYLFFBQVgsQ0FBb0I7b0JBQUE7ZUFFWGQsTUFBTTRhLGFBQU4sQ0FBb0JwdEI7T0FGN0I7YUFNRnVULGFBQWEsVUFBQ2YsS0FBRCxFQUFrRDtVQUN6RCxNQUFLdlcsS0FBTCxDQUFXb3lCLFlBQWYsRUFBNkI7Y0FDdEI3ZixRQUFMLENBQWMsRUFBRThmLGFBQWEsS0FBZixFQUFkOztVQUVFLE1BQUtyeUIsS0FBTCxDQUFXc3hCLE1BQWYsRUFBdUI7Y0FDaEJ0eEIsS0FBTCxDQUFXc3hCLE1BQVgsQ0FBa0I7c0JBQUE7aUJBRVQvYSxNQUFNNGEsYUFBTixDQUFvQnB0QjtTQUY3Qjs7YUFPSnlULGNBQWMsVUFBQ2pCLEtBQUQsRUFBa0Q7VUFDMUQsTUFBS3ZXLEtBQUwsQ0FBV295QixZQUFmLEVBQTZCO2NBQ3RCN2YsUUFBTCxDQUFjLEVBQUU4ZixhQUFhLElBQWYsRUFBZDs7VUFFRSxNQUFLcnlCLEtBQUwsQ0FBV3F4QixPQUFmLEVBQXdCO2NBQ2pCcnhCLEtBQUwsQ0FBV3F4QixPQUFYLENBQW1CO3NCQUFBO2lCQUVWOWEsTUFBTTRhLGFBQU4sQ0FBb0JwdEI7U0FGN0I7O2FBT0o0ZCxnQkFBZ0IsVUFBQ3BMLEtBQUQsRUFBcUQ7VUFDL0QsTUFBS3ZXLEtBQUwsQ0FBV3dnQixTQUFmLEVBQTBCO2NBQ25CeGdCLEtBQUwsQ0FBV3dnQixTQUFYLENBQXFCO3NCQUFBO2lCQUVaakssTUFBTTRhLGFBQU4sQ0FBb0JwdEI7U0FGN0I7Ozs7Ozs7NkJBU0s7OzttQkFZSCxLQUFLL0QsS0FaRjtVQUVMMjFCLFlBRkssVUFFTEEsWUFGSztVQUdMamdCLFFBSEssVUFHTEEsUUFISztVQUlMMGMsWUFKSyxVQUlMQSxZQUpLO1VBS0x2YSxRQUxLLFVBS0xBLFFBTEs7VUFNTEMsRUFOSyxVQU1MQSxFQU5LO1VBT0x3YSxtQkFQSyxVQU9MQSxtQkFQSztVQVFMaHhCLElBUkssVUFRTEEsSUFSSztVQVNMaXdCLFdBVEssVUFTTEEsV0FUSztVQVVMMWIsSUFWSyxVQVVMQSxJQVZLO1VBV0w5UixLQVhLLFVBV0xBLEtBWEs7OztVQWNEZ1MsVUFBVXZHLFdBQ2RyUSxVQUFPeTJCLFNBRE8sRUFFZGxnQixXQUFXdlcsVUFBT3VXLFFBQWxCLEdBQTZCdlcsVUFBT2tYLE9BRnRCLEVBR2R3QixZQUFZdWEsWUFBWixHQUEyQmp6QixVQUFPc3pCLE9BQWxDLEdBQTRDdHpCLFVBQU91ekIsTUFIckMsQ0FBaEI7Ozs7VUFRTW1ELFVBQVVoZ0IsU0FBUyxRQUFULEdBQW9CLE1BQXBCLEdBQTZCakcsU0FBN0M7O2FBR0UxRDs7Ozs4QkFHTWttQixnQkFBZ0IsS0FBSy9mLEtBQUwsQ0FBV2tGLE9BQTNCLEdBQXdDTyxFQUF4QyxzQkFBNkQsSUFGakU7MEJBSWdCc2EsZ0JBQWdCdmEsUUFBaEIsR0FBMkIsTUFBM0IsR0FBb0MsT0FKcEQ7d0JBS2dCOGQsWUFMaEI7cUJBTWE1ZixPQU5iO29CQU9ZTCxRQVBaO2NBUU1vQyxFQVJOO2dCQVNReFcsSUFUUjtrQkFVVSxLQUFLZ1csVUFWZjtvQkFXWSxLQUFLSixZQVhqQjttQkFZVyxLQUFLTSxXQVpoQjtxQkFhYSxLQUFLbUssYUFibEI7bUJBY1drVSxPQWRYO3VCQWVldEUsV0FmZjtlQWdCTyxnQkFBSzttQkFDSHVFLFNBQUwsR0FBaUJ6eEIsQ0FBakI7V0FqQko7Z0JBbUJRd1IsSUFuQlI7aUJBb0JTOVI7VUFyQlg7d0JBd0JJLEtBQUtzTyxLQUFMLENBQVdnZ0IsV0FEWixJQUVHbm1CO2dCQUFBOztvQkFDVSxLQUFLNHBCLFNBRGY7bUJBRVEsUUFGUjs0QkFHa0J4RCxtQkFIbEI7dUJBSWE7cUJBQU0sT0FBSy9mLFFBQUwsQ0FBYyxFQUFFOGYsYUFBYSxLQUFmLEVBQWQsQ0FBTjthQUpiO2tCQUtPOzs7ZUFFTDtjQUFLLFNBQVMsQ0FBZDs7a0JBQ0U7Z0JBQU0sVUFBTixFQUFXLE9BQU0sT0FBakI7OztrQkFDUSxJQUFPdmEsRUFBUCxtQkFBTjs7Ozs7O09BbkNkOzs7OzZDQTdFOEI5WCxPQUFjcVMsT0FBYztVQUN0RHJTLE1BQU1veUIsWUFBTixLQUF1Qi9mLE1BQU0rZixZQUFqQyxFQUErQztlQUN0Qzt1QkFDUSxDQUFDLENBQUNweUIsTUFBTW95QixZQURoQjt3QkFFU3B5QixNQUFNb3lCO1NBRnRCOzs7YUFNSyxJQUFQOzs7O0VBbERtQ2hoQjs7QUFBbEJza0IsVUFDWmxwQixZQUFZO2dCQUNISixVQUFVQyxLQUFWLENBQWdCLENBQzVCLGtCQUQ0QixFQUU1QixJQUY0QixFQUc1QixLQUg0QixFQUk1QixVQUo0QixDQUFoQixDQURHO1lBT1BELFVBQVVTLElBUEg7Z0JBUUhULFVBQVVZLE1BUlA7WUFTUFosVUFBVVMsSUFUSDtNQVViVCxVQUFVWSxNQUFWLENBQWlCOEMsVUFWSjt1QkFXSTFELFVBQVVZLE1BWGQ7UUFZWFosVUFBVVksTUFaQztVQWFUWixVQUFVaUYsSUFiRDtZQWNQakYsVUFBVWlGLElBQVYsQ0FBZXZCLFVBZFI7V0FlUjFELFVBQVVpRixJQWZGO2FBZ0JOakYsVUFBVWlGLElBaEJKO2VBaUJKakYsVUFBVVksTUFqQk47UUFrQlhaLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDcEIsTUFEb0IsRUFFcEIsT0FGb0IsRUFHcEIsUUFIb0IsRUFJcEIsVUFKb0IsRUFLcEIsTUFMb0IsRUFNcEIsS0FOb0IsQ0FBaEIsQ0FsQlc7U0EwQlZELFVBQVVZOztBQTNCQTBvQixVQThCWnBrQixlQUFlO1lBQ1YsS0FEVTtZQUVWLEtBRlU7dUJBR0MsT0FIRDtRQUlkOzs7QUNoRUssU0FBU3lrQixLQUFULENBQWUvMUIsS0FBZixFQUE2QjtxQkFDWUEsS0FEWixDQUNsQ21QLEtBRGtDO01BQ2xDQSxLQURrQyxnQ0FDMUIsVUFEMEI7TUFDZEMsSUFEYyxHQUNZcFAsS0FEWixDQUNkb1AsSUFEYztNQUNSNG1CLFNBRFEsR0FDWWgyQixLQURaLENBQ1JnMkIsU0FEUTtNQUNHcGdCLElBREgsR0FDWTVWLEtBRFosQ0FDRzRWLElBREg7OztNQUd0Q3NMLGlCQUFKOztNQUVJdEwsZ0JBQWdCaFcsS0FBaEIsSUFBeUJnVyxLQUFLdFYsTUFBTCxHQUFjLENBQTNDLEVBQThDO2VBRTFDNEw7U0FBQTtRQUFLLElBQUksRUFBRXBJLFNBQVMsTUFBWCxFQUFUOztXQUNFO1VBQUssSUFBSSxFQUFFQSxTQUFTLFlBQVgsRUFBVCxFQUFvQyxNQUFLLE1BQXpDLEVBQWdELGdCQUFlLFFBQS9EO29CQUVJb0k7Y0FBQTtZQUFNLE9BQU0sU0FBWixFQUFzQixRQUFRLEVBQTlCLEVBQWtDLE9BQU8sRUFBekM7O1NBREQsR0FJRztPQU5SOztXQVFFOztjQUNNLEVBQUVwSSxTQUFTLFlBQVgsRUFETjswQkFFaUIsUUFGakI7cUNBRzZCLEVBQUVxSCxTQUFTLEVBQUVza0IsYUFBYSxFQUFmLEVBQVg7OzthQUUzQjs7dUNBQzZCLEVBQUV0a0IsU0FBUyxFQUFFOHFCLFlBQVksUUFBZCxFQUFYOzs7Z0JBRTNCO2NBQU0sT0FBTSxPQUFaLEVBQW9CLE1BQUssSUFBekI7aUJBQ1EsQ0FBTDs7U0FUUDs7Y0FZRTtZQUFNLFVBQU4sRUFBVyxPQUFNLE9BQWpCLEVBQXlCLE1BQUssSUFBOUI7ZUFDUSxDQUFMOzs7S0F0QlQ7R0FERixNQTRCTzs7ZUFHSC9wQjtTQUFBOztZQUNNLEVBQUVwSSxTQUFTLE1BQVgsRUFETjt3QkFFaUIsU0FGakI7b0JBR2E7OztZQUVYO1VBQU0sVUFBTixFQUFXLE9BQU0sT0FBakIsRUFBeUIsTUFBSyxJQUE5Qjs7T0FMRjtjQVNJb0k7V0FBQTtVQUFLLDJCQUEyQixFQUFFZixTQUFTLEVBQUVza0IsYUFBYSxFQUFmLEVBQVgsRUFBaEM7NEJBQ0csSUFBRCxJQUFNLG9CQUFtQixFQUF6QixFQUE0QixPQUFNLE9BQWxDLEVBQTBDLE1BQU1yZ0IsSUFBaEQsRUFBc0QsTUFBTSxFQUE1RDs7S0FYUjs7O1NBbUJBbEQ7T0FBQTtNQUFLLGNBQWMsQ0FBbkIsRUFBc0IsVUFBVSxDQUFoQyxFQUFtQyxVQUFVLEdBQTdDLEVBQWtELE9BQU0sT0FBeEQ7O1NBQ0U7UUFBSyxPQUFPaUQsS0FBWixFQUFtQixTQUFuQixFQUF1QixVQUFVLENBQWpDLEVBQW9DLFVBQVUsQ0FBOUMsRUFBaUQsT0FBTSxNQUF2RDs7O0dBRko7OztBQVNGNG1CLE1BQU12cEIsU0FBTixHQUFrQjtTQUNUSixVQUFVQyxLQUFWLENBQWdCLENBQUMsVUFBRCxFQUFhLFFBQWIsQ0FBaEIsQ0FEUztRQUVWRCxVQUFVQyxLQUFWLENBQWdCLENBQUMsc0JBQUQsQ0FBaEIsQ0FGVTtRQUdWRCxVQUFVUSxTQUFWLENBQW9CLENBQ3hCUixVQUFVWSxNQURjLEVBRXhCWixVQUFVc04sT0FBVixDQUFrQnROLFVBQVVZLE1BQTVCLENBRndCLENBQXBCLEVBR0g4QyxVQU5hO2FBT0wxRCxVQUFVSztDQVB2Qjs7QUM5RGUsU0FBU3lwQixPQUFULENBQWlCbDJCLEtBQWpCLEVBQStCO01BRTFDK2hCLE1BRjBDLEdBUXhDL2hCLEtBUndDLENBRTFDK2hCLE1BRjBDO01BRzFDbFcsUUFIMEMsR0FReEM3TCxLQVJ3QyxDQUcxQzZMLFFBSDBDO01BSTFDbVIsY0FKMEMsR0FReENoZCxLQVJ3QyxDQUkxQ2dkLGNBSjBDO01BSzFDNkUsU0FMMEMsR0FReEM3aEIsS0FSd0MsQ0FLMUM2aEIsU0FMMEM7OEJBUXhDN2hCLEtBUndDLENBTTFDdWYsd0JBTjBDO01BTTFDQSx3QkFOMEMseUNBTWYsSUFOZTtvQkFReEN2ZixLQVJ3QyxDQU8xQ0MsSUFQMEM7TUFPMUNBLElBUDBDLCtCQU9uQyxJQVBtQzs7O01BVXhDLENBQUM4aEIsTUFBTCxFQUFhO1dBQ0osSUFBUDs7O1NBSUE3VjtjQUFBOztjQUNVNlYsTUFEVjtlQUVVLFVBRlY7c0JBR2tCL0UsY0FIbEI7Z0NBSTRCdUMsd0JBSjVCO2lCQUthc0MsU0FMYjtZQU1RNWhCOzs7U0FFTjtRQUFLLFFBQVEsRUFBYixFQUFpQixTQUFTLENBQTFCOzs7R0FUSjs7O0FBZ0JGaTJCLFFBQVExcEIsU0FBUixHQUFvQjtVQUNWSixVQUFVVyxLQUFWLENBQWdCO2NBQ1pYLFVBQVVpRixJQURFOzJCQUVDakYsVUFBVWlGO0dBRjNCLENBRFU7WUFLUmpGLFVBQVVLLElBTEY7a0JBTUZMLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixDQUFoQixDQU5FO2FBT1BELFVBQVVpRixJQUFWLENBQWV2QixVQVBSOzRCQVFRMUQsVUFBVVMsSUFSbEI7UUFTWlQsVUFBVUMsS0FBVixDQUFnQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFoQjtDQVRSOzs7O0FDSkEsSUFBTThwQixrQkFBa0IsRUFBeEI7QUFDQSxJQUFNQyxrQkFBa0IsRUFBeEI7O0lBRXFCQzs7Ozs7Ozs7Ozs7Ozs7MkxBQ25CQyxpQkFBaUIsVUFBQy9mLEtBQUQsRUFBbUQ7VUFDMURnZ0IsT0FEMEQsR0FDOUMsTUFBS3YyQixLQUR5QyxDQUMxRHUyQixPQUQwRDs7O1VBSWhFQSxZQUNDaGdCLE1BQU1pZ0IsUUFBTixLQUFtQkwsZUFBbkIsSUFBc0M1ZixNQUFNaWdCLFFBQU4sS0FBbUJKLGVBRDFELENBREYsRUFHRTs7Y0FFTXpILGNBQU47Z0JBQ1EsRUFBRXBZLFlBQUYsRUFBUjs7Ozs7Ozs2QkFJSzs7O21CQVVILEtBQUt2VyxLQVZGO1VBRUw2TCxRQUZLLFVBRUxBLFFBRks7b0NBR0w0cUIsU0FISztVQUdMQSxTQUhLLG9DQUdPLElBSFA7VUFJTEMsVUFKSyxVQUlMQSxVQUpLO3NDQUtMQyxXQUxLO1VBS0xBLFdBTEssc0NBS1MsU0FMVDtVQU1MamdCLFlBTkssVUFNTEEsWUFOSztVQU9MRyxZQVBLLFVBT0xBLFlBUEs7VUFRTDBmLE9BUkssVUFRTEEsT0FSSztnQ0FTTHhwQixLQVRLO1VBU0xBLEtBVEssZ0NBU0csUUFUSDs7O1VBWURnSixVQUFVdkcsV0FDZHJRLFVBQU95M0IsU0FETyxFQUVkejNCLFVBQU93M0IsV0FBUCxDQUZjLEVBR2R4M0IsVUFBTzROLEtBQVAsQ0FIYyxpREFLWDVOLFVBQU91M0IsVUFMSSxFQUtTQSxVQUxULCtCQU1YdjNCLFVBQU9zM0IsU0FOSSxFQU1RQSxTQU5SLGdCQUFoQjs7YUFXRXZxQjs7O3FCQUNhNkosT0FEYjttQkFFVzttQkFBU3dnQixXQUFXQSxRQUFRLEVBQUVoZ0IsWUFBRixFQUFSLENBQXBCO1dBRlg7Ozs7Ozs7Ozs7O1lBR2dCO21CQUFTRyxnQkFBZ0JBLGFBQWEsRUFBRUgsWUFBRixFQUFiLENBQXpCO1dBQWQsQ0FIRjs7Ozs7Ozs7Ozs7WUFJZ0I7bUJBQVNNLGdCQUFnQkEsYUFBYSxFQUFFTixZQUFGLEVBQWIsQ0FBekI7V0FBZCxDQUpGO3NCQUtjLEtBQUsrZixjQUxuQjtnQkFNTyxRQU5QO29CQU9XOzs7T0FSYjs7OztFQXBDbUNsbEI7OztBQW9EdkNpbEIsVUFBVTdwQixTQUFWLEdBQXNCO1lBQ1ZKLFVBQVVLLElBREE7Y0FFUkwsVUFBVVMsSUFGRjthQUdUVCxVQUFVUyxJQUhEO2VBSVBULFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDM0IsTUFEMkIsRUFFM0IsTUFGMkIsRUFHM0IsVUFIMkIsRUFJM0IsTUFKMkIsRUFLM0IsUUFMMkIsRUFNM0IsU0FOMkIsRUFPM0IsUUFQMkIsRUFRM0IsU0FSMkIsQ0FBaEIsQ0FKTztXQWNYRCxVQUFVaUYsSUFkQztnQkFlTmpGLFVBQVVpRixJQWZKO2dCQWdCTmpGLFVBQVVpRixJQWhCSjtTQWlCYmpGLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FDckIsUUFEcUIsRUFFckIsU0FGcUIsRUFHckIsTUFIcUIsRUFJckIsUUFKcUIsRUFLckIsWUFMcUIsRUFNckIsZUFOcUIsRUFPckIsYUFQcUIsRUFRckIsY0FScUIsQ0FBaEI7Q0FqQlQ7Ozs7SUMvRXFCd3FCOzs7Ozs7Ozs7Ozs7OzttTUFPbkJ4a0IsUUFBUTtlQUNHO2FBR1h5a0IsaUJBQWlCLFVBQUN4TCxHQUFELEVBQTBCO1lBQ3BDeUwsUUFBTCxHQUFnQnpMLEdBQWhCO2FBR0YwTCxPQUFPLFVBQUNDLE9BQUQsRUFBcUI7VUFDdEIsTUFBS0YsUUFBVCxFQUFtQjswQkFDVSxNQUFLLzJCLEtBRGY7WUFDVGszQixTQURTLGVBQ1RBLFFBRFM7WUFDQ0YsS0FERCxlQUNDQSxJQUREOztvQ0FFTyxNQUFLRCxRQUFMLENBQWM1VSxxQkFBZCxFQUZQO1lBRVQ3WSxJQUZTLHlCQUVUQSxJQUZTO1lBRUgyQixLQUZHLHlCQUVIQSxLQUZHOztZQUdYa3NCLFVBQVVsMkIsS0FBSytYLEdBQUwsQ0FBUyxDQUFULEVBQVkvWCxLQUFLbTJCLEdBQUwsQ0FBUyxDQUFDSCxVQUFVM3RCLElBQVgsSUFBbUIyQixLQUE1QixFQUFtQyxDQUFuQyxDQUFaLENBQWhCO1lBQ01vc0IsVUFBVUYsVUFBVUQsU0FBMUI7Y0FDS0csT0FBTDs7YUFJSkMsWUFBWSxVQUFDL2dCLEtBQUQ7YUFDVkEsTUFBTW1ZLGVBQU4sRUFEVTthQUdackssa0JBQWtCLFVBQUM5TixLQUFELEVBQWdEO1lBQzNEaEUsUUFBTCxDQUFjLEVBQUVnbEIsU0FBUyxJQUFYLEVBQWQ7WUFDS1AsSUFBTCxDQUFVemdCLE1BQU0wZ0IsT0FBaEI7YUFHRk8sa0JBQWtCLFVBQUNqaEIsS0FBRCxFQUFnRDtVQUN4RGdoQixPQUR3RCxHQUM1QyxNQUFLbGxCLEtBRHVDLENBQ3hEa2xCLE9BRHdEOztVQUU1REEsT0FBSixFQUFhO2NBQ05QLElBQUwsQ0FBVXpnQixNQUFNMGdCLE9BQWhCOzthQUlKM1MsZ0JBQWdCLFlBQU07WUFDZi9SLFFBQUwsQ0FBYyxFQUFFZ2xCLFNBQVMsS0FBWCxFQUFkOzs7Ozs7NkJBS087bUJBQzJCLEtBQUt2M0IsS0FEaEM7VUFDQ3kzQixXQURELFVBQ0NBLFdBREQ7VUFDY1AsUUFEZCxVQUNjQSxRQURkOztVQUVEanNCLFFBQVdoSyxLQUFLZ29CLEtBQUwsQ0FBV3dPLGNBQWMsS0FBZCxHQUFzQlAsUUFBakMsSUFBNkMsR0FBeEQsTUFBTjthQUVFaHJCO1dBQUE7O29CQUNXLFVBRFg7bUJBRVUsTUFGVjtnQkFHTyxNQUhQO3NCQUlhLFFBSmI7a0JBS1U7Ozs7OzZCQUdTZ3JCLFFBRGpCOzZCQUVnQixHQUZoQjs2QkFHaUJPLFdBSGpCO3VCQUlhdDRCLFVBQU80M0IsUUFKcEI7cUJBS1csS0FBS08sU0FMaEI7d0JBTWMsS0FBS0EsU0FObkI7eUJBT2UsS0FBS2pULGVBUHBCO3lCQVFlLEtBQUttVCxlQVJwQjt1QkFTYSxLQUFLbFQsYUFUbEI7aUJBVU8sS0FBS3dTLGNBVlo7a0JBV08sYUFYUDtzQkFZVzs7O2VBRVQ7O3dCQUFBO3lCQUFBO3dCQUdXLFVBSFg7cUJBSVEsV0FKUjtxQkFLUSxTQUxSO3NCQU1VOztnQ0FFUCxHQUFELElBQUssT0FBTSxPQUFYLEVBQW1CLE9BQU0sU0FBekIsRUFBbUMsUUFBTyxNQUExQyxFQUFpRCxPQUFPN3JCLEtBQXhEO1dBdEJKOztlQXdCRTs7d0JBQ1csVUFEWDtxQkFFUSxTQUZSO3NCQUdVLENBSFY7eUNBSTZCLEVBQUVFLFNBQVMsRUFBRTdCLE1BQU0yQixLQUFSLEVBQVg7O2dDQUUxQixHQUFEO3FCQUNRLFFBRFI7cUJBRVMsRUFGVDtzQkFHVSxFQUhWO3FCQUlRLE9BSlI7MEJBS2MsQ0FBQyxDQUxmO3lDQU02QixFQUFFRSxTQUFTLEVBQUV2SixXQUFXLENBQUMsQ0FBZCxFQUFYOzs7O09BNUNyQzs7OztFQWpEdUN3UDs7QUFBdEJ5bEIsY0FDWnJxQixZQUFZO2VBQ0pKLFVBQVVVLE1BQVYsQ0FBaUJnRCxVQURiO1lBRVAxRCxVQUFVVSxNQUFWLENBQWlCZ0QsVUFGVjtRQUdYMUQsVUFBVWlGLElBQVYsQ0FBZXZCOzs7QUNTekIsSUFBTTRuQixvQkFBb0IsU0FBcEJBLGlCQUFvQjs7O2FBRWZBLGlCQUFUOzthQUVTQyx1QkFGVDs7YUFJU0Msb0JBSlQ7O2FBTVNDOztDQVJYOztBQVVBLElBQU1DLGVBQWUsU0FBZkEsWUFBZSxDQUFDQyxJQUFELEVBQW1CO01BQ2hDcHRCLFVBQVUxSixLQUFLZ29CLEtBQUwsQ0FBVzhPLFFBQVEsQ0FBbkIsQ0FBaEI7TUFDTUMsVUFBVS8yQixLQUFLZ29CLEtBQUwsQ0FBV3RlLFVBQVUsRUFBckIsQ0FBaEI7TUFDTXN0QixVQUFVdHRCLFVBQVVxdEIsVUFBVSxFQUFwQztNQUNNRSxhQUFhRixVQUFVLEVBQVYsU0FBbUJBLE9BQW5CLEdBQStCQSxPQUFsRDtNQUNNRyxhQUFhRixVQUFVLEVBQVYsU0FBbUJBLE9BQW5CLEdBQStCQSxPQUFsRDtTQUNVQyxVQUFWLFNBQXdCQyxVQUF4QjtDQU5GOztJQVNNQzs7Ozs7Ozs7Ozs7Ozs7bU1Bb0JKQyx5QkFBeUIsaUJBTW5CO1VBTEo5aEIsS0FLSSxTQUxKQSxLQUtJO1VBQ0kraEIsa0JBREosR0FDMkIsTUFBS3Q0QixLQURoQyxDQUNJczRCLGtCQURKOztZQUVFNUosZUFBTjs7YUFJRjZKLHNCQUFzQixpQkFNaEI7VUFMSmhpQixLQUtJLFNBTEpBLEtBS0k7d0JBQ2lDLE1BQUt2VyxLQUR0QztVQUNJdzRCLE9BREosZUFDSUEsT0FESjtVQUNhQyxPQURiLGVBQ2FBLE9BRGI7VUFDc0JDLE1BRHRCLGVBQ3NCQSxNQUR0Qjs7VUFFQUYsT0FBSixFQUFhO2dCQUNIamlCLEtBQVI7T0FERixNQUVPO2VBQ0VBLEtBQVA7O2FBSUpvaUIscUJBQXFCLGlCQVFmO1VBUEpwaUIsS0FPSSxTQVBKQSxLQU9JO1VBQ0lxaUIsY0FESixHQUN1QixNQUFLNTRCLEtBRDVCLENBQ0k0NEIsY0FESjs7cUJBRVdyaUIsS0FBZjs7Ozs7OzZCQUdPO21CQWNILEtBQUt2VyxLQWRGO1VBRUw2NEIsMEJBRkssVUFFTEEsMEJBRks7VUFHTEMsMEJBSEssVUFHTEEsMEJBSEs7VUFJTEMsc0JBSkssVUFJTEEsc0JBSks7VUFLTEMsdUJBTEssVUFLTEEsdUJBTEs7VUFNTEMsc0JBTkssVUFNTEEsc0JBTks7VUFPTEMsd0JBUEssVUFPTEEsd0JBUEs7VUFRTHpCLFdBUkssVUFRTEEsV0FSSztVQVNMUCxRQVRLLFVBU0xBLFFBVEs7VUFVTGlDLFVBVkssVUFVTEEsVUFWSztVQVdMWCxPQVhLLFVBV0xBLE9BWEs7VUFZTHhCLElBWkssVUFZTEEsSUFaSztVQWFMb0MsTUFiSyxVQWFMQSxNQWJLOztVQWVEQyxRQUFRRCxXQUFXLENBQXpCO1VBQ01FLHVCQUNKLE9BQU83WixRQUFQLEtBQW9CLFdBQXBCLElBQW1DLENBQUMsQ0FBQ2lZLG1CQUR2QzthQUdFeHJCOztVQUFLLFdBQVcvTSxVQUFPbzZCLFFBQXZCOzthQUNFO1lBQUssU0FBUyxDQUFkOztxQkFDRTtjQUFXLFNBQVMsS0FBS2hCLG1CQUF6QixFQUE4QyxXQUFXLEtBQXpEO2dDQUNHLElBQUQ7a0NBRUlDLFVBQVVRLHVCQUFWLEdBQW9DQyxzQkFGeEM7cUJBSVEsT0FKUjtvQkFLUVQsVUFBVSxPQUFWLEdBQW9CLE1BTDVCO29CQU1ROzs7U0FUZDs7YUFhRTtZQUFLLE9BQU8sRUFBWixFQUFnQixTQUFTLENBQXpCOztnQkFDRTtjQUFNLE9BQU0sT0FBWixFQUFvQixPQUFNLE9BQTFCLEVBQWtDLE1BQUssSUFBdkM7eUJBQ2dCZixXQUFiOztTQWZQOzthQWtCRTtZQUFLLFNBQVMsQ0FBZCxFQUFpQixNQUFLLE1BQXRCOzhCQUNHLGFBQUQ7eUJBQ2VBLFdBRGY7c0JBRVlQLFFBRlo7a0JBR1FGOztTQXRCWjs7YUF5QkU7WUFBSyxPQUFPLEVBQVosRUFBZ0IsU0FBUyxDQUF6Qjs7Z0JBQ0U7Y0FBTSxPQUFNLE9BQVosRUFBb0IsT0FBTSxPQUExQixFQUFrQyxNQUFLLElBQXZDO3lCQUNnQkUsUUFBYjs7U0EzQlA7O2FBOEJFO1lBQUssU0FBUyxDQUFkOztxQkFDRTtjQUFXLFNBQVMsS0FBS3lCLGtCQUF6QixFQUE2QyxXQUFXLEtBQXhEO2dDQUNHLElBQUQ7a0NBRUlVLFFBQVFILHdCQUFSLEdBQW1DSCxzQkFGdkM7cUJBSVEsT0FKUjtvQkFLUU0sUUFBUSxNQUFSLEdBQWlCLE9BTHpCO29CQU1ROzs7U0F0Q2Q7Z0NBMkNJbnRCO2FBQUE7WUFBSyxTQUFTLENBQWQ7O3FCQUNFO2NBQVcsU0FBUyxLQUFLbXNCLHNCQUF6QixFQUFpRCxXQUFXLEtBQTVEO2dDQUNHLElBQUQ7a0NBRUljLGFBQ0lMLDBCQURKLEdBRUlELDBCQUpSO3FCQU1RLE9BTlI7b0JBT1FNLGFBQWEsVUFBYixHQUEwQixVQVBsQztvQkFRUTs7OztPQXREbEI7Ozs7RUE5RXdCL25COztBQUF0QmduQixjQUNHNXJCLFlBQVk7OEJBQ1dKLFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUQ1Qjs4QkFFVzFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUY1QjswQkFHTzFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUh4QjsyQkFJUTFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUp6QjswQkFLTzFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQUx4Qjs0QkFNUzFELFVBQVVZLE1BQVYsQ0FBaUI4QyxVQU4xQjtlQU9KMUQsVUFBVVUsTUFBVixDQUFpQmdELFVBUGI7WUFRUDFELFVBQVVVLE1BQVYsQ0FBaUJnRCxVQVJWO2NBU0wxRCxVQUFVUyxJQUFWLENBQWVpRCxVQVRWO3NCQVVHMUQsVUFBVWlGLElBQVYsQ0FBZXZCLFVBVmxCO1dBV1IxRCxVQUFVaUYsSUFBVixDQUFldkIsVUFYUDtVQVlUMUQsVUFBVWlGLElBQVYsQ0FBZXZCLFVBWk47a0JBYUQxRCxVQUFVaUYsSUFBVixDQUFldkIsVUFiZDtXQWNSMUQsVUFBVVMsSUFBVixDQUFlaUQsVUFkUDtRQWVYMUQsVUFBVWlGLElBQVYsQ0FBZXZCLFVBZko7VUFnQlQxRCxVQUFVVSxNQUFWLENBQWlCZ0Q7OztBQ1M3Qjs7O0FBR0EsSUFBTTBwQixvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFDdFIsT0FBRCxFQUEwQjtNQUM5Q0EsUUFBUXNSLGlCQUFaLEVBQStCO1lBQ3JCQSxpQkFBUjs7R0FERixNQUdPLElBQUl0UixRQUFRdVIsdUJBQVosRUFBcUM7O1lBRWxDQSx1QkFBUjs7R0FGSyxNQUlBLElBQUl2UixRQUFRd1Isb0JBQVosRUFBa0M7O1lBRS9CQSxvQkFBUjs7R0FGSyxNQUlBLElBQUl4UixRQUFReVIsbUJBQVosRUFBaUM7O1lBRTlCQSxtQkFBUjs7Q0FkSjs7QUFrQkEsSUFBTUMsaUJBQWlCLFNBQWpCQSxjQUFpQixHQUFNOztNQUV2Qm5hLFNBQVNtYSxjQUFiLEVBQTZCOzthQUVsQkEsY0FBVDs7R0FGRixNQUlPLElBQUluYSxTQUFTb2Esb0JBQWIsRUFBbUM7O2FBRS9CQSxvQkFBVDs7R0FGSyxNQUlBLElBQUlwYSxTQUFTcWEsbUJBQWIsRUFBa0M7O2FBRTlCQSxtQkFBVDs7R0FGSyxNQUlBLElBQUlyYSxTQUFTc2EsZ0JBQWIsRUFBK0I7O2FBRTNCQSxnQkFBVDs7Q0FoQko7Ozs7QUFzQkEsSUFBTUMsZUFBZSxTQUFmQSxZQUFlOzs7YUFFVkMsaUJBQVQ7O2FBRVNDLHVCQUZUOzthQUlTQyxvQkFKVDs7YUFNU0M7O0NBUlg7O0FBVUEsSUFBTUMsNkJBQTZCLFNBQTdCQSwwQkFBNkIsQ0FBQ0MsUUFBRCxFQUE2QjtXQUNyRGhhLGdCQUFULENBQTBCLGtCQUExQixFQUE4Q2dhLFFBQTlDO1dBQ1NoYSxnQkFBVCxDQUEwQix3QkFBMUIsRUFBb0RnYSxRQUFwRDtXQUNTaGEsZ0JBQVQsQ0FBMEIscUJBQTFCLEVBQWlEZ2EsUUFBakQ7V0FDU2hhLGdCQUFULENBQTBCLG9CQUExQixFQUFnRGdhLFFBQWhEO0NBSkY7O0FBT0EsSUFBTUMsZ0NBQWdDLFNBQWhDQSw2QkFBZ0MsQ0FBQ0QsUUFBRCxFQUE2QjtXQUN4RDVaLG1CQUFULENBQTZCLGtCQUE3QixFQUFpRDRaLFFBQWpEO1dBQ1M1WixtQkFBVCxDQUE2Qix3QkFBN0IsRUFBdUQ0WixRQUF2RDtXQUNTNVosbUJBQVQsQ0FBNkIscUJBQTdCLEVBQW9ENFosUUFBcEQ7V0FDUzVaLG1CQUFULENBQTZCLG9CQUE3QixFQUFtRDRaLFFBQW5EO0NBSkY7O0FBT0EsSUFBTUUsY0FBYyxTQUFkQSxXQUFjLENBQUNDLFNBQUQsRUFBb0JDLFNBQXBCLEVBQW1EO01BQ2pFLFFBQU9ELFNBQVAseUNBQU9BLFNBQVAsZUFBNEJDLFNBQTVCLHlDQUE0QkEsU0FBNUIsRUFBSixFQUEyQzs7O1dBR2xDLElBQVA7O01BRUU5NkIsTUFBTSs2QixPQUFOLENBQWNELFNBQWQsQ0FBSixFQUE4QjtRQUN4QkQsVUFBVW42QixNQUFWLEtBQXFCbzZCLFVBQVVwNkIsTUFBbkMsRUFBMkM7OzthQUdsQyxJQUFQOzs7O1dBSUtvNkIsVUFBVTlOLElBQVYsQ0FDTCxVQUFDZ08sTUFBRCxFQUFTamYsS0FBVDthQUNFLENBQUMvYixNQUFNKzZCLE9BQU4sQ0FBY0YsU0FBZCxDQUFELElBQ0FHLE9BQU8va0IsSUFBUCxLQUFnQjRrQixVQUFVOWUsS0FBVixFQUFpQjlGLElBRGpDLElBRUEra0IsT0FBT3JxQixHQUFQLEtBQWVrcUIsVUFBVTllLEtBQVYsRUFBaUJwTCxHQUhsQztLQURLLENBQVA7Ozs7U0FTS21xQixjQUFjRCxTQUFyQjtDQXZCRjs7SUEwQnFCSTs7Ozs7Ozs7Ozs7Ozs7bUxBK0NuQnhvQixRQUFRO21CQUNPLENBRFA7Z0JBRUksQ0FGSjtrQkFHTTthQTJEZHlvQixlQUFlLFVBQUN4UCxHQUFELEVBQTBCO1lBQ2xDeVAsTUFBTCxHQUFjelAsR0FBZDthQUlGMFAsY0FBYyxVQUFDMVAsR0FBRCxFQUE0QjtZQUNuQzJQLEtBQUwsR0FBYTNQLEdBQWI7YUFRRjRQLGtCQUFrQixVQUFDQyxZQUFELEVBQTBCO1VBQ3RDLE1BQUtGLEtBQVQsRUFBZ0I7Y0FDVEEsS0FBTCxDQUFXRSxZQUFYLEdBQTBCQSxZQUExQjs7YUFLSkMsWUFBWSxVQUFDaEMsTUFBRCxFQUFvQjtVQUMxQixNQUFLNkIsS0FBVCxFQUFnQjtjQUNUQSxLQUFMLENBQVc3QixNQUFYLEdBQW9CQSxNQUFwQjs7YUFLSmlDLE9BQU8sWUFBTTtVQUNQLE1BQUtKLEtBQVQsRUFBZ0I7Y0FDVEEsS0FBTCxDQUFXSSxJQUFYOzthQUtKQyxRQUFRLFlBQU07VUFDUixNQUFLTCxLQUFULEVBQWdCO2NBQ1RBLEtBQUwsQ0FBV0ssS0FBWDs7YUFLSkMsT0FBTyxZQUFNO1VBQ1AsTUFBS04sS0FBVCxFQUFnQjtjQUNUQSxLQUFMLENBQVdNLElBQVg7O2FBS0p2RSxPQUFPLFVBQUNlLElBQUQsRUFBa0I7VUFDbkIsTUFBS2tELEtBQVQsRUFBZ0I7Y0FDVEEsS0FBTCxDQUFXeEQsV0FBWCxHQUF5Qk0sSUFBekI7O2FBS0p5RCxtQkFBbUIsWUFBTTtVQUNuQnhCLGNBQUosRUFBb0I7O09BQXBCLE1BRU8sSUFBSSxNQUFLZSxNQUFULEVBQWlCOzBCQUNKLE1BQUtBLE1BQXZCOzthQVNKVSxnQkFBZ0IsVUFBQ2xsQixLQUFELEVBQTZDO1VBQ25EbWxCLE9BRG1ELEdBQ3ZDLE1BQUsxN0IsS0FEa0MsQ0FDbkQwN0IsT0FEbUQ7OztVQUd2REEsT0FBSixFQUFhO2dCQUNILEVBQUVubEIsWUFBRixFQUFSOzthQU1Kb2xCLHVCQUF1QixVQUFDcGxCLEtBQUQsRUFBNkM7VUFDMURxbEIsZ0JBRDBELEdBQ3JDLE1BQUs1N0IsS0FEZ0MsQ0FDMUQ0N0IsZ0JBRDBEOztVQUU1RDFFLFdBQVksTUFBSytELEtBQUwsSUFBYyxNQUFLQSxLQUFMLENBQVcvRCxRQUExQixJQUF1QyxDQUF4RDtZQUNLM2tCLFFBQUwsQ0FBYyxFQUFFMmtCLGtCQUFGLEVBQWQ7O1VBRUkwRSxnQkFBSixFQUFzQjt5QkFDSCxFQUFFcmxCLFlBQUYsRUFBUzJnQixrQkFBVCxFQUFqQjs7YUFLSjJFLGNBQWMsVUFBQ3RsQixLQUFELEVBQTZDO1VBQ2pEdWxCLE9BRGlELEdBQ3JDLE1BQUs5N0IsS0FEZ0MsQ0FDakQ4N0IsT0FEaUQ7OztVQUdyREEsT0FBSixFQUFhO2dCQUNILEVBQUV2bEIsWUFBRixFQUFSOzthQUtKOGhCLHlCQUF5QixVQUFDOWhCLEtBQUQsRUFBa0I7VUFDakMraEIsa0JBRGlDLEdBQ1YsTUFBS3Q0QixLQURLLENBQ2pDczRCLGtCQURpQzs7VUFFbkNhLGFBQWEsQ0FBQyxDQUFDYSxjQUFyQjtZQUNLem5CLFFBQUwsQ0FBYyxFQUFFNG1CLHNCQUFGLEVBQWQ7O1VBRUliLGtCQUFKLEVBQXdCOzJCQUNILEVBQUUvaEIsWUFBRixFQUFTNGlCLHNCQUFULEVBQW5COzthQUtKNEMsYUFBYSxVQUFDeGxCLEtBQUQsRUFBMkM7VUFDOUNtaUIsTUFEOEMsR0FDbkMsTUFBSzE0QixLQUQ4QixDQUM5QzA0QixNQUQ4Qzs7O1VBR2xEQSxNQUFKLEVBQVk7ZUFDSCxFQUFFbmlCLFlBQUYsRUFBUDs7YUFLSnlsQixjQUFjLFVBQUN6bEIsS0FBRCxFQUEyQztVQUMvQ2tpQixPQUQrQyxHQUNuQyxNQUFLejRCLEtBRDhCLENBQy9DeTRCLE9BRCtDOzs7VUFHbkRBLE9BQUosRUFBYTtnQkFDSCxFQUFFbGlCLFlBQUYsRUFBUjs7YUFLSjBsQixpQkFBaUIsVUFBQzFsQixLQUFELEVBQTZDO1VBQ3BEMmxCLGNBRG9ELEdBQ2pDLE1BQUtsOEIsS0FENEIsQ0FDcERrOEIsY0FEb0Q7O2tCQUV2QyxNQUFLakIsS0FBTCxJQUFjLEVBRnlCO1VBRXBEa0IsUUFGb0QsU0FFcERBLFFBRm9EOztVQUd0REMsU0FDSkQsWUFBWUEsU0FBUzc3QixNQUFULEdBQWtCLENBQTlCLEdBQWtDNjdCLFNBQVNFLEdBQVQsQ0FBYUYsU0FBUzc3QixNQUFULEdBQWtCLENBQS9CLENBQWxDLEdBQXNFLENBRHhFOztVQUdJNDdCLGNBQUosRUFBb0I7dUJBQ0gsRUFBRTNsQixZQUFGLEVBQVM2bEIsY0FBVCxFQUFmOzthQUtKRSxhQUFhLFVBQUMvbEIsS0FBRCxFQUE2QztVQUNoRGdtQixNQURnRCxHQUNyQyxNQUFLdjhCLEtBRGdDLENBQ2hEdThCLE1BRGdEOzs7VUFHcERBLE1BQUosRUFBWTtlQUNILEVBQUVobUIsWUFBRixFQUFQOzthQUtKaW1CLG1CQUFtQixVQUFDam1CLEtBQUQsRUFBNkM7VUFDdERrbUIsWUFEc0QsR0FDckMsTUFBS3o4QixLQURnQyxDQUN0RHk4QixZQURzRDs7VUFFeERoRixjQUFlLE1BQUt3RCxLQUFMLElBQWMsTUFBS0EsS0FBTCxDQUFXeEQsV0FBMUIsSUFBMEMsQ0FBOUQ7WUFDS2xsQixRQUFMLENBQWMsRUFBRWtsQix3QkFBRixFQUFkOztVQUVJZ0YsWUFBSixFQUFrQjtxQkFDSCxFQUFFbG1CLFlBQUYsRUFBU3doQixNQUFNTixXQUFmLEVBQWI7O2FBS0prQixxQkFBcUIsVUFBQ3BpQixLQUFELEVBQTJDO1VBQ3REcWlCLGNBRHNELEdBQ25DLE1BQUs1NEIsS0FEOEIsQ0FDdEQ0NEIsY0FEc0Q7O1VBRXhEUyxRQUFTLE1BQUs0QixLQUFMLElBQWMsTUFBS0EsS0FBTCxDQUFXNUIsS0FBMUIsSUFBb0MsS0FBbEQ7O1VBRUlULGNBQUosRUFBb0I7dUJBQ0gsRUFBRXJpQixZQUFGLEVBQVM2aUIsUUFBUUMsUUFBUSxDQUFSLEdBQVksQ0FBN0IsRUFBZjs7Ozs7Ozs7Ozs7Ozt3Q0F6TmdCO21CQUN3QixLQUFLcjVCLEtBRDdCO1VBQ1ZtN0IsWUFEVSxVQUNWQSxZQURVO1VBQ0kzQyxPQURKLFVBQ0lBLE9BREo7VUFDYVksTUFEYixVQUNhQSxNQURiOzs7O1VBSWQsT0FBTzNaLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUM7bUNBQ1IsS0FBSzRZLHNCQUFoQzs7O1dBR0dnRCxJQUFMOztXQUVLRCxTQUFMLENBQWVoQyxNQUFmOztXQUVLOEIsZUFBTCxDQUFxQkMsWUFBckI7O1VBRUkzQyxPQUFKLEVBQWE7YUFDTitDLElBQUw7Ozs7O3VDQUllanJCLFdBQWtCOztVQUUvQmtxQixZQUFZbHFCLFVBQVVDLEdBQXRCLEVBQTJCLEtBQUt2USxLQUFMLENBQVd1USxHQUF0QyxDQUFKLEVBQWdEO2FBQ3pDOHFCLElBQUw7OztVQUdFL3FCLFVBQVU4b0IsTUFBVixLQUFxQixLQUFLcDVCLEtBQUwsQ0FBV281QixNQUFwQyxFQUE0QzthQUNyQ2dDLFNBQUwsQ0FBZSxLQUFLcDdCLEtBQUwsQ0FBV281QixNQUExQjs7O1VBR0U5b0IsVUFBVTZxQixZQUFWLEtBQTJCLEtBQUtuN0IsS0FBTCxDQUFXbTdCLFlBQTFDLEVBQXdEO2FBQ2pERCxlQUFMLENBQXFCLEtBQUtsN0IsS0FBTCxDQUFXbTdCLFlBQWhDOzs7VUFHRTdxQixVQUFVa29CLE9BQVYsS0FBc0IsS0FBS3g0QixLQUFMLENBQVd3NEIsT0FBckMsRUFBOEM7WUFDeEMsS0FBS3g0QixLQUFMLENBQVd3NEIsT0FBZixFQUF3QjtlQUNqQitDLElBQUw7U0FERixNQUVPO2VBQ0FELEtBQUw7Ozs7OzsyQ0FLaUI7b0NBQ1MsS0FBS2pELHNCQUFuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXNMTztvQkFXSCxLQUFLcjRCLEtBWEY7VUFFTGdsQixXQUZLLFdBRUxBLFdBRks7VUFHTDBYLFFBSEssV0FHTEEsUUFISztVQUlMQyxJQUpLLFdBSUxBLElBSks7VUFLTG5FLE9BTEssV0FLTEEsT0FMSztVQU1Mb0UsV0FOSyxXQU1MQSxXQU5LO1VBT0xDLE1BUEssV0FPTEEsTUFQSztVQVFMQyxPQVJLLFdBUUxBLE9BUks7VUFTTHZzQixHQVRLLFdBU0xBLEdBVEs7VUFVTDZvQixNQVZLLFdBVUxBLE1BVks7bUJBWXVDLEtBQUsvbUIsS0FaNUM7VUFZQ29sQixXQVpELFVBWUNBLFdBWkQ7VUFZY1AsUUFaZCxVQVljQSxRQVpkO1VBWXdCaUMsVUFaeEIsVUFZd0JBLFVBWnhCOzs7VUFjRHhuQixnQkFBaUJ3bkIsY0FBYyxHQUFmLElBQTBCLElBQUluVSxXQUFKLEdBQWtCLEdBQTVDLE1BQXRCOzthQUdFOVk7OztlQUNPLEtBQUs0dUIsWUFEWjtxQkFFYTM3QixVQUFPNDdCLE1BRnBCO2lCQUdTLEVBQUVwcEIsNEJBQUYsRUFBaUJsSixRQUFRMHdCLGFBQWEsTUFBYixHQUFzQixDQUEvQzs7Ozs7c0JBR0tYLE9BRFo7a0JBRVFtRSxJQUZSO21CQUdTdkQsV0FBVyxDQUhwQjt5QkFJZXdELFdBSmY7b0JBS1VDLE1BTFY7cUJBTVdDLE9BTlg7aUJBT08sT0FBT3ZzQixHQUFQLEtBQWUsUUFBZixHQUEwQkEsR0FBMUIsR0FBZ0NYLFNBUHZDO2lCQVFPLEtBQUtvckIsV0FSWjt1QkFTYTc3QixVQUFPODdCLEtBVHBCO3VCQVVhLEtBQUtRLGFBVmxCOzhCQVdvQixLQUFLRSxvQkFYekI7cUJBWVcsS0FBS0UsV0FaaEI7c0JBYVksS0FBS1MsVUFiakI7MEJBY2dCLEtBQUtFLGdCQWRyQjt3QkFlYyxLQUFLUDs7Z0JBRVZ0QixPQUFOLENBQWNwcUIsR0FBZCxLQUNDQSxJQUFJelEsR0FBSixDQUFRO21CQUNOb00sZ0NBQVEsS0FBSzB1QixPQUFPcnFCLEdBQXBCLEVBQXlCLEtBQUtxcUIsT0FBT3JxQixHQUFyQyxFQUEwQyxNQUFNcXFCLE9BQU8va0IsSUFBdkQsR0FETTtXQUFSLENBbEJKO3lDQXFCUyxNQUFLLFVBQVosRUFBdUIsS0FBSzZtQixRQUE1QjtTQTFCSjthQTZCUTE4QixLQUFMLENBQVd1NUIsUUFBWCxJQUNDcnRCLG9CQUFDLGFBQUQ7c0NBQzhCLEtBQUtsTSxLQUFMLENBQVc2NEIsMEJBRHpDO3NDQUU4QixLQUFLNzRCLEtBQUwsQ0FBVzg0QiwwQkFGekM7a0NBRzBCLEtBQUs5NEIsS0FBTCxDQUFXKzRCLHNCQUhyQzttQ0FJMkIsS0FBSy80QixLQUFMLENBQVdnNUIsdUJBSnRDO2tDQUswQixLQUFLaDVCLEtBQUwsQ0FBV2k1QixzQkFMckM7b0NBTTRCLEtBQUtqNUIsS0FBTCxDQUFXazVCLHdCQU52Qzt1QkFPZXpCLFdBUGY7b0JBUVlQLFFBUlo7c0JBU2NpQyxVQVRkO2tCQVVVLEtBQUs0QyxVQVZmO21CQVdXLEtBQUtDLFdBWGhCOzhCQVlzQixLQUFLUixnQkFaM0I7MEJBYWtCLEtBQUs3QyxrQkFidkI7bUJBY1dILE9BZFg7Z0JBZVEsS0FBS3hCLElBZmI7a0JBZ0JVb0M7O09BL0NoQjs7OztFQTFTK0Job0I7O0FBQWR5cEIsTUFDWnJ1QixZQUFZOzhCQUNXSixVQUFVWSxNQURyQjs4QkFFV1osVUFBVVksTUFGckI7MEJBR09aLFVBQVVZLE1BSGpCOzJCQUlRWixVQUFVWSxNQUpsQjswQkFLT1osVUFBVVksTUFMakI7NEJBTVNaLFVBQVVZLE1BTm5CO2VBT0paLFVBQVVVLE1BQVYsQ0FBaUJnRCxVQVBiO1lBUVAxRCxVQUFVWSxNQUFWLENBQWlCOEMsVUFSVjtZQVNQMUQsVUFBVVMsSUFUSDtRQVVYVCxVQUFVUyxJQVZDO29CQVdDVCxVQUFVaUYsSUFYWDtXQVlSakYsVUFBVWlGLElBWkY7c0JBYUdqRixVQUFVaUYsSUFiYjtrQkFjRGpGLFVBQVVpRixJQWRUO1VBZVRqRixVQUFVaUYsSUFmRDtXQWdCUmpGLFVBQVVpRixJQWhCRjtXQWlCUmpGLFVBQVVpRixJQWpCRjtVQWtCVGpGLFVBQVVpRixJQWxCRDtnQkFtQkhqRixVQUFVaUYsSUFuQlA7a0JBb0JEakYsVUFBVWlGLElBcEJUO2dCQXFCSGpGLFVBQVVVLE1BckJQO1dBc0JSVixVQUFVUyxJQXRCRjtlQXVCSlQsVUFBVVMsSUF2Qk47VUF3QlRULFVBQVVZLE1BeEJEO1dBeUJSWixVQUFVQyxLQUFWLENBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUIsTUFBckIsQ0FBaEIsQ0F6QlE7T0EwQlpELFVBQVVRLFNBQVYsQ0FBb0IsQ0FDdkJSLFVBQVVZLE1BRGEsRUFFdkJaLFVBQVVzTixPQUFWLENBQ0V0TixVQUFVVyxLQUFWLENBQWdCO1VBQ1JYLFVBQVVDLEtBQVYsQ0FBZ0IsQ0FBQyxZQUFELEVBQWUsV0FBZixFQUE0QixXQUE1QixDQUFoQixFQUNIeUQsVUFGVztTQUdUMUQsVUFBVVksTUFBVixDQUFpQjhDO0dBSHhCLENBREYsQ0FGdUIsQ0FBcEIsRUFTRkEsVUFuQ2M7VUFvQ1QxRCxVQUFVVTs7QUFyQ0QrdEIsTUF3Q1p2cEIsZUFBZTtnQkFDTixDQURNO1dBRVgsS0FGVztXQUdYLE1BSFc7VUFJWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
